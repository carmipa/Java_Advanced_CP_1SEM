Script: converte-classes-java-em-txt-unico
Data de criação do arquivo de saída: 2025-04-30 16:15:10

Estrutura de diretórios do projeto:
fiap/
    controller/
    dto/
        agenda/
        cliente/
        contato/
        endereco/
        oficina/
        orcamento/
        pagamento/
        pecas/
        relatorio/
        veiculo/
    exception/
    mapper/
    model/
        relacionamentos/
    repository/
        relacionamentos/
        specification/
    service/
        agenda/
        cep/
        clientes/
        ia/
        oficina/
        orcamento/
        pagamento/
        pecas/
        relatorio/
            cliente/
        veiculo/

// --- Arquivo: App.java
// --- Classe: App
package br.com.fiap;

import io.swagger.v3.oas.annotations.OpenAPIDefinition;
import io.swagger.v3.oas.annotations.info.Info;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean; // <-- Importar @Bean
import org.springframework.context.annotation.ComponentScan;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.web.client.RestTemplate; // <-- Importar RestTemplate

@EnableJpaRepositories
@SpringBootApplication
@ComponentScan(basePackages = "br.com.fiap")
@EnableCaching
@OpenAPIDefinition(info = @Info(title = "PROJETO-SEMESTRAL-1.0", description = "REFATORAÇÃO DO CHALLENGE 2024", version = "v1"))
public class App {

	public static void main(String[] args) {
		SpringApplication.run(App.class, args);
	}

	// Adiciona este método para criar o Bean do RestTemplate
	@Bean
	public RestTemplate restTemplate() {
		return new RestTemplate();
	}

}

// --- Arquivo: controller\AgendaController.java
// --- Classe: AgendaController
// src/main/java/br/com/fiap/Controller/AgendaController.java
package br.com.fiap.controller;

import br.com.fiap.dto.agenda.AgendaRequestDto;
import br.com.fiap.dto.agenda.AgendaResponseDto;
import br.com.fiap.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.exception.AgendaNotFoundException;
import br.com.fiap.exception.AssociacaoNotFoundException;
import br.com.fiap.exception.VeiculoNotFoundException;
import br.com.fiap.service.agenda.AgendaService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag; // <<< Importar Tag
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.time.LocalDate;
import java.util.List;

@RestController
@RequestMapping("/rest/agenda")
@CrossOrigin(origins = "http://localhost:3000")
@Tag(name = "Agendamentos", description = "Operações relacionadas a agendamentos de serviços") // <<< TAG ATUALIZADA
public class AgendaController {

    private static final Logger log = LoggerFactory.getLogger(AgendaController.class);

    @Autowired
    private AgendaService agendaService;

    @GetMapping
    @Operation(summary = "Listar Agendamentos",
            description = "Retorna uma lista paginada de agendamentos, com opções de filtro por data e observação. Parâmetros de paginação: ?page=0&size=10&sort=dataAgendamento,desc")
    @ApiResponses(value = { // <<< ApiResponses Adicionadas/Revisadas
            @ApiResponse(responseCode = "200", description = "Lista de agendamentos retornada"),
            @ApiResponse(responseCode = "204", description = "Nenhum agendamento encontrado para os filtros"),
            @ApiResponse(responseCode = "400", description = "Parâmetros de filtro ou paginação inválidos"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<Page<AgendaResponseDto>> findWithFilters(
            @Parameter(description = "Filtrar por data inicial (formato YYYY-MM-DD)") @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate dataInicio,
            @Parameter(description = "Filtrar por data final (formato YYYY-MM-DD)") @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate dataFim,
            @Parameter(description = "Filtrar por parte da observação (case-insensitive)") @RequestParam(required = false) String observacao,
            @Parameter(hidden = true) Pageable pageable
    ) {
        log.info("Requisição GET /rest/agenda com filtros e paginação recebida.");
        Page<AgendaResponseDto> paginaAgendas = agendaService.findWithFilters(dataInicio, dataFim, observacao, pageable);
        if (paginaAgendas.isEmpty()) {
            return ResponseEntity.noContent().build();
        }
        return ResponseEntity.ok(paginaAgendas);
    }

    @GetMapping("/{id}")
    @Operation(summary = "Buscar Agendamento por ID", description = "Retorna um agendamento específico pelo seu ID.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Agendamento encontrado"),
            @ApiResponse(responseCode = "404", description = "Agendamento não encontrado para o ID fornecido"), // Descrição adicionada
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<AgendaResponseDto> findById(
            @Parameter(description = "ID do agendamento a ser buscado") @PathVariable Long id // <<< @Parameter adicionado
    ) {
        try {
            AgendaResponseDto agenda = agendaService.findById(id);
            return ResponseEntity.ok(agenda);
        } catch (AgendaNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PostMapping
    @CacheEvict(value = {"agendas", "veiculosDaAgenda"}, allEntries = true)
    @Operation(summary = "Criar Novo Agendamento", description = "Registra um novo agendamento no sistema.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Agendamento criado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Dados inválidos fornecidos para o agendamento"), // Descrição adicionada
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar criar o agendamento")
    })
    public ResponseEntity<?> create(
            @Parameter(description = "Dados do agendamento para criação") // <<< @Parameter adicionado
            @RequestBody @Valid AgendaRequestDto agendaDto
    ) {
        try {
            AgendaResponseDto savedAgenda = agendaService.create(agendaDto);
            return ResponseEntity.status(HttpStatus.CREATED).body(savedAgenda);
        } catch (Exception e) {
            // Simplificado para retornar apenas o status 500, o log de erro está no service
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PutMapping("/{id}")
    @CacheEvict(value = {"agendas", "veiculosDaAgenda"}, allEntries = true)
    @Operation(summary = "Atualizar Agendamento", description = "Atualiza os dados de um agendamento existente.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Agendamento atualizado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Dados inválidos fornecidos para atualização"),
            @ApiResponse(responseCode = "404", description = "Agendamento não encontrado para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar atualizar o agendamento")
    })
    public ResponseEntity<?> update(
            @Parameter(description = "ID do agendamento a ser atualizado") @PathVariable Long id, // <<< @Parameter adicionado
            @Parameter(description = "Dados atualizados do agendamento") @RequestBody @Valid AgendaRequestDto agendaDto // <<< @Parameter adicionado
    ) {
        try {
            AgendaResponseDto updatedAgenda = agendaService.update(id, agendaDto);
            return ResponseEntity.ok(updatedAgenda);
        } catch (AgendaNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @DeleteMapping("/{id}")
    @CacheEvict(value = {"agendas", "veiculosDaAgenda"}, allEntries = true)
    @Operation(summary = "Deletar Agendamento", description = "Remove um agendamento do sistema.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Agendamento deletado com sucesso"),
            @ApiResponse(responseCode = "404", description = "Agendamento não encontrado para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar deletar o agendamento") // Ou 409 se houver conflito de integridade
    })
    public ResponseEntity<Void> delete(
            @Parameter(description = "ID do agendamento a ser deletado") @PathVariable Long id // <<< @Parameter adicionado
    ) {
        try {
            agendaService.deleteById(id);
            return ResponseEntity.noContent().build();
        } catch (AgendaNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            // Poderia verificar DataIntegrityViolationException e retornar 409 Conflict
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    // --- Endpoints de Relacionamento ---
    @PostMapping("/{agendaId}/veiculos/{veiculoId}")
    @CacheEvict(value = "veiculosDaAgenda", key = "#agendaId")
    @Operation(summary = "Associar Veículo a uma Agenda", description = "Cria uma associação entre um agendamento e um veículo existentes.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Associação criada com sucesso"),
            @ApiResponse(responseCode = "404", description = "Agenda ou Veículo não encontrado com os IDs fornecidos")
            // Poderia adicionar 409 se a associação já existir
    })
    public ResponseEntity<Void> associarVeiculo(
            @Parameter(description = "ID da agenda") @PathVariable Long agendaId,
            @Parameter(description = "ID do veículo a ser associado") @PathVariable Long veiculoId
    ) {
        log.info("Requisição para associar veículo ID {} à agenda ID {}", veiculoId, agendaId);
        try {
            agendaService.associarVeiculo(agendaId, veiculoId);
            return ResponseEntity.noContent().build();
        } catch (AgendaNotFoundException | VeiculoNotFoundException e) {
            log.warn("Erro ao associar veículo {} à agenda {}: {}", veiculoId, agendaId, e.getMessage());
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro inesperado ao associar veículo {} à agenda {}: {}", veiculoId, agendaId, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @DeleteMapping("/{agendaId}/veiculos/{veiculoId}")
    @CacheEvict(value = "veiculosDaAgenda", key = "#agendaId")
    @Operation(summary = "Desassociar Veículo de uma Agenda", description = "Remove a associação entre um agendamento e um veículo.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Associação removida com sucesso"),
            @ApiResponse(responseCode = "404", description = "Associação não encontrada entre a Agenda e o Veículo fornecidos")
    })
    public ResponseEntity<Void> desassociarVeiculo(
            @Parameter(description = "ID da agenda") @PathVariable Long agendaId,
            @Parameter(description = "ID do veículo a ser desassociado") @PathVariable Long veiculoId
    ) {
        log.info("Requisição para desassociar veículo ID {} da agenda ID {}", veiculoId, agendaId);
        try {
            agendaService.desassociarVeiculo(agendaId, veiculoId);
            return ResponseEntity.noContent().build();
        } catch (AssociacaoNotFoundException e) {
            log.warn("Erro ao desassociar veículo {} da agenda {}: {}", veiculoId, agendaId, e.getMessage());
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro inesperado ao desassociar veículo {} da agenda {}: {}", veiculoId, agendaId, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @GetMapping("/{agendaId}/veiculos")
    @Operation(summary = "Listar Veículos de uma Agenda", description = "Retorna a lista de veículos associados a um agendamento específico.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Lista de veículos retornada (pode ser vazia)"),
            @ApiResponse(responseCode = "404", description = "Agenda não encontrada com o ID fornecido")
    })
    public ResponseEntity<List<VeiculoResponseDto>> findVeiculosByAgendaId(
            @Parameter(description = "ID da agenda para a qual listar os veículos") @PathVariable Long agendaId
    ) {
        log.info("Requisição para listar veículos da agenda ID {}", agendaId);
        try {
            List<VeiculoResponseDto> veiculos = agendaService.findVeiculosByAgendaId(agendaId);
            return ResponseEntity.ok(veiculos); // Retorna 200 OK mesmo se a lista for vazia
        } catch (AgendaNotFoundException e) {
            log.warn("Agenda não encontrada para listar veículos, ID: {}", agendaId);
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro inesperado ao listar veículos da agenda {}: {}", agendaId, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}

// --- Arquivo: controller\ClienteRelatorioController.java
// --- Classe: ClienteRelatorioController
// --- Arquivo: src/main/java/br/com/fiap/controller/ClienteRelatorioController.java ---
package br.com.fiap.controller;

import br.com.fiap.dto.relatorio.ClienteRelatorioCompletoDTO;
import br.com.fiap.exception.ClientesNotFoundException;
import br.com.fiap.service.relatorio.cliente.RelatorioClienteService; // Importa o serviço de relatório
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/rest/relatorios/cliente") // <<< Novo RequestMapping base para relatórios de cliente
@CrossOrigin(origins = "http://localhost:3000")
@Tag(name = "Relatórios Cliente", description = "Endpoints para gerar relatórios específicos de clientes") // <<< Nova Tag
public class ClienteRelatorioController {

    private static final Logger log = LoggerFactory.getLogger(ClienteRelatorioController.class);

    @Autowired
    private RelatorioClienteService relatorioClienteService; // <<< Injeta o serviço de relatório

    @GetMapping("/completo") // <<< Endpoint relativo ao RequestMapping da classe
    @Operation(summary = "Relatório Completo do Cliente", description = "Busca todos os dados relacionados a um cliente por ID ou Documento.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Relatório gerado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Parâmetros de busca inválidos"),
            @ApiResponse(responseCode = "404", description = "Cliente não encontrado"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<ClienteRelatorioCompletoDTO> getRelatorioCompleto(
            @Parameter(description = "Tipo de busca: 'id' para ID_CLI ou 'documento' para CPF/CNPJ", required = true, example = "documento")
            @RequestParam String tipoBusca,
            @Parameter(description = "Valor correspondente ao tipo de busca", required = true, example = "12345678900")
            @RequestParam String valorBusca
    ) {
        log.info("Requisição GET /rest/relatorios/cliente/completo: tipo={}, valor={}", tipoBusca, valorBusca);
        try {
            ClienteRelatorioCompletoDTO relatorio = relatorioClienteService.getRelatorioCompletoCliente(tipoBusca, valorBusca);
            return ResponseEntity.ok(relatorio);
        } catch (ClientesNotFoundException e) {
            log.warn("Cliente não encontrado para relatório: tipo={}, valor={}", tipoBusca, valorBusca);
            return ResponseEntity.notFound().build(); // 404
        } catch (IllegalArgumentException e) {
            log.warn("Argumento inválido para relatório: {}", e.getMessage());
            // Retorna 400 com a mensagem de erro no corpo para o frontend
            return ResponseEntity.badRequest().body(null); // Corpo vazio ou pode criar um DTO de erro { "error": e.getMessage() }
        } catch (Exception e) {
            log.error("Erro ao gerar relatório completo para cliente: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build(); // 500
        }
    }

}

// --- Arquivo: controller\ClientesController.java
// --- Classe: ClientesController
// --- Arquivo: src/main/java/br/com/fiap/controller/ClientesController.java ---
package br.com.fiap.controller;

// --- Imports necessários para as operações restantes ---
import br.com.fiap.dto.cliente.ClienteInfoDTO;
import br.com.fiap.dto.cliente.ClienteRequestDto;
import br.com.fiap.dto.cliente.ClienteResponseDto;
import br.com.fiap.exception.ClientesNotFoundException;
import br.com.fiap.model.relacionamentos.ClienteId;
import br.com.fiap.service.clientes.ClienteService; // Apenas o ClienteService é necessário aqui
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
// Remover import do ClienteRelatorioCompletoDTO e RelatorioClienteService se existirem
import java.util.List;
// ------------------------------------------------------

@RestController
@RequestMapping("/rest/clientes") // Mapping base permanece o mesmo
@CrossOrigin(origins = "http://localhost:3000")
@Tag(name = "Clientes", description = "Gerenciamento de clientes e seus dados associados")
public class ClientesController {

    private static final Logger log = LoggerFactory.getLogger(ClientesController.class);

    @Autowired
    private ClienteService clienteService; // <<< Apenas ClienteService injetado

    // --- Endpoint de Busca de Clientes (Existente) ---
    @GetMapping("/buscar")
    @Operation(summary = "Buscar Clientes por Critérios",
            description = "Retorna uma lista de clientes (com IDs e dados básicos) que correspondem aos critérios fornecidos (nome, documento ou ID Cliente). Pelo menos um critério deve ser informado.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Busca realizada com sucesso, retornando lista de clientes"),
            @ApiResponse(responseCode = "204", description = "Nenhum cliente encontrado para os critérios fornecidos"),
            @ApiResponse(responseCode = "400", description = "Nenhum critério de busca válido foi fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<List<ClienteInfoDTO>> buscar(
            @Parameter(description = "Parte do nome ou sobrenome do cliente (case-insensitive)") @RequestParam(required = false) String nome,
            @Parameter(description = "Número exato do documento (CPF/CNPJ)") @RequestParam(required = false) String documento,
            @Parameter(description = "ID exato do cliente (ID_CLI)") @RequestParam(required = false) Long idCliente
    ) {
        log.info("Requisição GET /rest/clientes/buscar: nome={}, documento={}, idCliente={}", nome, documento, idCliente);
        if ((nome == null || nome.isBlank()) && (documento == null || documento.isBlank()) && (idCliente == null || idCliente <= 0)) {
            log.warn("Busca de clientes chamada sem nenhum critério válido.");
            return ResponseEntity.badRequest().build(); // 400
        }
        try {
            List<ClienteInfoDTO> clientes = clienteService.buscarClientes(nome, documento, idCliente);
            if (clientes.isEmpty()) {
                log.info("Nenhum cliente encontrado para os critérios fornecidos.");
                return ResponseEntity.noContent().build(); // 204
            }
            log.info("Retornando {} clientes encontrados.", clientes.size());
            return ResponseEntity.ok(clientes); // 200
        } catch (Exception e) {
            log.error("Erro ao buscar clientes: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build(); // 500
        }
    }

    // --- Endpoints CRUD (Existentes) ---
    @GetMapping("/all")
    @Cacheable("clientes")
    @Operation(summary = "Listar Todos os Clientes", description = "Retorna uma lista completa de todos os clientes cadastrados.")
    @ApiResponses(value = { /* ... */ })
    public ResponseEntity<List<ClienteResponseDto>> findAll() {
        log.info("Requisição para listar todos os clientes recebida");
        List<ClienteResponseDto> clientes = clienteService.findAll();
        if (clientes.isEmpty()) {
            log.info("Nenhum cliente encontrado.");
            return ResponseEntity.noContent().build(); // 204
        }
        log.info("Retornando {} clientes.", clientes.size());
        return ResponseEntity.ok(clientes); // 200
    }

    @GetMapping("/{idCliente}/{idEndereco}")
    @Operation(summary = "Buscar Cliente por ID Composto", description = "Retorna um cliente específico pelo seu ID_CLI e ID_ENDERECO.")
    @ApiResponses(value = { /* ... */ })
    public ResponseEntity<ClienteResponseDto> findById(
            @Parameter(description = "ID numérico do cliente (parte da chave composta)") @PathVariable Long idCliente,
            @Parameter(description = "ID do endereço associado (parte da chave composta)") @PathVariable Long idEndereco
    ) {
        ClienteId id = new ClienteId(idCliente, idEndereco);
        log.info("Requisição para buscar cliente por ID: {}", id);
        try {
            ClienteResponseDto cliente = clienteService.findById(id);
            log.info("Cliente encontrado: {}", id);
            return ResponseEntity.ok(cliente); // 200
        } catch (ClientesNotFoundException e) {
            log.warn("Cliente não encontrado para o ID: {}", id);
            return ResponseEntity.notFound().build(); // 404
        } catch (IllegalArgumentException e) {
            log.warn("ID Composto inválido fornecido: {}: {}", id, e.getMessage());
            return ResponseEntity.badRequest().build(); // 400
        } catch (Exception e) {
            log.error("Erro inesperado ao buscar cliente por ID {}: {}", id, e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build(); // 500
        }
    }

    @PostMapping
    @CacheEvict(value = "clientes", allEntries = true)
    @Operation(summary = "Criar Novo Cliente", description = "Cria um novo registro de cliente, incluindo seu endereço e contato inicial.")
    @ApiResponses(value = { /* ... */ })
    public ResponseEntity<ClienteResponseDto> create(
            @Parameter(description = "Dados completos do cliente para criação") @RequestBody @Valid ClienteRequestDto clienteDto
    ) {
        log.info("Requisição para criar novo cliente recebida: {}", clienteDto.getNome());
        try {
            ClienteResponseDto savedCliente = clienteService.create(clienteDto);
            log.info("Cliente criado com sucesso com ID_CLI: {}", savedCliente.getIdCli());
            return ResponseEntity.status(HttpStatus.CREATED).body(savedCliente); // 201
        } catch (Exception e) {
            log.error("Erro ao criar cliente: {}", e.getMessage(), e);
            // Retorna uma resposta de erro mais informativa se possível
            //String message = "Erro interno ao criar cliente. Detalhes: " + e.getMessage();
            // Evita expor stack trace completo, mas dá uma pista
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null); // Ou retornar um objeto de erro { "error": message }
        }
    }


    @PutMapping("/{idCliente}/{idEndereco}")
    @CacheEvict(value = "clientes", allEntries = true)
    @Operation(summary = "Atualizar Cliente", description = "Atualiza um cliente existente (e seus dados de endereço/contato associados) pelo seu ID composto.")
    @ApiResponses(value = { /* ... */ })
    public ResponseEntity<ClienteResponseDto> update(
            @Parameter(description = "ID numérico do cliente a ser atualizado") @PathVariable Long idCliente,
            @Parameter(description = "ID do endereço associado ao cliente a ser atualizado") @PathVariable Long idEndereco,
            @Parameter(description = "Dados atualizados do cliente") @RequestBody @Valid ClienteRequestDto clienteDto
    ) {
        ClienteId id = new ClienteId(idCliente, idEndereco);
        log.info("Requisição para atualizar cliente ID: {}", id);
        try {
            ClienteResponseDto updatedCliente = clienteService.update(id, clienteDto);
            log.info("Cliente ID {} atualizado com sucesso.", id);
            return ResponseEntity.ok(updatedCliente); // 200
        } catch (ClientesNotFoundException e) {
            log.warn("Cliente não encontrado para atualização, ID: {}", id);
            return ResponseEntity.notFound().build(); // 404
        } catch (IllegalArgumentException e) {
            log.warn("ID Composto inválido fornecido para atualização: {}", id);
            return ResponseEntity.badRequest().build(); // 400
        } catch (Exception e) {
            log.error("Erro ao atualizar cliente ID {}: {}", id, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build(); // 500
        }
    }

    @DeleteMapping("/{idCliente}/{idEndereco}")
    @CacheEvict(value = "clientes", allEntries = true)
    @Operation(summary = "Deletar Cliente", description = "Deleta um cliente existente pelo seu ID composto. ATENÇÃO: Pode falhar se houver dependências.")
    @ApiResponses(value = { /* ... */ })
    public ResponseEntity<Void> delete(
            @Parameter(description = "ID numérico do cliente a ser deletado") @PathVariable Long idCliente,
            @Parameter(description = "ID do endereço associado ao cliente a ser deletado") @PathVariable Long idEndereco
    ) {
        ClienteId id = new ClienteId(idCliente, idEndereco);
        log.info("Requisição para deletar cliente ID: {}", id);
        try {
            clienteService.deleteById(id);
            log.info("Cliente ID {} deletado com sucesso.", id);
            return ResponseEntity.noContent().build(); // 204
        } catch (ClientesNotFoundException e) {
            log.warn("Cliente não encontrado para exclusão, ID: {}", id);
            return ResponseEntity.notFound().build(); // 404
        } catch (IllegalArgumentException e) {
            log.warn("ID Composto inválido fornecido para exclusão: {}", id);
            return ResponseEntity.badRequest().build(); // 400
        } catch (Exception e) { // Captura DataIntegrityViolationException ou outros
            log.error("Erro ao deletar cliente ID {}: {}", id, e.getMessage(), e);
            // Retorna 500, mas poderia retornar 409 (Conflict) se detectar DataIntegrityViolationException especificamente
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }


    // <<< O ENDPOINT /relatorio-completo FOI REMOVIDO DAQUI >>>

} // Fim da classe ClientesController

// --- Arquivo: controller\IaController.java
// --- Classe: IaController
// src/main/java/br/com/fiap/Controller/IaController.java
package br.com.fiap.controller;

import br.com.fiap.service.ia.GoogleGeminiService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/rest/ia")
@CrossOrigin(origins = "http://localhost:3000")
@Tag(name = "IA Service", description = "Endpoint para interação com a IA Generativa (Google Gemini)") // Descrição um pouco mais específica
public class IaController {

    private static final Logger log = LoggerFactory.getLogger(IaController.class);
    @Autowired
    private GoogleGeminiService iaService;

    @GetMapping("/diagnostico")
    @Operation(summary = "Gerar Diagnóstico via IA",
            description = "Recebe a descrição de um problema de veículo e retorna um possível diagnóstico, partes afetadas e estimativa de horas, gerados pela IA.") // Descrição atualizada
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Diagnóstico gerado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Descrição do problema não fornecida ou inválida"), // Atualizado
            @ApiResponse(responseCode = "500", description = "Erro interno, falha na comunicação com a IA ou IA não configurada") // Atualizado
    })
    public ResponseEntity<String> gerarDiagnostico(
            @Parameter(description = "Descrição textual do problema do veículo.", required = true, example = "Motor falhando na partida a frio e fumaça branca saindo do escapamento.")
            @RequestParam String descricao
    ) {
        log.info("Requisição para gerar diagnóstico via IA recebida para descrição: '{}'", descricao);
        if (descricao == null || descricao.isBlank()) {
            log.warn("Descrição do problema está vazia.");
            return ResponseEntity.badRequest().body("A descrição do problema é obrigatória."); // Retorna 400
        }
        try {
            String diagnostico = iaService.gerarDiagnostico(descricao);
            // Verifica se o diagnóstico é válido ou uma mensagem de erro/placeholder do serviço
            if (diagnostico != null && !diagnostico.isBlank() && !diagnostico.toLowerCase().contains("erro") && !diagnostico.toLowerCase().contains("não configurado")) {
                log.info("Diagnóstico da IA retornado com sucesso.");
                return ResponseEntity.ok(diagnostico); // 200
            } else {
                log.error("Serviço de IA retornou um erro, placeholder ou diagnóstico inválido: {}", diagnostico);
                // Retorna 500 com a mensagem de erro/placeholder do serviço
                return ResponseEntity.status(500).body(diagnostico != null ? diagnostico : "Erro desconhecido no serviço de IA.");
            }
        } catch (Exception e) {
            log.error("Erro inesperado ao chamar o serviço de IA: {}", e.getMessage(), e);
            return ResponseEntity.status(500).body("Erro interno ao processar solicitação de diagnóstico."); // 500
        }
    }
}

// --- Arquivo: controller\OficinaController.java
// --- Classe: OficinaController
// src/main/java/br/com/fiap/Controller/OficinaController.java
package br.com.fiap.controller;

import br.com.fiap.dto.oficina.OficinaRequestDto;
import br.com.fiap.dto.oficina.OficinaResponseDto;
import br.com.fiap.exception.OficinaNotFoundException;
import br.com.fiap.service.oficina.OficinaService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter; // <<< Importar
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag; // <<< Importar
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/rest/oficina")
@CrossOrigin(origins = "http://localhost:3000")
@Tag(name = "Oficina (Diagnósticos)", description = "Operações relacionadas aos registros de diagnóstico da oficina") // <<< TAG ADICIONADA
public class OficinaController {

    private static final Logger log = LoggerFactory.getLogger(OficinaController.class);
    @Autowired
    private OficinaService oficinaService;

    @GetMapping("/all")
    @Cacheable("oficinas")
    @Operation(summary = "Listar Todos os Diagnósticos", description = "Retorna uma lista de todos os registros de diagnósticos da oficina.") // Descrição adicionada
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Lista de registros retornada"),
            @ApiResponse(responseCode = "204", description = "Nenhum registro encontrado"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<List<OficinaResponseDto>> findAll() {
        log.info("Requisição para listar todos os registros de oficina");
        List<OficinaResponseDto> oficinas = oficinaService.findAll();
        if (oficinas.isEmpty()) {
            return ResponseEntity.noContent().build();
        }
        return ResponseEntity.ok(oficinas);
    }

    @GetMapping("/{id}")
    @Operation(summary = "Buscar Diagnóstico por ID", description = "Retorna um registro de diagnóstico específico pelo seu ID.") // Descrição adicionada
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Registro encontrado"),
            @ApiResponse(responseCode = "404", description = "Registro não encontrado para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<OficinaResponseDto> findById(
            @Parameter(description = "ID do registro de oficina a ser buscado") @PathVariable Long id // <<< @Parameter
    ) {
        log.info("Requisição para buscar registro de oficina por ID: {}", id);
        try {
            OficinaResponseDto oficina = oficinaService.findById(id);
            return ResponseEntity.ok(oficina);
        } catch (OficinaNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro inesperado ao buscar registro de oficina ID {}: {}", id, e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PostMapping
    @CacheEvict(value = "oficinas", allEntries = true)
    @Operation(summary = "Criar Novo Diagnóstico", description = "Cria um novo registro de diagnóstico na oficina.") // Descrição adicionada
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Registro criado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Dados inválidos fornecidos"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar criar o registro")
    })
    public ResponseEntity<OficinaResponseDto> create(
            @Parameter(description = "Dados do diagnóstico para criação") @RequestBody @Valid OficinaRequestDto oficinaDto // <<< @Parameter
    ) {
        log.info("Requisição para criar novo registro de oficina: {}", oficinaDto.getDataOficina());
        try {
            OficinaResponseDto savedOficina = oficinaService.create(oficinaDto);
            return ResponseEntity.status(HttpStatus.CREATED).body(savedOficina);
        } catch (Exception e) {
            log.error("Erro ao criar registro de oficina: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PutMapping("/{id}")
    @CacheEvict(value = "oficinas", allEntries = true)
    @Operation(summary = "Atualizar Diagnóstico", description = "Atualiza um registro de diagnóstico existente.") // Descrição adicionada
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Registro atualizado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Dados inválidos fornecidos"),
            @ApiResponse(responseCode = "404", description = "Registro não encontrado para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar atualizar")
    })
    public ResponseEntity<OficinaResponseDto> update(
            @Parameter(description = "ID do registro a ser atualizado") @PathVariable Long id, // <<< @Parameter
            @Parameter(description = "Dados atualizados do diagnóstico") @RequestBody @Valid OficinaRequestDto oficinaDto // <<< @Parameter
    ) {
        log.info("Requisição para atualizar registro de oficina ID: {}", id);
        try {
            OficinaResponseDto updatedOficina = oficinaService.update(id, oficinaDto);
            return ResponseEntity.ok(updatedOficina);
        } catch (OficinaNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro ao atualizar registro de oficina ID {}: {}", id, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @DeleteMapping("/{id}")
    @CacheEvict(value = "oficinas", allEntries = true)
    @Operation(summary = "Deletar Diagnóstico", description = "Remove um registro de diagnóstico.") // Descrição adicionada
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Registro deletado com sucesso"),
            @ApiResponse(responseCode = "404", description = "Registro não encontrado para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar deletar")
    })
    public ResponseEntity<Void> delete(
            @Parameter(description = "ID do registro a ser deletado") @PathVariable Long id // <<< @Parameter
    ) {
        log.info("Requisição para deletar registro de oficina ID: {}", id);
        try {
            oficinaService.deleteById(id);
            return ResponseEntity.noContent().build();
        } catch (OficinaNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro ao deletar registro de oficina ID {}: {}", id, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}

// --- Arquivo: controller\OrcamentoController.java
// --- Classe: OrcamentoController
// src/main/java/br/com/fiap/Controller/OrcamentoController.java
package br.com.fiap.controller;

import br.com.fiap.dto.orcamento.OrcamentoRequestDto;
import br.com.fiap.dto.orcamento.OrcamentoResponseDto;
import br.com.fiap.exception.OrcamentoNotFoundException;
import br.com.fiap.service.orcamento.OrcamentoService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter; // <<< Importar
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag; // <<< Importar
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/rest/orcamento")
@CrossOrigin(origins = "http://localhost:3000")
@Tag(name = "Orçamentos", description = "Operações relacionadas a orçamentos de serviços") // <<< TAG ADICIONADA
public class OrcamentoController {

    private static final Logger log = LoggerFactory.getLogger(OrcamentoController.class);
    @Autowired
    private OrcamentoService orcamentoService;

    @GetMapping("/all")
    @Cacheable("orcamentos")
    @Operation(summary = "Listar Todos os Orçamentos", description = "Retorna uma lista de todos os orçamentos cadastrados.") // Descrição
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Lista de orçamentos retornada"),
            @ApiResponse(responseCode = "204", description = "Nenhum orçamento encontrado"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<List<OrcamentoResponseDto>> findAll() {
        log.info("Requisição para listar todos os orçamentos");
        List<OrcamentoResponseDto> orcamentos = orcamentoService.findAll();
        if (orcamentos.isEmpty()) { return ResponseEntity.noContent().build(); }
        return ResponseEntity.ok(orcamentos);
    }

    @GetMapping("/{id}")
    @Operation(summary = "Buscar Orçamento por ID", description = "Retorna um orçamento específico pelo seu ID.") // Descrição
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Orçamento encontrado"),
            @ApiResponse(responseCode = "404", description = "Orçamento não encontrado para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<OrcamentoResponseDto> findById(
            @Parameter(description = "ID do orçamento a ser buscado") @PathVariable Long id // <<< @Parameter
    ) {
        log.info("Requisição para buscar orçamento por ID: {}", id);
        try {
            OrcamentoResponseDto orcamento = orcamentoService.findById(id);
            return ResponseEntity.ok(orcamento);
        } catch (OrcamentoNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro inesperado ao buscar orçamento ID {}: {}", id, e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PostMapping
    @CacheEvict(value = "orcamentos", allEntries = true)
    @Operation(summary = "Criar Novo Orçamento", description = "Cria um novo registro de orçamento.") // Descrição
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Orçamento criado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Dados inválidos fornecidos"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar criar o orçamento")
    })
    public ResponseEntity<OrcamentoResponseDto> create(
            @Parameter(description = "Dados do orçamento para criação") @RequestBody @Valid OrcamentoRequestDto orcamentoDto // <<< @Parameter
    ) {
        log.info("Requisição para criar novo orçamento: {}", orcamentoDto.getDataOrcamento());
        try {
            OrcamentoResponseDto savedOrcamento = orcamentoService.create(orcamentoDto);
            return ResponseEntity.status(HttpStatus.CREATED).body(savedOrcamento);
        } catch (Exception e) {
            log.error("Erro ao criar orçamento: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PutMapping("/{id}")
    @CacheEvict(value = "orcamentos", allEntries = true)
    @Operation(summary = "Atualizar Orçamento", description = "Atualiza um orçamento existente.") // Descrição
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Orçamento atualizado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Dados inválidos fornecidos"),
            @ApiResponse(responseCode = "404", description = "Orçamento não encontrado para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar atualizar")
    })
    public ResponseEntity<OrcamentoResponseDto> update(
            @Parameter(description = "ID do orçamento a ser atualizado") @PathVariable Long id, // <<< @Parameter
            @Parameter(description = "Dados atualizados do orçamento") @RequestBody @Valid OrcamentoRequestDto orcamentoDto // <<< @Parameter
    ) {
        log.info("Requisição para atualizar orçamento ID: {}", id);
        try {
            OrcamentoResponseDto updatedOrcamento = orcamentoService.update(id, orcamentoDto);
            return ResponseEntity.ok(updatedOrcamento);
        } catch (OrcamentoNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro ao atualizar orçamento ID {}: {}", id, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @DeleteMapping("/{id}")
    @CacheEvict(value = "orcamentos", allEntries = true)
    @Operation(summary = "Deletar Orçamento", description = "Remove um orçamento.") // Descrição
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Orçamento deletado com sucesso"),
            @ApiResponse(responseCode = "404", description = "Orçamento não encontrado para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar deletar")
    })
    public ResponseEntity<Void> delete(
            @Parameter(description = "ID do orçamento a ser deletado") @PathVariable Long id // <<< @Parameter
    ) {
        log.info("Requisição para deletar orçamento ID: {}", id);
        try {
            orcamentoService.deleteById(id);
            return ResponseEntity.noContent().build();
        } catch (OrcamentoNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro ao deletar orçamento ID {}: {}", id, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}

// --- Arquivo: controller\PagamentoController.java
// --- Classe: PagamentoController
// src/main/java/br/com/fiap/Controller/PagamentoController.java
package br.com.fiap.controller;

import br.com.fiap.dto.pagamento.PagamentoRequestDto;
import br.com.fiap.dto.pagamento.PagamentoResponseDto;
import br.com.fiap.exception.PagamentoNotFoundException;
import br.com.fiap.service.pagamento.PagamentoService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter; // <<< Importar
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag; // <<< Importar
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/rest/pagamento")
@CrossOrigin(origins = "http://localhost:3000")
@Tag(name = "Pagamentos", description = "Operações relacionadas a pagamentos") // <<< TAG ADICIONADA
public class PagamentoController {

    private static final Logger log = LoggerFactory.getLogger(PagamentoController.class);
    @Autowired
    private PagamentoService pagamentoService;

    @GetMapping("/all")
    @Cacheable("pagamentos")
    @Operation(summary = "Listar Todos os Pagamentos", description = "Retorna uma lista de todos os pagamentos registrados.") // Descrição
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Lista de pagamentos retornada"),
            @ApiResponse(responseCode = "204", description = "Nenhum pagamento encontrado"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<List<PagamentoResponseDto>> findAll() {
        log.info("Requisição para listar todos os pagamentos");
        List<PagamentoResponseDto> pagamentos = pagamentoService.findAll();
        if (pagamentos.isEmpty()) { return ResponseEntity.noContent().build(); }
        return ResponseEntity.ok(pagamentos);
    }

    @GetMapping("/{id}")
    @Operation(summary = "Buscar Pagamento por ID", description = "Retorna um pagamento específico pelo seu ID.") // Descrição
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Pagamento encontrado"),
            @ApiResponse(responseCode = "404", description = "Pagamento não encontrado para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<PagamentoResponseDto> findById(
            @Parameter(description = "ID do pagamento a ser buscado") @PathVariable Long id // <<< @Parameter
    ) {
        log.info("Requisição para buscar pagamento por ID: {}", id);
        try {
            PagamentoResponseDto pagamento = pagamentoService.findById(id);
            return ResponseEntity.ok(pagamento);
        } catch (PagamentoNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro inesperado ao buscar pagamento ID {}: {}", id, e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PostMapping
    @CacheEvict(value = "pagamentos", allEntries = true)
    @Operation(summary = "Criar Novo Pagamento", description = "Cria um novo registro de pagamento.") // Descrição
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Pagamento criado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Dados inválidos fornecidos"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar criar o pagamento")
    })
    public ResponseEntity<PagamentoResponseDto> create(
            @Parameter(description = "Dados do pagamento para criação") @RequestBody @Valid PagamentoRequestDto pagamentoDto // <<< @Parameter
    ) {
        log.info("Requisição para criar novo pagamento: {}", pagamentoDto.getTipoPagamento());
        try {
            PagamentoResponseDto savedPagamento = pagamentoService.create(pagamentoDto);
            return ResponseEntity.status(HttpStatus.CREATED).body(savedPagamento);
        } catch (Exception e) {
            log.error("Erro ao criar pagamento: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PutMapping("/{id}")
    @CacheEvict(value = "pagamentos", allEntries = true)
    @Operation(summary = "Atualizar Pagamento", description = "Atualiza um pagamento existente.") // Descrição
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Pagamento atualizado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Dados inválidos fornecidos"),
            @ApiResponse(responseCode = "404", description = "Pagamento não encontrado para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar atualizar")
    })
    public ResponseEntity<PagamentoResponseDto> update(
            @Parameter(description = "ID do pagamento a ser atualizado") @PathVariable Long id, // <<< @Parameter
            @Parameter(description = "Dados atualizados do pagamento") @RequestBody @Valid PagamentoRequestDto pagamentoDto // <<< @Parameter
    ) {
        log.info("Requisição para atualizar pagamento ID: {}", id);
        try {
            PagamentoResponseDto updatedPagamento = pagamentoService.update(id, pagamentoDto);
            return ResponseEntity.ok(updatedPagamento);
        } catch (PagamentoNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro ao atualizar pagamento ID {}: {}", id, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @DeleteMapping("/{id}")
    @CacheEvict(value = "pagamentos", allEntries = true)
    @Operation(summary = "Deletar Pagamento", description = "Remove um pagamento.") // Descrição
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Pagamento deletado com sucesso"),
            @ApiResponse(responseCode = "404", description = "Pagamento não encontrado para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar deletar")
    })
    public ResponseEntity<Void> delete(
            @Parameter(description = "ID do pagamento a ser deletado") @PathVariable Long id // <<< @Parameter
    ) {
        log.info("Requisição para deletar pagamento ID: {}", id);
        try {
            pagamentoService.deleteById(id);
            return ResponseEntity.noContent().build();
        } catch (PagamentoNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro ao deletar pagamento ID {}: {}", id, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}

// --- Arquivo: controller\PecasController.java
// --- Classe: PecasController
// src/main/java/br/com/fiap/Controller/PecasController.java
package br.com.fiap.controller;

import br.com.fiap.dto.pecas.PecasRequestDto;
import br.com.fiap.dto.pecas.PecasResponseDto;
import br.com.fiap.exception.PecasNotFoundException;
import br.com.fiap.service.pecas.PecasService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter; // <<< Importar
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag; // <<< Importar
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/rest/pecas")
@CrossOrigin(origins = "http://localhost:3000")
@Tag(name = "Peças", description = "Operações relacionadas a peças de veículos") // <<< TAG ADICIONADA
public class PecasController {

    private static final Logger log = LoggerFactory.getLogger(PecasController.class);
    @Autowired
    private PecasService pecasService;

    @GetMapping("/all")
    @Cacheable("pecas")
    @Operation(summary = "Listar Todas as Peças", description = "Retorna uma lista de todas as peças cadastradas.") // Descrição
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Lista de peças retornada"),
            @ApiResponse(responseCode = "204", description = "Nenhuma peça encontrada"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<List<PecasResponseDto>> findAll() {
        log.info("Requisição para listar todas as peças");
        List<PecasResponseDto> pecas = pecasService.findAll();
        if (pecas.isEmpty()) { return ResponseEntity.noContent().build(); }
        return ResponseEntity.ok(pecas);
    }

    @GetMapping("/{id}")
    @Operation(summary = "Buscar Peça por ID", description = "Retorna uma peça específica pelo seu ID.") // Descrição
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Peça encontrada"),
            @ApiResponse(responseCode = "404", description = "Peça não encontrada para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<PecasResponseDto> findById(
            @Parameter(description = "ID da peça a ser buscada") @PathVariable Long id // <<< @Parameter
    ) {
        log.info("Requisição para buscar peça por ID: {}", id);
        try {
            PecasResponseDto peca = pecasService.findById(id);
            return ResponseEntity.ok(peca);
        } catch (PecasNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro inesperado ao buscar peça ID {}: {}", id, e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PostMapping
    @CacheEvict(value = "pecas", allEntries = true)
    @Operation(summary = "Criar Nova Peça", description = "Cria um novo registro de peça.") // Descrição
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Peça criada com sucesso"),
            @ApiResponse(responseCode = "400", description = "Dados inválidos fornecidos"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar criar a peça")
    })
    public ResponseEntity<PecasResponseDto> create(
            @Parameter(description = "Dados da peça para criação") @RequestBody @Valid PecasRequestDto pecasDto // <<< @Parameter
    ) {
        log.info("Requisição para criar nova peça: {}", pecasDto.getDescricao());
        try {
            PecasResponseDto savedPeca = pecasService.create(pecasDto);
            return ResponseEntity.status(HttpStatus.CREATED).body(savedPeca);
        } catch (Exception e) {
            log.error("Erro ao criar peça: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PutMapping("/{id}")
    @CacheEvict(value = "pecas", allEntries = true)
    @Operation(summary = "Atualizar Peça", description = "Atualiza uma peça existente.") // Descrição
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Peça atualizada com sucesso"),
            @ApiResponse(responseCode = "400", description = "Dados inválidos fornecidos"),
            @ApiResponse(responseCode = "404", description = "Peça não encontrada para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar atualizar")
    })
    public ResponseEntity<PecasResponseDto> update(
            @Parameter(description = "ID da peça a ser atualizada") @PathVariable Long id, // <<< @Parameter
            @Parameter(description = "Dados atualizados da peça") @RequestBody @Valid PecasRequestDto pecasDto // <<< @Parameter
    ) {
        log.info("Requisição para atualizar peça ID: {}", id);
        try {
            PecasResponseDto updatedPeca = pecasService.update(id, pecasDto);
            return ResponseEntity.ok(updatedPeca);
        } catch (PecasNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro ao atualizar peça ID {}: {}", id, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @DeleteMapping("/{id}")
    @CacheEvict(value = "pecas", allEntries = true)
    @Operation(summary = "Deletar Peça", description = "Remove uma peça.") // Descrição
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Peça deletada com sucesso"),
            @ApiResponse(responseCode = "404", description = "Peça não encontrada para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar deletar")
    })
    public ResponseEntity<Void> delete(
            @Parameter(description = "ID da peça a ser deletada") @PathVariable Long id // <<< @Parameter
    ) {
        log.info("Requisição para deletar peça ID: {}", id);
        try {
            pecasService.deleteById(id);
            return ResponseEntity.noContent().build();
        } catch (PecasNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro ao deletar peça ID {}: {}", id, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}

// --- Arquivo: controller\RelatorioController.java
// --- Classe: RelatorioController
// src/main/java/br/com/fiap/Controller/RelatorioController.java
package br.com.fiap.Controller;

// --- Imports NECESSÁRIOS ---
// DTOs
import br.com.fiap.dto.relatorio.ContagemMensalDTO;
import br.com.fiap.dto.relatorio.HistoricoAgendamentoClienteDTO;
import br.com.fiap.dto.relatorio.ServicoAgendadoDTO; // << Import para Serviços Agendados
// Exceptions
import br.com.fiap.exception.ClientesNotFoundException;
// Models
import br.com.fiap.model.relacionamentos.ClienteId;
// Services
import br.com.fiap.service.relatorio.RelatorioService;
// Swagger / OpenAPI
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
// Logging
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
// Spring Core & Web
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;         // << Import para Page
import org.springframework.data.domain.Pageable;      // << Import para Pageable
import org.springframework.format.annotation.DateTimeFormat; // << Import para LocalDate @RequestParam
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;    // << Import para todas as anotações Web
// Java Util
import java.time.LocalDate;                         // << Import para LocalDate
import java.util.List;
// --- Fim Imports ---

@RestController
@RequestMapping("/rest/relatorios")
@CrossOrigin(origins = "http://localhost:3000")
@Tag(name = "Relatórios", description = "Endpoints para geração de relatórios")
public class RelatorioController {

    private static final Logger log = LoggerFactory.getLogger(RelatorioController.class);

    @Autowired
    private RelatorioService relatorioService;

    // Endpoint Contagem Mensal
    @GetMapping("/contagem-agendamentos-mensal")
    @Operation(summary = "Relatório de Contagem Mensal")
    @ApiResponses(value = { @ApiResponse(responseCode = "200"), @ApiResponse(responseCode = "204"), @ApiResponse(responseCode = "500") })
    public ResponseEntity<List<ContagemMensalDTO>> getContagemMensal() {
        log.info("Requisição GET /rest/relatorios/contagem-agendamentos-mensal");
        try {
            List<ContagemMensalDTO> contagem = relatorioService.getContagemMensalAgendamentos();
            if (contagem.isEmpty()) { return ResponseEntity.noContent().build(); }
            return ResponseEntity.ok(contagem);
        } catch (Exception e) {
            log.error("Erro: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    // Endpoint Histórico Cliente
    @GetMapping("/historico-cliente/{idCliente}/{idEndereco}")
    @Operation(summary = "Histórico de Agendamentos por Cliente")
    @ApiResponses(value = { @ApiResponse(responseCode = "200"), @ApiResponse(responseCode = "204"), @ApiResponse(responseCode = "400"), @ApiResponse(responseCode = "404"), @ApiResponse(responseCode = "500") })
    public ResponseEntity<List<HistoricoAgendamentoClienteDTO>> getHistoricoCliente(
            @Parameter(description = "ID_CLI do cliente") @PathVariable Long idCliente,
            @Parameter(description = "ENDERECOS_ID_END do cliente") @PathVariable Long idEndereco
    ) {
        ClienteId clienteId = new ClienteId(idCliente, idEndereco);
        log.info("Requisição GET /rest/relatorios/historico-cliente/{}", clienteId);
        try {
            List<HistoricoAgendamentoClienteDTO> historico = relatorioService.getHistoricoAgendamentosCliente(clienteId);
            if (historico.isEmpty()) { return ResponseEntity.noContent().build(); }
            return ResponseEntity.ok(historico);
        } catch (ClientesNotFoundException e) {
            log.warn("Cliente não encontrado: {}", clienteId);
            return ResponseEntity.notFound().build();
        } catch (IllegalArgumentException e) {
            log.warn("ID inválido: {}: {}", clienteId, e.getMessage());
            return ResponseEntity.badRequest().build();
        } catch (Exception e) {
            log.error("Erro ao gerar histórico: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    // Endpoint Serviços Agendados
    @GetMapping("/servicos-agendados")
    @Operation(summary = "Relatório de Serviços Agendados")
    @ApiResponses(value = { @ApiResponse(responseCode = "200"), @ApiResponse(responseCode = "204"), @ApiResponse(responseCode = "400"), @ApiResponse(responseCode = "500") })
    public ResponseEntity<Page<ServicoAgendadoDTO>> getServicosAgendados(
            @Parameter(description = "Data inicial (AAAA-MM-DD). Padrão: hoje.")
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate dataInicio,
            @Parameter(hidden = true) Pageable pageable
    ) {
        LocalDate dataInicioFiltro = (dataInicio != null) ? dataInicio : LocalDate.now();
        log.info("Requisição GET /rest/relatorios/servicos-agendados: dataInicio={}, pageable={}", dataInicioFiltro, pageable);
        try {
            Page<ServicoAgendadoDTO> paginaServicos = relatorioService.findServicosAgendados(dataInicioFiltro, pageable);
            if (paginaServicos.isEmpty()) { return ResponseEntity.noContent().build(); }
            return ResponseEntity.ok(paginaServicos);
        } catch (Exception e) {
            log.error("Erro ao gerar relatório de serviços agendados: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }
}

// --- Arquivo: controller\VeiculoController.java
// --- Classe: VeiculoController
// src/main/java/br/com/fiap/Controller/VeiculoController.java
package br.com.fiap.controller;

import br.com.fiap.dto.veiculo.VeiculoRequestDto;
import br.com.fiap.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.exception.VeiculoNotFoundException;
import br.com.fiap.service.veiculo.VeiculoService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter; // <<< Importar
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag; // <<< Importar
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.bind.annotation.RequestParam; // <<< Importar para busca

import java.util.List;

@RestController
@RequestMapping("/rest/veiculo")
@CrossOrigin(origins = "http://localhost:3000")
@Tag(name = "Veículos", description = "Operações relacionadas a veículos") // <<< TAG ATUALIZADA
public class VeiculoController {

    private static final Logger log = LoggerFactory.getLogger(VeiculoController.class);
    @Autowired
    private VeiculoService veiculoService;

    // Endpoint de Busca/Listagem com Filtro
    @GetMapping("/all") // Mantido como /all, mas agora aceita filtros
    @Cacheable("veiculos") // Cache pode ser menos eficaz com filtros dinâmicos
    @Operation(summary = "Listar ou Buscar Veículos",
            description = "Retorna uma lista de veículos. Pode ser filtrada por placa, modelo ou proprietário (parâmetros de query opcionais).") // Descrição unificada
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Lista de veículos retornada (pode ser vazia se filtro não encontrar nada)"),
            @ApiResponse(responseCode = "204", description = "Nenhum veículo cadastrado no sistema (sem filtros)"), // Aplica-se mais sem filtros
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<List<VeiculoResponseDto>> findVeiculos( // Nome do método mais genérico
                                                                  @Parameter(description = "Filtrar por parte da placa (case-insensitive)") @RequestParam(required = false) String placa,
                                                                  @Parameter(description = "Filtrar por parte do modelo (case-insensitive)") @RequestParam(required = false) String modelo,
                                                                  @Parameter(description = "Filtrar por parte do nome do proprietário (case-insensitive)") @RequestParam(required = false) String proprietario
    ) {
        log.info("Requisição para buscar/listar veículos com filtros: placa='{}', modelo='{}', proprietario='{}'", placa, modelo, proprietario);
        List<VeiculoResponseDto> veiculos;
        // Chama o método de busca do service se houver filtros
        if ((placa != null && !placa.isBlank()) || (modelo != null && !modelo.isBlank()) || (proprietario != null && !proprietario.isBlank())) {
            veiculos = veiculoService.buscarVeiculos(placa, modelo, proprietario);
        } else {
            // Chama o findAll normal se não houver filtros
            veiculos = veiculoService.findAll();
        }

        if (veiculos.isEmpty()) {
            // Retorna 204 se a busca com filtros não retornou nada, ou se não há veículos cadastrados
            log.info("Nenhum veículo encontrado para os critérios ou nenhum veículo cadastrado.");
            return ResponseEntity.noContent().build();
        }
        log.info("Retornando {} veículos.", veiculos.size());
        return ResponseEntity.ok(veiculos);
    }


    @GetMapping("/{id}")
    @Operation(summary = "Buscar Veículo por ID", description = "Retorna um veículo específico pelo seu ID.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Veículo encontrado"),
            @ApiResponse(responseCode = "404", description = "Veículo não encontrado para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<VeiculoResponseDto> findById(
            @Parameter(description = "ID do veículo a ser buscado") @PathVariable Long id
    ) {
        log.info("Requisição para buscar veículo por ID: {}", id);
        try {
            VeiculoResponseDto veiculo = veiculoService.findById(id);
            return ResponseEntity.ok(veiculo);
        } catch (VeiculoNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro inesperado ao buscar veículo ID {}: {}", id, e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PostMapping
    @CacheEvict(value = "veiculos", allEntries = true)
    @Operation(summary = "Criar Novo Veículo", description = "Cria um novo registro de veículo.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Veículo criado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Dados inválidos fornecidos"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar criar o veículo")
    })
    public ResponseEntity<VeiculoResponseDto> create(
            @Parameter(description = "Dados do veículo para criação") @RequestBody @Valid VeiculoRequestDto veiculoDto
    ) {
        log.info("Requisição para criar novo veículo: {}", veiculoDto.getPlaca());
        try {
            VeiculoResponseDto savedVeiculo = veiculoService.create(veiculoDto);
            return ResponseEntity.status(HttpStatus.CREATED).body(savedVeiculo);
        } catch (Exception e) {
            log.error("Erro ao criar veículo: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PutMapping("/{id}")
    @CacheEvict(value = "veiculos", allEntries = true)
    @Operation(summary = "Atualizar Veículo", description = "Atualiza um veículo existente.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Veículo atualizado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Dados inválidos fornecidos"),
            @ApiResponse(responseCode = "404", description = "Veículo não encontrado para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar atualizar")
    })
    public ResponseEntity<VeiculoResponseDto> update(
            @Parameter(description = "ID do veículo a ser atualizado") @PathVariable Long id,
            @Parameter(description = "Dados atualizados do veículo") @RequestBody @Valid VeiculoRequestDto veiculoDto
    ) {
        log.info("Requisição para atualizar veículo ID: {}", id);
        try {
            VeiculoResponseDto updatedVeiculo = veiculoService.update(id, veiculoDto);
            return ResponseEntity.ok(updatedVeiculo);
        } catch (VeiculoNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro ao atualizar veículo ID {}: {}", id, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @DeleteMapping("/{id}")
    @CacheEvict(value = "veiculos", allEntries = true)
    @Operation(summary = "Deletar Veículo", description = "Remove um veículo.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Veículo deletado com sucesso"),
            @ApiResponse(responseCode = "404", description = "Veículo não encontrado para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar deletar") // Ou 409
    })
    public ResponseEntity<Void> delete(
            @Parameter(description = "ID do veículo a ser deletado") @PathVariable Long id
    ) {
        log.info("Requisição para deletar veículo ID: {}", id);
        try {
            veiculoService.deleteById(id);
            return ResponseEntity.noContent().build();
        } catch (VeiculoNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) { // Captura DataIntegrityViolation etc.
            log.error("Erro ao deletar veículo ID {}: {}", id, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}

// --- Arquivo: dto\agenda\AgendaRequestDto.java
// --- Classe: AgendaRequestDto
package br.com.fiap.dto.agenda;

import jakarta.validation.constraints.FutureOrPresent;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class AgendaRequestDto implements Serializable {
    private static final long serialVersionUID = 1L;

    // ID Omitido para criação/atualização

    @NotNull(message = "Data do agendamento é obrigatória")
    @FutureOrPresent(message = "Data do agendamento não pode ser no passado") // Ou só @NotNull se permitir passado
    private LocalDate dataAgendamento;

    @Size(max = 400, message = "Observação pode ter no máximo 400 caracteres") // DDL: VARCHAR2(400)
    private String observacao; // Renomeado de obsAgenda
}

// --- Arquivo: dto\agenda\AgendaResponseDto.java
// --- Classe: AgendaResponseDto
package br.com.fiap.dto.agenda;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class AgendaResponseDto implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long id; // ID incluído na resposta
    private LocalDate dataAgendamento;
    private String observacao;
}

// --- Arquivo: dto\cliente\ClienteInfoDTO.java
// --- Classe: ClienteInfoDTO
// src/main/java/br/com/fiap/dto/cliente/ClienteInfoDTO.java
package br.com.fiap.dto.cliente;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
public class ClienteInfoDTO {
    private Long idCli;
    private Long idEndereco; // Essencial para identificar unicamente o cliente
    private String nome;
    private String sobrenome;
    private String numeroDocumento;

    public ClienteInfoDTO(Long idCli, Long idEndereco, String nome, String sobrenome, String numeroDocumento) {
        this.idCli = idCli;
        this.idEndereco = idEndereco;
        this.nome = nome;
        this.sobrenome = sobrenome;
        this.numeroDocumento = numeroDocumento;
    }

    public String getNomeCompleto() {
        return (nome != null ? nome : "") + " " + (sobrenome != null ? sobrenome : "");
    }
}

// --- Arquivo: dto\cliente\ClienteRequestDto.java
// --- Classe: ClienteRequestDto
package br.com.fiap.dto.cliente;

import br.com.fiap.dto.contato.ContatoRequestDto; // Usa Request DTO aninhado
import br.com.fiap.dto.endereco.EnderecoRequestDto; // Usa Request DTO aninhado
import jakarta.validation.Valid;
import jakarta.validation.constraints.*; // Importa todas as validações
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class ClienteRequestDto implements Serializable {
    private static final long serialVersionUID = 1L;

    // IDs (idCli, enderecoId) Omitidos

    @NotBlank(message = "Tipo do cliente é obrigatório")
    @Size(max = 2, message = "Tipo do cliente deve ter no máximo 2 caracteres") // DDL: VARCHAR2(2)
    private String tipoCliente;

    @NotBlank(message = "Nome é obrigatório")
    @Size(max = 50) // DDL: VARCHAR2(50)
    private String nome;

    @NotBlank(message = "Sobrenome é obrigatório")
    @Size(max = 50) // DDL: VARCHAR2(50)
    private String sobrenome;

    @NotBlank(message = "Sexo é obrigatório")
    @Size(max = 2) // DDL: VARCHAR2(2)
    private String sexo;

    @NotBlank(message = "Tipo do documento é obrigatório")
    @Size(max = 10) // DDL: VARCHAR2(10)
    private String tipoDocumento;

    @NotBlank(message = "Número do documento é obrigatório")
    @Size(max = 20) // DDL: VARCHAR2(20)
    private String numeroDocumento; // Considerar adicionar @Pattern se houver formato específico

    @NotNull(message = "Data de nascimento é obrigatória")
    @Past(message = "Data de nascimento deve ser no passado") // DDL: DATE not null
    private LocalDate dataNascimento;

    @NotBlank(message = "Atividade profissional é obrigatória")
    @Size(max = 50) // DDL: VARCHAR2(50)
    private String atividadeProfissional;

    @NotNull(message = "Endereço é obrigatório")
    @Valid // Valida o DTO aninhado
    private EnderecoRequestDto endereco; // <-- Tipo Corrigido

    @NotNull(message = "Contato é obrigatório")
    @Valid // Valida o DTO aninhado
    private ContatoRequestDto contato; // <-- Tipo Corrigido

    // Não incluir Autenticar aqui
}

// --- Arquivo: dto\cliente\ClienteResponseDto.java
// --- Classe: ClienteResponseDto
package br.com.fiap.dto.cliente;

import br.com.fiap.dto.contato.ContatoResponseDto; // Usa Response DTO aninhado
import br.com.fiap.dto.endereco.EnderecoResponseDto; // Usa Response DTO aninhado
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class ClienteResponseDto implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long idCli; // Parte principal da chave composta
    // O ID do endereço está dentro do EnderecoResponseDto

    private String tipoCliente;
    private String nome;
    private String sobrenome;
    private String sexo;
    private String tipoDocumento;
    private String numeroDocumento;
    private LocalDate dataNascimento;
    private String atividadeProfissional;

    private EnderecoResponseDto endereco; // <-- Tipo Corrigido
    private ContatoResponseDto contato;   // <-- Tipo Corrigido

    // Poderia ter um DTO resumido de Autenticar se necessário
    // private AutenticarResumoDto autenticar;
}

// --- Arquivo: dto\contato\ContatoRequestDto.java
// --- Classe: ContatoRequestDto
package br.com.fiap.dto.contato;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;

@Getter @Setter @NoArgsConstructor
public class ContatoRequestDto implements Serializable {
    private static final long serialVersionUID = 1L;

    // ID (codigo) Omitido

    @NotBlank(message = "Celular é obrigatório")
    @Size(max = 20) // DDL: VARCHAR2(20)
    private String celular;

    @NotBlank(message = "Email é obrigatório")
    @Email(message = "Formato de email inválido")
    @Size(max = 50) // DDL: VARCHAR2(50)
    private String email;

    @NotBlank(message = "Nome do contato é obrigatório")
    @Size(max = 100) // DDL: VARCHAR2(100)
    private String contato; // Nome do campo no DTO
}

// --- Arquivo: dto\contato\ContatoResponseDto.java
// --- Classe: ContatoResponseDto
package br.com.fiap.dto.contato;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;

@Getter @Setter @NoArgsConstructor
public class ContatoResponseDto implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long codigo; // ID incluído na resposta
    private String celular;
    private String email;
    private String contato;
}

// --- Arquivo: dto\endereco\EnderecoRequestDto.java
// --- Classe: EnderecoRequestDto
package br.com.fiap.dto.endereco;

import com.fasterxml.jackson.annotation.JsonProperty; // Para mapear JSON ViaCEP se necessário
import jakarta.validation.constraints.*; // Importa todas as validações
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;

@Getter @Setter @NoArgsConstructor
public class EnderecoRequestDto implements Serializable {
    private static final long serialVersionUID = 1L;

    // ID (codigo) Omitido

    @NotNull(message = "Número do endereço é obrigatório")
    @Positive(message = "Número deve ser positivo")
    private Integer numero; // DDL: NUMBER not null

    @NotBlank(message = "CEP é obrigatório")
    @Pattern(regexp = "\\d{5}-?\\d{3}", message = "CEP inválido. Formato: 00000-000 ou 00000000")
    @Size(max = 10) // DDL: VARCHAR2(10) not null
    private String cep;

    @NotBlank(message = "Logradouro é obrigatório")
    @Size(max = 100) // DDL: VARCHAR2(100) not null
    private String logradouro;

    @NotBlank(message = "Cidade é obrigatória")
    @Size(max = 100) // DDL: VARCHAR2(100) not null
    @JsonProperty("localidade") // Mantém compatibilidade com ViaCEP se usar Jackson
    private String cidade;

    @NotBlank(message = "Bairro é obrigatório")
    @Size(max = 100) // DDL: VARCHAR2(100) not null
    private String bairro;

    @NotBlank(message = "Estado é obrigatório")
    @Size(max = 50) // DDL: VARCHAR2(50) not null
    @JsonProperty("uf") // Mantém compatibilidade com ViaCEP se usar Jackson
    private String estado;

    @Size(max = 100) // DDL: VARCHAR2(100) nullable
    private String complemento;
}

// --- Arquivo: dto\endereco\EnderecoResponseDto.java
// --- Classe: EnderecoResponseDto
package br.com.fiap.dto.endereco;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;

@Getter @Setter @NoArgsConstructor
public class EnderecoResponseDto implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long codigo; // ID incluído na resposta
    private Integer numero; // Usar Integer para consistência, ou int se preferir
    private String cep;
    private String logradouro;
    @JsonProperty("localidade")
    private String cidade;
    private String bairro;
    @JsonProperty("uf")
    private String estado;
    private String complemento;
}

// --- Arquivo: dto\oficina\OficinaRequestDto.java
// --- Classe: OficinaRequestDto
package br.com.fiap.dto.oficina;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
// Poderia adicionar @Pattern para horasTrabalhadas se souber o formato exato
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class OficinaRequestDto implements Serializable {
    private static final long serialVersionUID = 1L;

    // ID Omitido

    @NotNull(message = "Data da oficina é obrigatória")
    @PastOrPresent(message = "Data da oficina não pode ser no futuro") // DDL: DATE not null
    private LocalDate dataOficina;

    @NotBlank(message = "Descrição do problema é obrigatória")
    @Size(max = 500) // DDL: VARCHAR2(500) not null
    private String descricaoProblema;

    @NotBlank(message = "Diagnóstico é obrigatório")
    @Size(max = 4000) // DDL: VARCHAR2(4000 char) not null
    private String diagnostico;

    @NotBlank(message = "Partes afetadas são obrigatórias")
    @Size(max = 500) // DDL: VARCHAR2(500) not null
    private String partesAfetadas;

    @NotBlank(message = "Horas trabalhadas são obrigatórias")
    @Size(max = 5, message = "Horas trabalhadas devem ter no máximo 5 caracteres") // DDL: VARCHAR2(5) not null
    // @Pattern(regexp = "\\d+", message = "Horas trabalhadas devem conter apenas números") // Exemplo, ajustar regex se necessário
    private String horasTrabalhadas; // Mapeado como String devido ao DDL
}

// --- Arquivo: dto\oficina\OficinaResponseDto.java
// --- Classe: OficinaResponseDto
package br.com.fiap.dto.oficina;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class OficinaResponseDto implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long id; // ID incluído
    private LocalDate dataOficina;
    private String descricaoProblema;
    private String diagnostico;
    private String partesAfetadas;
    private String horasTrabalhadas; // Mantido como String
}

// --- Arquivo: dto\orcamento\OrcamentoRequestDto.java
// --- Classe: OrcamentoRequestDto
package br.com.fiap.dto.orcamento;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Positive;
import jakarta.validation.constraints.PositiveOrZero; // Para valores que podem ser zero
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class OrcamentoRequestDto implements Serializable {
    private static final long serialVersionUID = 1L;

    // ID Omitido

    @NotNull(message = "Data do orçamento é obrigatória")
    @PastOrPresent(message = "Data do orçamento não pode ser futura") // DDL: DATE not null
    private LocalDate dataOrcamento;

    @NotNull(message = "Valor da mão de obra é obrigatório")
    @PositiveOrZero(message = "Valor da mão de obra não pode ser negativo") // DDL: NUMBER not null
    private BigDecimal maoDeObra;

    @NotNull(message = "Valor por hora é obrigatório")
    @Positive(message = "Valor por hora deve ser positivo") // DDL: NUMBER not null
    private BigDecimal valorHora;

    @NotNull(message = "Quantidade de horas é obrigatória")
    @Positive(message = "Quantidade de horas deve ser positiva") // DDL: NUMBER not null
    private Integer quantidadeHoras;

    @NotNull(message = "Valor total é obrigatório")
    @PositiveOrZero(message = "Valor total não pode ser negativo") // DDL: NUMBER not null
    private BigDecimal valorTotal; // Este valor pode ser calculado no backend também
}

// --- Arquivo: dto\orcamento\OrcamentoResponseDto.java
// --- Classe: OrcamentoResponseDto
package br.com.fiap.dto.orcamento;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class OrcamentoResponseDto implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long id; // ID incluído
    private LocalDate dataOrcamento;
    private BigDecimal maoDeObra;
    private BigDecimal valorHora;
    private Integer quantidadeHoras;
    private BigDecimal valorTotal;
}

// --- Arquivo: dto\pagamento\PagamentoRequestDto.java
// --- Classe: PagamentoRequestDto
package br.com.fiap.dto.pagamento;

import jakarta.validation.constraints.*; // Importa todas as validações
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class PagamentoRequestDto implements Serializable {
    private static final long serialVersionUID = 1L;

    // ID Omitido

    @NotNull(message = "Data do pagamento é obrigatória")
    @PastOrPresent(message = "Data do pagamento não pode ser futura") // DDL: DATE not null
    private LocalDate dataPagamento;

    @NotBlank(message = "Tipo do pagamento é obrigatório")
    @Size(max = 20) // DDL: VARCHAR2(20) not null
    private String tipoPagamento;

    @NotNull(message = "Desconto é obrigatório")
    @PositiveOrZero(message = "Desconto não pode ser negativo") // DDL: NUMBER not null
    private BigDecimal desconto;

    @NotBlank(message = "Total de parcelas é obrigatório")
    @Size(max = 5) // DDL: VARCHAR2(5) not null
    @Pattern(regexp = "\\d+", message = "Total de parcelas deve conter apenas números") // Validação básica para string numérica
    private String totalParcelas; // Mapeado como String devido ao DDL

    @NotNull(message = "Valor das parcelas é obrigatório")
    @Positive(message = "Valor das parcelas deve ser positivo") // DDL: NUMBER not null
    private BigDecimal valorParcelas;

    @NotNull(message = "Total com desconto é obrigatório")
    @PositiveOrZero(message = "Total com desconto não pode ser negativo") // DDL: NUMBER not null
    private BigDecimal totalComDesconto;
}

// --- Arquivo: dto\pagamento\PagamentoResponseDto.java
// --- Classe: PagamentoResponseDto
package br.com.fiap.dto.pagamento;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDate;

@Getter
@Setter
@NoArgsConstructor
public class PagamentoResponseDto implements Serializable {

    private static final long serialVersionUID = 1L;

    Long id;
    LocalDate dataPagamento;
    String tipoPagamento;
    BigDecimal desconto;
    String totalParcelas;
    BigDecimal valorParcelas;
    BigDecimal totalComDesconto;
}

// --- Arquivo: dto\pecas\PecasRequestDto.java
// --- Classe: PecasRequestDto
package br.com.fiap.dto.pecas;

import jakarta.validation.constraints.*; // Importa todas as validações
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class PecasRequestDto implements Serializable {
    private static final long serialVersionUID = 1L;

    // ID Omitido

    @NotBlank(message = "Tipo do veículo é obrigatório")
    @Size(max = 10) // DDL: VARCHAR2(10) not null
    private String tipoVeiculo;

    @NotBlank(message = "Fabricante é obrigatório")
    @Size(max = 50) // DDL: VARCHAR2(50) not null
    private String fabricante;

    @NotBlank(message = "Descrição da peça é obrigatória")
    @Size(max = 50) // DDL: DESCRICA_PECA VARCHAR2(50) not null
    private String descricao;

    @NotNull(message = "Data da compra é obrigatória")
    @PastOrPresent(message = "Data da compra não pode ser futura") // DDL: DATE not null
    private LocalDate dataCompra;

    @NotNull(message = "Preço é obrigatório")
    @Positive(message = "Preço deve ser positivo") // DDL: NUMBER not null
    private BigDecimal preco;

    @NotNull(message = "Desconto é obrigatório")
    @PositiveOrZero(message = "Desconto não pode ser negativo") // DDL: NUMBER not null
    private BigDecimal desconto;

    @NotNull(message = "Total com desconto é obrigatório")
    @PositiveOrZero(message = "Total com desconto não pode ser negativo") // DDL: NUMBER not null
    private BigDecimal totalDesconto;
}

// --- Arquivo: dto\pecas\PecasResponseDto.java
// --- Classe: PecasResponseDto
package br.com.fiap.dto.pecas;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class PecasResponseDto implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long id; // ID incluído
    private String tipoVeiculo;
    private String fabricante;
    private String descricao;
    private LocalDate dataCompra;
    private BigDecimal preco;
    private BigDecimal desconto;
    private BigDecimal totalDesconto;
}

// --- Arquivo: dto\relatorio\ClienteRelatorioCompletoDTO.java
// --- Classe: ClienteRelatorioCompletoDTO
// --- Arquivo: src/main/java/br/com/fiap/dto/relatorio/ClienteRelatorioCompletoDTO.java ---
package br.com.fiap.dto.relatorio;

import br.com.fiap.dto.agenda.AgendaResponseDto; // Ou um DTO mais simples
import br.com.fiap.dto.cliente.ClienteResponseDto;
import br.com.fiap.dto.orcamento.OrcamentoResponseDto;
import br.com.fiap.dto.pagamento.PagamentoResponseDto;
import br.com.fiap.dto.veiculo.VeiculoResponseDto;
// Importe DTOs específicos para Oficina e Peças se criá-los, ou use os existentes
import br.com.fiap.dto.oficina.OficinaResponseDto; // Exemplo
import br.com.fiap.dto.pecas.PecasResponseDto;     // Exemplo

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.io.Serializable;
import java.util.List;

@Getter
@Setter
@NoArgsConstructor
public class ClienteRelatorioCompletoDTO implements Serializable {
    private static final long serialVersionUID = 1L;

    private ClienteResponseDto cliente; // Dados básicos do cliente
    private List<VeiculoResponseDto> veiculos; // Lista de veículos do cliente
    private List<AgendaSimplificadoDTO> agendamentos; // Histórico de agendamentos (DTO simplificado)
    private List<OficinaServicoDTO> servicosOficina; // Serviços realizados (DTO com peças talvez?)
    private List<OrcamentoResponseDto> orcamentos; // Orçamentos associados ao cliente
    private List<PagamentoResponseDto> pagamentos; // Pagamentos associados ao cliente
    private long totalAgendamentos; // Contagem para o gráfico

    // --- Sub-DTOs Simplificados (Exemplos) ---
    // Você pode criar esses DTOs em seus respectivos pacotes ou aqui mesmo

    @Getter @Setter @NoArgsConstructor
    public static class AgendaSimplificadoDTO implements Serializable {
        private Long id;
        private String dataAgendamento; // Formatada
        private String observacao;
        private String veiculoPlaca; // Adicionar a placa para contexto
    }

    @Getter @Setter @NoArgsConstructor
    public static class OficinaServicoDTO implements Serializable {
        private Long idOficina;
        private String dataOficina; // Formatada
        private String descricaoProblema;
        private String diagnostico;
        private String partesAfetadas;
        private String horasTrabalhadas;
        private String veiculoPlaca; // Adicionar a placa
        private List<PecaUtilizadaDTO> pecasUtilizadas; // Lista de peças
    }

    @Getter @Setter @NoArgsConstructor
    public static class PecaUtilizadaDTO implements Serializable {
        private Long idPeca;
        private String descricaoPeca;
        private String fabricante;
        // Adicionar quantidade se a tabela de junção tiver
    }

}

// --- Arquivo: dto\relatorio\ContagemMensalDTO.java
// --- Classe: ContagemMensalDTO
// src/main/java/br/com/fiap/dto/relatorio/ContagemMensalDTO.java
package br.com.fiap.dto.relatorio;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor // Necessário para a query JPQL construir o objeto
public class ContagemMensalDTO {
    private String mesAno; // Formato "YYYY-MM"
    private Long quantidade; // Contagem de agendamentos no mês/ano
}

// --- Arquivo: dto\relatorio\ContagemMensalResultadoNativo.java
// --- Classe: ContagemMensalResultadoNativo
// src/main/java/br/com/fiap/dto/relatorio/ContagemMensalResultadoNativo.java
package br.com.fiap.dto.relatorio;

// Interface para mapear o resultado da query nativa
public interface ContagemMensalResultadoNativo {
    String getMesAno();      // Nome do método DEVE corresponder ao alias da coluna na query nativa (case-insensitive)
    Long getQuantidade(); // Nome do método DEVE corresponder ao alias da coluna na query nativa (case-insensitive)
}

// --- Arquivo: dto\relatorio\HistoricoAgendamentoClienteDTO.java
// --- Classe: HistoricoAgendamentoClienteDTO
// src/main/java/br/com/fiap/dto/relatorio/HistoricoAgendamentoClienteDTO.java
package br.com.fiap.dto.relatorio;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.LocalDate;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor // Necessário para a query JPQL
public class HistoricoAgendamentoClienteDTO {
    private LocalDate dataAgendamento;
    private String observacao;
    private String veiculoPlaca; // Placa do veículo associado ao agendamento
}

// --- Arquivo: dto\relatorio\ServicoAgendadoDTO.java
// --- Classe: ServicoAgendadoDTO
// src/main/java/br/com/fiap/dto/relatorio/ServicoAgendadoDTO.java
package br.com.fiap.dto.relatorio;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.LocalDate;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor // Necessário para a query JPQL com 'new'
public class ServicoAgendadoDTO {
    private Long agendaId;                    // ID do agendamento
    private LocalDate dataAgendamento;        // Data do agendamento
    private String agendaObservacao;          // Observação vinda da Agenda
    private String veiculoPlaca;              // Placa do Veiculo (pode ser null)
    private String oficinaDescricaoProblema;  // Descrição vinda da Oficina (pode ser null)
    private String oficinaDiagnostico;        // Diagnóstico vindo da Oficina (pode ser null)
}

// --- Arquivo: dto\veiculo\VeiculoRequestDto.java
// --- Classe: VeiculoRequestDto
package br.com.fiap.dto.veiculo;

import jakarta.validation.constraints.*; // Importa todas as validações
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class VeiculoRequestDto implements Serializable {
    private static final long serialVersionUID = 1L;

    // ID Omitido

    @NotBlank(message = "Tipo do veículo é obrigatório")
    @Size(max = 15) // DDL: VARCHAR2(15) not null
    private String tipoVeiculo;

    @NotBlank(message = "Renavam é obrigatório")
    @Size(max = 13) // DDL: VARCHAR2(13) not null
    // Adicionar @Pattern se houver formato específico para Renavam
    private String renavam;

    @NotBlank(message = "Placa é obrigatória")
    @Size(max = 7) // DDL: VARCHAR2(7) not null
    // Adicionar @Pattern para formato de placa (ex: Mercosul ou antiga)
    private String placa;

    @NotBlank(message = "Modelo é obrigatório")
    @Size(max = 100) // DDL: VARCHAR2(100) not null
    private String modelo;

    @NotBlank(message = "Proprietário é obrigatório")
    @Size(max = 50) // DDL: VARCHAR2(50) not null
    private String proprietario;

    @NotBlank(message = "Montadora é obrigatória")
    @Size(max = 100) // DDL: VARCHAR2(100) not null
    private String montadora;

    @NotBlank(message = "Cor é obrigatória")
    @Size(max = 50) // DDL: VARCHAR2(50) not null
    private String cor;

    @NotBlank(message = "Motor é obrigatório")
    @Size(max = 50) // DDL: VARCHAR2(50) not null
    private String motor;

    @NotNull(message = "Ano de fabricação é obrigatório")
    @PastOrPresent(message = "Ano de fabricação não pode ser futuro") // DDL: DATE not null
    private LocalDate anoFabricacao; // Mapeado como LocalDate
}

// --- Arquivo: dto\veiculo\VeiculoResponseDto.java
// --- Classe: VeiculoResponseDto
package br.com.fiap.dto.veiculo;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class VeiculoResponseDto implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long id; // ID incluído
    private String tipoVeiculo;
    private String renavam;
    private String placa;
    private String modelo;
    private String proprietario;
    private String montadora;
    private String cor;
    private String motor;
    private LocalDate anoFabricacao; // Mantido como LocalDate
}

// --- Arquivo: exception\AgendaNotFoundException.java
// --- Classe: AgendaNotFoundException
package br.com.fiap.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;


@ResponseStatus(HttpStatus.NOT_FOUND)
public class AgendaNotFoundException extends RuntimeException{

    public AgendaNotFoundException(String message) {
        super(message);
    }


    public AgendaNotFoundException(String message, Throwable cause) {
        super(message, cause); // Chama o construtor de RuntimeException que aceita mensagem e causa
    }


}


// --- Arquivo: exception\AssociacaoNotFoundException.java
// --- Classe: AssociacaoNotFoundException
// --- src/main/java/br/com/fiap/exception/AssociacaoNotFoundException.java ---
package br.com.fiap.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND) // Retorna 404 Not Found
public class AssociacaoNotFoundException extends RuntimeException {
    public AssociacaoNotFoundException(String message) {
        super(message);
    }
}

// --- Arquivo: exception\AutenticarNotFoundException.java
// --- Classe: AutenticarNotFoundException
package br.com.fiap.exception;

public class AutenticarNotFoundException extends RuntimeException{

    public AutenticarNotFoundException(String message) {
        super(message);
    }

    public AutenticarNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

}


// --- Arquivo: exception\ClientesNotFoundException.java
// --- Classe: ClientesNotFoundException
package br.com.fiap.exception;

public class ClientesNotFoundException extends RuntimeException{

    public ClientesNotFoundException(String message){
        super(message);
    }

    public ClientesNotFoundException(String message, Throwable cause){
        super(message, cause);
    }

}


// --- Arquivo: exception\ContatoNotFoundException.java
// --- Classe: ContatoNotFoundException
package br.com.fiap.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class ContatoNotFoundException extends RuntimeException {

    public ContatoNotFoundException(String message) {
        super(message);
    }

    public ContatoNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

}


// --- Arquivo: exception\EnderecoNotFoundException.java
// --- Classe: EnderecoNotFoundException
package br.com.fiap.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class EnderecoNotFoundException extends RuntimeException{

    public EnderecoNotFoundException(String message) {
        super(message);
    }

    public EnderecoNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

}


// --- Arquivo: exception\OficinaNotFoundException.java
// --- Classe: OficinaNotFoundException
package br.com.fiap.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class OficinaNotFoundException extends RuntimeException{

    public OficinaNotFoundException(String message) {
        super(message);
    }

    public OficinaNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

}


// --- Arquivo: exception\OrcamentoNotFoundException.java
// --- Classe: OrcamentoNotFoundException
package br.com.fiap.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class OrcamentoNotFoundException extends RuntimeException {

    public OrcamentoNotFoundException(String message) {
        super(message);
    }

    public OrcamentoNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

}


// --- Arquivo: exception\PagamentoNotFoundException.java
// --- Classe: PagamentoNotFoundException
package br.com.fiap.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class PagamentoNotFoundException extends RuntimeException {

    public PagamentoNotFoundException(String message) {
        super(message);
    }

    public PagamentoNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

}


// --- Arquivo: exception\PecasNotFoundException.java
// --- Classe: PecasNotFoundException
package br.com.fiap.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class PecasNotFoundException extends RuntimeException{

    public PecasNotFoundException(String message) {
        super(message);
    }

    public PecasNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

}


// --- Arquivo: exception\VeiculoNotFoundException.java
// --- Classe: VeiculoNotFoundException
package br.com.fiap.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class VeiculoNotFoundException extends RuntimeException {

    public VeiculoNotFoundException(String message) {
        super(message);
    }

    public VeiculoNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

}


// --- Arquivo: mapper\AgendaMapper.java
// --- Classe: AgendaMapper
// --- src/main/java/br/com/fiap/mapper/AgendaMapper.java ---
// (Já existe no seu código, apenas garantindo que está correto)
package br.com.fiap.mapper;

import br.com.fiap.dto.agenda.AgendaRequestDto;
import br.com.fiap.dto.agenda.AgendaResponseDto;
import br.com.fiap.model.Agenda;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

@Mapper(componentModel = "spring")
public interface AgendaMapper {

    AgendaMapper INSTANCE = Mappers.getMapper(AgendaMapper.class);

    // Ignora o 'id' ao mapear do DTO para a Entidade (será gerado pelo banco)
    // Mapeia 'observacao' do DTO para 'observacao' da Entidade
    @Mapping(target = "id", ignore = true)
    Agenda toEntity(AgendaRequestDto dto);

    // Mapeia 'id' e 'observacao' da Entidade para o DTO de resposta
    AgendaResponseDto toResponseDto(Agenda entity);

    // Ignora o 'id' ao atualizar a Entidade a partir do DTO
    // Mapeia 'observacao' do DTO para 'observacao' da Entidade existente
    @Mapping(target = "id", ignore = true)
    void updateEntityFromDto(AgendaRequestDto dto, @MappingTarget Agenda entity);
}

// --- Arquivo: mapper\ClienteMapper.java
// --- Classe: ClienteMapper
// --- src/main/java/br/com/fiap/mapper/ClienteMapper.java ---
package br.com.fiap.mapper;

import br.com.fiap.dto.cliente.ClienteRequestDto;
import br.com.fiap.dto.cliente.ClienteResponseDto;
import br.com.fiap.model.Clientes;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Mappings;

// Declara que este mapper usa outros mappers (para Endereco e Contato)
@Mapper(componentModel = "spring", uses = {EnderecoMapper.class, ContatoMapper.class})
public interface ClienteMapper {

    // Mapeamento DTO -> Entidade (Criação)
    // Ignora o ID composto ('id') pois será gerenciado pelo JPA/@MapsId e Sequence
    // Mapeia os DTOs aninhados de endereco e contato usando os mappers injetados
    @Mappings({
            @Mapping(target = "id", ignore = true), // Ignora o @EmbeddedId
            @Mapping(target = "endereco", source = "endereco"), // Usa EnderecoMapper
            @Mapping(target = "contato", source = "contato"),   // Usa ContatoMapper
            @Mapping(target = "autenticar", ignore = true) // Ignora autenticar por enquanto
    })
    Clientes toEntity(ClienteRequestDto dto);

    // Mapeamento Entidade -> DTO (Resposta)
    // Mapeia a parte idCli da chave composta para o campo idCli do DTO
    // Mapeia as entidades aninhadas Endereco e Contato para seus DTOs de resposta
    @Mappings({
            @Mapping(target = "idCli", source = "id.idCli"), // Pega o idCli de dentro do ClienteId
            @Mapping(target = "endereco", source = "endereco"), // Usa EnderecoMapper
            @Mapping(target = "contato", source = "contato")    // Usa ContatoMapper
            // Mapear autenticar se houver um DTO para ele
    })
    ClienteResponseDto toResponseDto(Clientes entity);

    // Mapeamento DTO -> Entidade (Atualização)
    // Ignora o ID composto ('id') pois não deve ser alterado
    // Mapeia os DTOs aninhados (a lógica de salvar/atualizar Endereco/Contato fica no Service)
    // Atualiza os campos simples do cliente
    @Mappings({
            @Mapping(target = "id", ignore = true),
            @Mapping(target = "endereco", ignore = true), // Endereço é atualizado separadamente no Service
            @Mapping(target = "contato", ignore = true),  // Contato é atualizado separadamente no Service
            @Mapping(target = "autenticar", ignore = true) // Ignora autenticar
    })
    void updateEntityFromDto(ClienteRequestDto dto, @MappingTarget Clientes entity);
}

// --- Arquivo: mapper\ContatoMapper.java
// --- Classe: ContatoMapper
// --- src/main/java/br/com/fiap/mapper/ContatoMapper.java ---
package br.com.fiap.mapper;

import br.com.fiap.dto.contato.ContatoRequestDto;
import br.com.fiap.dto.contato.ContatoResponseDto;
import br.com.fiap.model.Contato;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

@Mapper(componentModel = "spring")
public interface ContatoMapper {

    @Mapping(target = "codigo", ignore = true) // Ignora ID na criação
    Contato toEntity(ContatoRequestDto dto);

    ContatoResponseDto toResponseDto(Contato entity);

    @Mapping(target = "codigo", ignore = true) // Ignora ID na atualização
    void updateEntityFromDto(ContatoRequestDto dto, @MappingTarget Contato entity);
}

// --- Arquivo: mapper\EnderecoMapper.java
// --- Classe: EnderecoMapper
// --- src/main/java/br/com/fiap/mapper/EnderecoMapper.java ---
package br.com.fiap.mapper;

import br.com.fiap.dto.endereco.EnderecoRequestDto;
import br.com.fiap.dto.endereco.EnderecoResponseDto;
import br.com.fiap.model.Endereco;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

@Mapper(componentModel = "spring")
public interface EnderecoMapper {

    @Mapping(target = "codigo", ignore = true) // Ignora ID na criação
    Endereco toEntity(EnderecoRequestDto dto);

    EnderecoResponseDto toResponseDto(Endereco entity);

    @Mapping(target = "codigo", ignore = true) // Ignora ID na atualização
    void updateEntityFromDto(EnderecoRequestDto dto, @MappingTarget Endereco entity);
}

// --- Arquivo: mapper\OficinaMapper.java
// --- Classe: OficinaMapper
// --- src/main/java/br/com/fiap/mapper/OficinaMapper.java ---
package br.com.fiap.mapper;

import br.com.fiap.dto.oficina.OficinaRequestDto;
import br.com.fiap.dto.oficina.OficinaResponseDto;
import br.com.fiap.model.Oficina;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

@Mapper(componentModel = "spring")
public interface OficinaMapper {

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "agendaOficinas", ignore = true) // Ignora coleções de relacionamentos
    @Mapping(target = "oficinaVeiculos", ignore = true)
    @Mapping(target = "oficinaPecas", ignore = true)
    @Mapping(target = "oficinaOrcamentos", ignore = true)
    Oficina toEntity(OficinaRequestDto dto);

    OficinaResponseDto toResponseDto(Oficina entity);

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "agendaOficinas", ignore = true)
    @Mapping(target = "oficinaVeiculos", ignore = true)
    @Mapping(target = "oficinaPecas", ignore = true)
    @Mapping(target = "oficinaOrcamentos", ignore = true)
    void updateEntityFromDto(OficinaRequestDto dto, @MappingTarget Oficina entity);
}

// --- Arquivo: mapper\OrcamentoMapper.java
// --- Classe: OrcamentoMapper
// --- src/main/java/br/com/fiap/mapper/OrcamentoMapper.java ---
package br.com.fiap.mapper;

import br.com.fiap.dto.orcamento.OrcamentoRequestDto;
import br.com.fiap.dto.orcamento.OrcamentoResponseDto;
import br.com.fiap.model.Orcamento;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Mappings;

@Mapper(componentModel = "spring")
public interface OrcamentoMapper {

    @Mappings({
            @Mapping(target = "id", ignore = true),
            @Mapping(target = "clienteOrcamentos", ignore = true), // Ignora relacionamentos
            @Mapping(target = "oficinaOrcamentos", ignore = true),
            @Mapping(target = "pagamentoOrcamentos", ignore = true)
    })
    Orcamento toEntity(OrcamentoRequestDto dto);

    OrcamentoResponseDto toResponseDto(Orcamento entity);

    @Mappings({
            @Mapping(target = "id", ignore = true),
            @Mapping(target = "clienteOrcamentos", ignore = true),
            @Mapping(target = "oficinaOrcamentos", ignore = true),
            @Mapping(target = "pagamentoOrcamentos", ignore = true)
    })
    void updateEntityFromDto(OrcamentoRequestDto dto, @MappingTarget Orcamento entity);
}

// --- Arquivo: mapper\PagamentoMapper.java
// --- Classe: PagamentoMapper
// --- src/main/java/br/com/fiap/mapper/PagamentoMapper.java ---
package br.com.fiap.mapper;

import br.com.fiap.dto.pagamento.PagamentoRequestDto;
import br.com.fiap.dto.pagamento.PagamentoResponseDto;
import br.com.fiap.model.Pagamento;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Mappings;

@Mapper(componentModel = "spring")
public interface PagamentoMapper {

    @Mappings({
            @Mapping(target = "id", ignore = true),
            // Mapeia totalParcelas (String DTO) para totalParcelas (String Entidade)
            @Mapping(target = "totalParcelas", source="totalParcelas"),
            @Mapping(target = "clientePagamentos", ignore = true), // Ignora relacionamentos
            @Mapping(target = "pagamentoOrcamentos", ignore = true)
    })
    Pagamento toEntity(PagamentoRequestDto dto);

    // Mapeia totalParcelas (String Entidade) para totalParcelas (String DTO)
    @Mapping(target = "totalParcelas", source="totalParcelas")
    PagamentoResponseDto toResponseDto(Pagamento entity);

    @Mappings({
            @Mapping(target = "id", ignore = true),
            // Mapeia totalParcelas (String DTO) para totalParcelas (String Entidade)
            @Mapping(target = "totalParcelas", source="totalParcelas"),
            @Mapping(target = "clientePagamentos", ignore = true),
            @Mapping(target = "pagamentoOrcamentos", ignore = true)
    })
    void updateEntityFromDto(PagamentoRequestDto dto, @MappingTarget Pagamento entity);
}

// --- Arquivo: mapper\PecasMapper.java
// --- Classe: PecasMapper
// --- src/main/java/br/com/fiap/mapper/PecasMapper.java ---
package br.com.fiap.mapper;

import br.com.fiap.dto.pecas.PecasRequestDto;
import br.com.fiap.dto.pecas.PecasResponseDto;
import br.com.fiap.model.Pecas;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Mappings;

@Mapper(componentModel = "spring")
public interface PecasMapper {

    @Mappings({
            @Mapping(target = "id", ignore = true),
            @Mapping(target = "oficinaPecas", ignore = true), // Ignora relacionamentos
            @Mapping(target = "pecaVeiculos", ignore = true)
    })
    Pecas toEntity(PecasRequestDto dto);

    PecasResponseDto toResponseDto(Pecas entity);

    @Mappings({
            @Mapping(target = "id", ignore = true),
            @Mapping(target = "oficinaPecas", ignore = true),
            @Mapping(target = "pecaVeiculos", ignore = true)
    })
    void updateEntityFromDto(PecasRequestDto dto, @MappingTarget Pecas entity);
}

// --- Arquivo: mapper\VeiculoMapper.java
// --- Classe: VeiculoMapper
// --- src/main/java/br/com/fiap/mapper/VeiculoMapper.java ---
package br.com.fiap.mapper;

import br.com.fiap.dto.veiculo.VeiculoRequestDto;
import br.com.fiap.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.model.Veiculo;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Mappings;

@Mapper(componentModel = "spring")
public interface VeiculoMapper {

    @Mappings({
            @Mapping(target = "id", ignore = true),
            @Mapping(target = "agendaVeiculos", ignore = true), // Ignora relacionamentos
            @Mapping(target = "clienteVeiculos", ignore = true),
            @Mapping(target = "oficinaVeiculos", ignore = true),
            @Mapping(target = "pecaVeiculos", ignore = true)
    })
    Veiculo toEntity(VeiculoRequestDto dto);

    VeiculoResponseDto toResponseDto(Veiculo entity);

    @Mappings({
            @Mapping(target = "id", ignore = true),
            @Mapping(target = "agendaVeiculos", ignore = true),
            @Mapping(target = "clienteVeiculos", ignore = true),
            @Mapping(target = "oficinaVeiculos", ignore = true),
            @Mapping(target = "pecaVeiculos", ignore = true)
    })
    void updateEntityFromDto(VeiculoRequestDto dto, @MappingTarget Veiculo entity);
}

// --- Arquivo: model\Agenda.java
// --- Classe: Agenda
// src/main/java/br/com/fiap/model/Agenda.java
package br.com.fiap.model;

import br.com.fiap.model.relacionamentos.AgendaOficina; // Importar se usar
import br.com.fiap.model.relacionamentos.AgendaVeiculo; // <<< Importar AgendaVeiculo
import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDate;
import java.io.Serializable;
import java.util.ArrayList; // <<< Importar ArrayList
import java.util.List;      // <<< Importar List

@Entity
@Table(name = "AGENDAR")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "id")
@ToString(exclude = {"agendaOficinas", "agendaVeiculos"}) // Excluir coleções do toString
public class Agenda implements Serializable {

	private static final long serialVersionUID = 1L;

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "agenda_seq_gen")
	@SequenceGenerator(name = "agenda_seq_gen", sequenceName = "AGENDAR_ID_AGE_SEQ", allocationSize = 1)
	@Column(name = "ID_AGE")
	private Long id;

	@Column(name = "DATA_AGENDAMENTO", nullable = false)
	private LocalDate dataAgendamento;

	@Column(name = "OBS_AGENDAMENTO", length = 400, nullable = true)
	private String observacao;

	// === RELACIONAMENTOS DESCOMENTADOS ===
	// Relacionamento com Oficina (via tabela AO)
	@OneToMany(mappedBy = "agenda", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY) // <<< DESCOMENTAR ANOTAÇÃO
	private List<AgendaOficina> agendaOficinas = new ArrayList<>(); // <<< DESCOMENTAR ATRIBUTO

	// Relacionamento com Veiculo (via tabela AV) - PRECISA ESTAR DESCOMENTADO
	@OneToMany(mappedBy = "agenda", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<AgendaVeiculo> agendaVeiculos = new ArrayList<>();
	// ====================================
}

// --- Arquivo: model\Autenticar.java
// --- Classe: Autenticar
package br.com.fiap.model;

import jakarta.persistence.*;   // Importações JPA
import lombok.*;                // Importações Lombok
import java.io.Serializable;    // Para implementar Serializable

@Entity // Marca como Entidade JPA
@Table(name = "AUTENTICAR") // Nome exato da tabela no DDL

// --- Lombok ---
@Getter
@Setter
@NoArgsConstructor // Construtor padrão (obrigatório para JPA)
@AllArgsConstructor // Construtor com todos os campos (útil)
@EqualsAndHashCode(of = "id") // equals e hashCode baseados apenas no campo 'id'
@ToString(exclude = "senha") // Exclui o campo senha do toString padrão por segurança
// --------------
public class Autenticar implements Serializable { // Boa prática implementar Serializable

    private static final long serialVersionUID = 1L; // Boa prática para Serializable

    @Id // Marca como chave primária
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "autenticar_seq_gen") // Geração via Sequence
    @SequenceGenerator(name = "autenticar_seq_gen", sequenceName = "AUTENTICAR_ID_AUT_SEQ", allocationSize = 1) // Configura a sequence do DDL
    @Column(name = "ID_AUT") // Mapeia para a coluna ID_AUT do banco
    private Long id; // Renomeado de 'codigoAutenticacao' para 'id' para simplicidade (ou poderia ser 'idAut')

    @Column(name = "USUARIO", length = 100, nullable = false, unique = true) // Mapeia para USUARIO, com constraints do DDL
    private String usuario;

    @Column(name = "SENHA", length = 100, nullable = false) // Mapeia para SENHA
    private String senha; // <-- Novamente, ATENÇÃO À SEGURANÇA!

    // === MÉTODOS MANUAIS REMOVIDOS ===
    // Os métodos getCodigoAutenticacao(), setCodigoAutenticacao(), getUsuario(), setUsuario(),
    // getSenha(), setSenha(), construtores padrão e completo, equals(), hashCode() e toString()
    // foram removidos pois agora são gerados automaticamente pelas anotações do Lombok
    // (@Getter, @Setter, @NoArgsConstructor, @AllArgsConstructor, @EqualsAndHashCode, @ToString).

    // ==================================
    // !!! ALERTA DE SEGURANÇA !!!
    // ==================================
    // Reitero: Armazenar senhas diretamente como texto no banco é INSEGURO.
    // Em aplicações reais, use Spring Security (ou similar) para aplicar HASHING (ex: BCrypt)
    // na senha ANTES de salvá-la. O campo 'senha' armazenaria o HASH.
    // ==================================
}

// --- Arquivo: model\Clientes.java
// --- Classe: Clientes
package br.com.fiap.model;
import br.com.fiap.model.relacionamentos.ClienteId;
import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDate; // Importa LocalDate para datas

@Entity
@Table(name = "CLIENTES") // Nome exato da tabela no DDL

// --- Lombok ---
@Getter
@Setter
@NoArgsConstructor // Construtor padrão obrigatório para JPA
@AllArgsConstructor // Construtor com todos os campos (opcional, mas útil)
@ToString(exclude = {"endereco", "contato", "autenticar"}) // Excluir relacionamentos LAZY
// --------------
public class Clientes {

	@EmbeddedId
	private ClienteId id = new ClienteId(); // <<< ADICIONE = new ClienteId(); AQUI

	// --- Relacionamento com Endereco (Obrigatório e parte da PK) ---
	@ManyToOne(fetch = FetchType.LAZY, optional = false) // Relacionamento com Endereco. optional=false porque a FK não pode ser nula
	@MapsId("enderecoId") // Diz que o atributo 'enderecoId' DENTRO do 'id' (@EmbeddedId) deve usar o ID desta entidade Endereco
	@JoinColumn(name = "ENDERECOS_ID_END", nullable = false) // Nome exato da coluna FK no DDL. Não pode ser nulo.
	private Endereco endereco;
	// -----------------------------------------------------------

	// --- Demais Colunas Mapeadas Exatamente como no DDL ---
	@Column(name = "TIPO_CLIENTE", length = 2, nullable = false)
	private String tipoCliente;

	@Column(name = "NOME", length = 50, nullable = false)
	private String nome;

	@Column(name = "SOBRENOME", length = 50, nullable = false)
	private String sobrenome;

	@Column(name = "SEXO", length = 2, nullable = false)
	private String sexo;

	@Column(name = "TIPO_DOCUMENTO", length = 10, nullable = false)
	private String tipoDocumento;

	@Column(name = "NUMERO_DOCUMENTO", length = 20, nullable = false, unique = true) // Ajustado unique=true pois geralmente documentos são únicos
	private String numeroDocumento;

	@Column(name = "DATA_NASCIMENTO", nullable = false) // Nome exato da coluna no DDL
	private LocalDate dataNascimento; // Tipo LocalDate para coluna DATE

	@Column(name = "ATIVIDADE_PROFISSIONAL", length = 50, nullable = false)
	private String atividadeProfissional;

	// --- Relacionamentos Opcionais (FKs permitem NULO no DDL) ---
	@ManyToOne(fetch = FetchType.LAZY) // Pode ser ManyToOne ou OneToOne dependendo da regra de negócio
	@JoinColumn(name = "CONTATOS_ID_CONT", nullable = true) // Nome exato da FK, permite nulo
	private Contato contato;

	@OneToOne(fetch = FetchType.LAZY) // Geralmente autenticação é 1-para-1
	@JoinColumn(name = "AUTENTICAR_ID_AUT", nullable = true) // Nome exato da FK, permite nulo
	private Autenticar autenticar; // Assume que existe uma entidade Autenticar mapeada para TB_AUTENTICAR
	// ---------------------------------------------------------

	// --- equals() e hashCode() baseados no ID composto ---
	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		Clientes clientes = (Clientes) o;
		// Só são iguais se o ID composto não for nulo e for igual ao do outro objeto.
		return id != null && id.equals(clientes.id);
	}

	@Override
	public int hashCode() {
		// Se o ID não for nulo, usa o hashCode dele, senão usa um valor baseado na classe.
		return id != null ? id.hashCode() : getClass().hashCode();
	}
	// ------------------------------------------------------

	// NOTA: Não usamos @GeneratedValue aqui porque a trigger CLIENTES_ID_CLI_TRG
	// no banco de dados já cuida de gerar o ID_CLI usando a sequence CLIENTES_ID_CLI_SEQ.
	// O JPA pegará o valor gerado pelo banco após a inserção.
}

// --- Arquivo: model\Contato.java
// --- Classe: Contato
package br.com.fiap.model;

import jakarta.persistence.*;   // Importações JPA
import lombok.*;                // Lombok
import java.io.Serializable;

@Entity // Marca como Entidade JPA
@Table(name = "CONTATOS") // Mapeia para a tabela TB_CONTATOS

// --- Lombok ---
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "codigo")
@ToString
//---------------
public class Contato implements Serializable {

	private static final long serialVersionUID = 1L;

	@Id // Chave Primária
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "contato_seq_gen")
	@SequenceGenerator(name = "contato_seq_gen", sequenceName = "CONTATOS_ID_CONT_SEQ", allocationSize = 1) // Usa a sequence do DDL
	@Column(name = "ID_CONT") // Mapeia para a coluna ID_CONT
	private Long codigo;

	@Column(name = "CELULAR", length = 20, nullable = false) // Mapeia para CELULAR
	private String celular;

	@Column(name = "EMAIL", length = 50, nullable = false) // Mapeia para EMAIL
	private String email;

	@Column(name = "CONTATO", length = 100, nullable = false) // Mapeia para CONTATO (Nome do campo Java e da coluna são diferentes aqui, mas ok)
	private String contato; // O nome do campo Java é 'contato', a coluna é 'CONTATO'

	// Getters, Setters, Construtores, equals, hashCode, toString gerados pelo Lombok
}

// --- Arquivo: model\Endereco.java
// --- Classe: Endereco
package br.com.fiap.model;

import com.google.gson.annotations.SerializedName; // Mantida para ViaCEP/Gson
import jakarta.persistence.*;                      // Importações JPA
import lombok.*;                                   // Lombok

import java.io.Serializable; // Necessário se for parte de chave composta ou relacionamento complexo

@Entity // Marca como Entidade JPA
@Table(name = "ENDERECOS") // Mapeia para a tabela TB_ENDERECOS

// --- Lombok ---
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "codigo") // Baseia equals/hashCode no ID
@ToString
//---------------
public class Endereco implements Serializable { // Implementar Serializable é uma boa prática para entidades

	private static final long serialVersionUID = 1L;

	@Id // Chave Primária
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "endereco_seq_gen")
	@SequenceGenerator(name = "endereco_seq_gen", sequenceName = "ENDERECOS_ID_END_SEQ", allocationSize = 1) // Usa a sequence do DDL
	@Column(name = "ID_END") // Mapeia para a coluna ID_END
	private Long codigo; // Seu campo 'codigo' mapeia para ID_END

	@Column(name = "NUMERO", nullable = false) // Mapeia para a coluna NUMERO
	private int numero; // Mantido como int, pois no DDL é NUMBER not null

	@Column(name = "CEP", length = 10, nullable = false) // Mapeia para CEP
	private String cep;

	@Column(name = "LOGRADOURO", length = 100, nullable = false) // Mapeia para LOGRADOURO
	private String logradouro;

	@Column(name = "CIDADE", length = 100, nullable = false) // Mapeia para CIDADE
	@SerializedName("localidade") // <-- ANOTAÇÃO GSON MANTIDA!
	private String cidade;

	@Column(name = "BAIRRO", length = 100, nullable = false) // Mapeia para BAIRRO
	private String bairro;

	@Column(name = "ESTADO", length = 50, nullable = false) // Mapeia para ESTADO
	@SerializedName("uf") // <-- ANOTAÇÃO GSON MANTIDA!
	private String estado;

	@Column(name = "COMPLEMENTO", length = 100, nullable = true) // Mapeia para COMPLEMENTO (permite nulo)
	private String complemento;

	// Getters, Setters, Construtores, equals, hashCode, toString gerados pelo Lombok
	// Comentário original removido pois o ID agora é gerenciado pelo JPA/Banco
}

// --- Arquivo: model\Oficina.java
// --- Classe: Oficina
package br.com.fiap.model;

import br.com.fiap.model.relacionamentos.AgendaOficina;
import br.com.fiap.model.relacionamentos.OficinaOrcamento;
import br.com.fiap.model.relacionamentos.OficinaPeca;
import br.com.fiap.model.relacionamentos.OficinaVeiculo;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;
import java.time.LocalDate;
import java.util.ArrayList; // Para inicializar listas
import java.util.List;       // Para coleções de relacionamentos

@Entity
@Table(name = "OFICINAS") // Nome exato da tabela no DDL

// --- Lombok ---
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "id")
// Excluir coleções LAZY do toString para evitar erros
@ToString(exclude = {"agendaOficinas", "oficinaVeiculos", "oficinaPecas", "oficinaOrcamentos"})
// --------------
public class Oficina implements Serializable {

	private static final long serialVersionUID = 1L;

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "oficina_seq_gen")
	@SequenceGenerator(name = "oficina_seq_gen", sequenceName = "OFICINAS_ID_OFIC_SEQ", allocationSize = 1)
	@Column(name = "ID_OFIC")
	private Long id; // Renomeado de 'codigo'

	@Column(name = "DATA_OFICINA", nullable = false)
	private LocalDate dataOficina; // Alterado para LocalDate, nome para camelCase

	@Column(name = "DESCRICAO_PROBLEMA", length = 500, nullable = false)
	private String descricaoProblema;

	@Column(name = "DIAGNOSTICO", length = 4000, nullable = false)
	private String diagnostico;

	@Column(name = "PARTES_AFETADAS", length = 500, nullable = false)
	private String partesAfetadas;

	// --- ATENÇÃO: HORAS_TRABALHADAS é VARCHAR2 no DDL ---
	@Column(name = "HORAS_TRABALHADAS", length = 5, nullable = false)
	private String horasTrabalhadas; // Mapeado como String para corresponder ao DDL.
	// Idealmente, esta coluna deveria ser NUMBER no banco.
	// Você precisará converter para número na sua lógica de negócio.
	// ----------------------------------------------------

	// === RELACIONAMENTOS INDIRETOS (Via Tabelas de Junção) ===
	// Removidos os campos diretos: private Agenda agenda; private Veiculo veiculo; private Pecas peca;
	// Adicionados relacionamentos @OneToMany para as ENTIDADES DE JUNÇÃO (que precisam ser criadas)

	// Relacionamento com Agendamentos (via Tabela AO -> Entidade AgendaOficina)
	@OneToMany(mappedBy = "oficina", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<AgendaOficina> agendaOficinas = new ArrayList<>(); // Assume entidade AgendaOficina

	// Relacionamento com Veículos (via Tabela OV -> Entidade OficinaVeiculo)
	@OneToMany(mappedBy = "oficina", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<OficinaVeiculo> oficinaVeiculos = new ArrayList<>(); // Assume entidade OficinaVeiculo

	// Relacionamento com Peças (via Tabela OFP -> Entidade OficinaPeca)
	@OneToMany(mappedBy = "oficina", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<OficinaPeca> oficinaPecas = new ArrayList<>(); // Assume entidade OficinaPeca

	// Relacionamento com Orçamentos (via Tabela OFO -> Entidade OficinaOrcamento)
	@OneToMany(mappedBy = "oficina", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<OficinaOrcamento> oficinaOrcamentos = new ArrayList<>(); // Assume entidade OficinaOrcamento

	// ===========================================================

	// Getters, Setters, Construtores, equals, hashCode, toString gerados pelo Lombok
}

// --- Arquivo: model\Orcamento.java
// --- Classe: Orcamento
package br.com.fiap.model;

import br.com.fiap.model.relacionamentos.ClienteOrcamento;
import br.com.fiap.model.relacionamentos.OficinaOrcamento;
import br.com.fiap.model.relacionamentos.PagamentoOrcamento;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;
import java.math.BigDecimal; // Usar BigDecimal para valores monetários/precisos
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "ORCAMENTOS") // Nome exato da tabela no DDL

// --- Lombok ---
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "id")
// Excluir coleções LAZY do toString
@ToString(exclude = {"clienteOrcamentos", "oficinaOrcamentos", "pagamentoOrcamentos"})
// --------------
public class Orcamento implements Serializable {

	private static final long serialVersionUID = 1L;

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "orcamento_seq_gen")
	@SequenceGenerator(name = "orcamento_seq_gen", sequenceName = "ORCAMENTOS_ID_ORC_SEQ", allocationSize = 1)
	@Column(name = "ID_ORC")
	private Long id; // Renomeado de 'codigo'

	@Column(name = "DATA_ORCAMENTO", nullable = false)
	private LocalDate dataOrcamento; // Alterado para LocalDate

	// Usando BigDecimal para precisão monetária/decimal
	@Column(name = "VALOR_MAODEOBRA", nullable = false, precision = 10, scale = 2) // Definir precisão e escala conforme necessário
	private BigDecimal maoDeObra; // Alterado para BigDecimal

	@Column(name = "VALOR_HORA", nullable = false, precision = 10, scale = 2)
	private BigDecimal valorHora; // Alterado para BigDecimal

	@Column(name = "QUANTIDADE_HORAS", nullable = false)
	private Integer quantidadeHoras; // Alterado para Integer (compatível com NUMBER)

	@Column(name = "VALOR_TOTAL", nullable = false, precision = 10, scale = 2)
	private BigDecimal valorTotal; // Alterado para BigDecimal

	// === RELACIONAMENTOS INDIRETOS (Via Tabelas de Junção) ===
	// Removidos os campos diretos: private Oficina oficina; private Pecas pecas;
	// O campo 'pecas' foi removido pois não há FK ou tabela de junção direta Orcamento<->Pecas no DDL.
	// Adicionados relacionamentos @OneToMany para as ENTIDADES DE JUNÇÃO (que precisam ser criadas)

	// Relacionamento com Clientes (via Tabela CO -> Entidade ClienteOrcamento)
	@OneToMany(mappedBy = "orcamento", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<ClienteOrcamento> clienteOrcamentos = new ArrayList<>(); // Assume entidade ClienteOrcamento

	// Relacionamento com Oficinas (via Tabela OFO -> Entidade OficinaOrcamento)
	@OneToMany(mappedBy = "orcamento", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<OficinaOrcamento> oficinaOrcamentos = new ArrayList<>(); // Assume entidade OficinaOrcamento

	// Relacionamento com Pagamentos (via Tabela PAO -> Entidade PagamentoOrcamento)
	@OneToMany(mappedBy = "orcamento", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<PagamentoOrcamento> pagamentoOrcamentos = new ArrayList<>(); // Assume entidade PagamentoOrcamento

	// ===========================================================

	// Getters, Setters, Construtores, equals, hashCode, toString gerados pelo Lombok
}

// --- Arquivo: model\Pagamento.java
// --- Classe: Pagamento
package br.com.fiap.model;

import br.com.fiap.model.relacionamentos.ClientePagamento;
import br.com.fiap.model.relacionamentos.PagamentoOrcamento;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;
import java.math.BigDecimal; // Usar BigDecimal para valores monetários/precisos
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "PAGAMENTOS") // Nome exato da tabela no DDL

// --- Lombok ---
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "id")
// Excluir coleções LAZY do toString
@ToString(exclude = {"clientePagamentos", "pagamentoOrcamentos"})
// --------------
public class Pagamento implements Serializable {

	private static final long serialVersionUID = 1L;

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "pagamento_seq_gen")
	@SequenceGenerator(name = "pagamento_seq_gen", sequenceName = "PAGAMENTOS_ID_PAG_SEQ", allocationSize = 1)
	@Column(name = "ID_PAG")
	private Long id; // Renomeado de 'codigo'

	@Column(name = "DATA_PAGAMENTO", nullable = false)
	private LocalDate dataPagamento; // Alterado para LocalDate

	@Column(name = "TIPO_PAGAMENTO", length = 20, nullable = false)
	private String tipoPagamento;

	// Usando BigDecimal para precisão monetária/decimal
	@Column(name = "DESCONTO", nullable = false, precision = 10, scale = 2) // Definir precisão/escala
	private BigDecimal desconto; // Alterado para BigDecimal

	// --- ATENÇÃO: TOTAL_PARCELAS é VARCHAR2 no DDL ---
	@Column(name = "TOTAL_PARCELAS", length = 5, nullable = false)
	private String totalParcelas; // Mapeado como String para corresponder ao DDL.
	// O campo original era 'parcelamento' (int). Renomeado e tipo alterado.
	// Idealmente, esta coluna deveria ser NUMBER no banco.
	// Você precisará converter para número na sua lógica de negócio.
	// ----------------------------------------------------

	@Column(name = "VALOR_PARCELAS", nullable = false, precision = 10, scale = 2)
	private BigDecimal valorParcelas; // Alterado para BigDecimal

	@Column(name = "TOTAL_PAGAMENTO_DESCONTO", nullable = false, precision = 10, scale = 2)
	private BigDecimal totalComDesconto; // Alterado para BigDecimal e nome do campo ajustado

	// === RELACIONAMENTOS INDIRETOS (Via Tabelas de Junção) ===
	// Removidos os campos diretos: private Orcamento orcamento; private Pecas pecas;
	// O campo 'pecas' foi removido pois não há FK ou tabela de junção Pagamento<->Pecas no DDL.
	// Adicionados relacionamentos @OneToMany para as ENTIDADES DE JUNÇÃO (que precisam ser criadas)

	// Relacionamento com Clientes (via Tabela CP -> Entidade ClientePagamento)
	@OneToMany(mappedBy = "pagamento", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<ClientePagamento> clientePagamentos = new ArrayList<>(); // Assume entidade ClientePagamento

	// Relacionamento com Orcamentos (via Tabela PAO -> Entidade PagamentoOrcamento)
	@OneToMany(mappedBy = "pagamento", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<PagamentoOrcamento> pagamentoOrcamentos = new ArrayList<>(); // Assume entidade PagamentoOrcamento

	// ===========================================================

	// Getters, Setters, Construtores, equals, hashCode, toString gerados pelo Lombok
}

// --- Arquivo: model\Pecas.java
// --- Classe: Pecas
package br.com.fiap.model;

import br.com.fiap.model.relacionamentos.OficinaPeca;
import br.com.fiap.model.relacionamentos.PecaVeiculo;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;
import java.math.BigDecimal; // Para valores monetários/precisos
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "PECAS") // Nome exato da tabela no DDL

// --- Lombok ---
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "id")
// Excluir coleções LAZY do toString
@ToString(exclude = {"oficinaPecas", "pecaVeiculos"})
// --------------
public class Pecas implements Serializable {

	private static final long serialVersionUID = 1L;

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "pecas_seq_gen")
	@SequenceGenerator(name = "pecas_seq_gen", sequenceName = "PECAS_ID_PEC_SEQ", allocationSize = 1)
	@Column(name = "ID_PEC")
	private Long id; // Renomeado de 'codigo'

	@Column(name = "TIPO_VEICULO", length = 10, nullable = false)
	private String tipoVeiculo;

	@Column(name = "FABRICANTE", length = 50, nullable = false)
	private String fabricante;

	// Atenção: Nome da coluna no DDL parece ser "DESCRICA_PECA"
	@Column(name = "DESCRICA_PECA", length = 50, nullable = false)
	private String descricao; // Campo Java 'descricao' mapeado para 'DESCRICA_PECA'

	@Column(name = "DATA_COMPRA", nullable = false)
	private LocalDate dataCompra; // Alterado para LocalDate

	// Usando BigDecimal para precisão
	@Column(name = "PRECO", nullable = false, precision = 10, scale = 2)
	private BigDecimal preco; // Alterado para BigDecimal

	@Column(name = "DESCONTO", nullable = false, precision = 10, scale = 2)
	private BigDecimal desconto; // Alterado para BigDecimal

	@Column(name = "TOTAL_DESCONTO", nullable = false, precision = 10, scale = 2)
	private BigDecimal totalDesconto; // Alterado para BigDecimal

	// === RELACIONAMENTOS INDIRETOS (Via Tabelas de Junção) ===
	// Adicionados relacionamentos @OneToMany para as ENTIDADES DE JUNÇÃO (que precisam ser criadas)

	// Relacionamento com Oficinas (via Tabela OFP -> Entidade OficinaPeca)
	@OneToMany(mappedBy = "peca", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<OficinaPeca> oficinaPecas = new ArrayList<>(); // Assume entidade OficinaPeca com campo 'peca'

	// Relacionamento com Veículos (via Tabela PV -> Entidade PecaVeiculo)
	@OneToMany(mappedBy = "peca", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<PecaVeiculo> pecaVeiculos = new ArrayList<>(); // Assume entidade PecaVeiculo com campo 'peca'

	// ===========================================================

	// Getters, Setters, Construtores, equals, hashCode, toString gerados pelo Lombok
}

// --- Arquivo: model\Veiculo.java
// --- Classe: Veiculo
package br.com.fiap.model;

import br.com.fiap.model.relacionamentos.AgendaVeiculo;
import br.com.fiap.model.relacionamentos.ClienteVeiculo;
import br.com.fiap.model.relacionamentos.OficinaVeiculo;
import br.com.fiap.model.relacionamentos.PecaVeiculo;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;
import java.time.LocalDate; // Usar LocalDate para mapear DATE
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "VEICULOS") // Nome exato da tabela no DDL

// --- Lombok ---
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "id")
// Excluir coleções LAZY do toString
@ToString(exclude = {"agendaVeiculos", "clienteVeiculos", "oficinaVeiculos", "pecaVeiculos"})
// --------------
public class Veiculo implements Serializable {

	private static final long serialVersionUID = 1L;

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "veiculo_seq_gen")
	@SequenceGenerator(name = "veiculo_seq_gen", sequenceName = "VEICULOS_ID_VEI_SEQ", allocationSize = 1)
	@Column(name = "ID_VEI") // Mapeia para ID_VEI (conforme DDL)
	private Long id; // Renomeado de 'codigo'

	@Column(name = "TIPO_VEICULO", length = 15, nullable = false)
	private String tipoVeiculo;

	@Column(name = "RENAVAM", length = 13, nullable = false, unique = true) // Renavam geralmente é único
	private String renavam;

	@Column(name = "PLACA", length = 7, nullable = false, unique = true) // Placa geralmente é única
	private String placa;

	@Column(name = "MODELO", length = 100, nullable = false)
	private String modelo;

	@Column(name = "PROPRIETARIO", length = 50, nullable = false) // Mapeado conforme DDL
	private String proprietario;

	@Column(name = "MONTADORA", length = 100, nullable = false)
	private String montadora;

	@Column(name = "COR", length = 50, nullable = false)
	private String cor;

	@Column(name = "MOTOR", length = 50, nullable = false)
	private String motor;

	// --- ATENÇÃO: ANO_FABRICACAO é DATE no DDL ---
	@Column(name = "ANO_FABRICACAO", nullable = false)
	private LocalDate anoFabricacao; // Mapeado como LocalDate para corresponder ao tipo DATE do DDL.
	// Se você realmente só precisa do ano, talvez fosse melhor a coluna ser NUMBER no banco
	// e o tipo aqui ser Integer. Usar DATE para armazenar só o ano é incomum.
	// -------------------------------------------

	// === RELACIONAMENTOS INDIRETOS (Via Tabelas de Junção) ===
	// Adicionados relacionamentos @OneToMany para as ENTIDADES DE JUNÇÃO (que precisam ser criadas)

	// Relacionamento com Agendamentos (via Tabela AV -> Entidade AgendaVeiculo)
	@OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<AgendaVeiculo> agendaVeiculos = new ArrayList<>(); // Assume entidade AgendaVeiculo

	// Relacionamento com Clientes (via Tabela CV -> Entidade ClienteVeiculo)
	@OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<ClienteVeiculo> clienteVeiculos = new ArrayList<>(); // Assume entidade ClienteVeiculo

	// Relacionamento com Oficinas (via Tabela OV -> Entidade OficinaVeiculo)
	@OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<OficinaVeiculo> oficinaVeiculos = new ArrayList<>(); // Assume entidade OficinaVeiculo

	// Relacionamento com Peças (via Tabela PV -> Entidade PecaVeiculo)
	@OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<PecaVeiculo> pecaVeiculos = new ArrayList<>(); // Assume entidade PecaVeiculo

	// ===========================================================

	// Getters, Setters, Construtores, equals, hashCode, toString gerados pelo Lombok
}

// --- Arquivo: model\relacionamentos\AgendaOficina.java
// --- Classe: AgendaOficina
package br.com.fiap.model.relacionamentos; // Ou subpacote

import br.com.fiap.model.Agenda;
import br.com.fiap.model.Oficina;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;

@Entity
@Table(name = "AO")
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @EqualsAndHashCode(of = "id") @ToString
public class AgendaOficina implements Serializable {
    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "ao_seq_gen")
    @SequenceGenerator(name = "ao_seq_gen", sequenceName = "AO_ID_AO_SEQ", allocationSize = 1)
    @Column(name = "ID_AO")
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "AGENDAR_ID_AGE", nullable = false)
    private Agenda agenda;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "OFICINAS_ID_OFIC", nullable = false)
    private Oficina oficina;
}

// --- Arquivo: model\relacionamentos\AgendaVeiculo.java
// --- Classe: AgendaVeiculo
package br.com.fiap.model.relacionamentos; // Ou um subpacote como br.com.fiap.model.join

import br.com.fiap.model.Agenda;
import br.com.fiap.model.Veiculo;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;

@Entity
@Table(name = "AV") // Nome exato da tabela de junção no DDL

// --- Lombok ---
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "id")
@ToString
//---------------
public class AgendaVeiculo implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "av_seq_gen")
    @SequenceGenerator(name = "av_seq_gen", sequenceName = "AV_ID_AV_SEQ", allocationSize = 1)
    @Column(name = "ID_AV") // Mapeia para a PK da tabela AV
    private Long id;

    // Relacionamento ManyToOne com Agenda
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "AGENDAR_ID_AGE", nullable = false) // Mapeia para a FK AGENDAR_ID_AGE
    private Agenda agenda;

    // Relacionamento ManyToOne com Veiculo
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "T_VEICULOS_ID_VEI", nullable = false) // Mapeia para a FK T_VEICULOS_ID_VEI
    private Veiculo veiculo;

    // Getters, Setters, etc., gerados pelo Lombok
}

// --- Arquivo: model\relacionamentos\ClienteId.java
// --- Classe: ClienteId
package br.com.fiap.model.relacionamentos;

import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.*;
import java.io.Serializable;

@Embeddable // Marca como classe de ID embutível
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode // Essencial para chaves compostas
public class ClienteId implements Serializable {

    private static final long serialVersionUID = 1L; // Boa prática

    @Column(name = "ID_CLI") // Mapeia EXATAMENTE para a coluna ID_CLI da tabela TB_CLIENTES
    private Long idCli; // Parte 1 da chave primária

    // A segunda parte da chave (ENDERECOS_ID_END) será mapeada via @MapsId na entidade Clientes
    // Não precisa de @Column aqui, pois seu valor virá do relacionamento com Endereco.
    private Long enderecoId; // Parte 2 da chave primária
}

// --- Arquivo: model\relacionamentos\ClienteOrcamento.java
// --- Classe: ClienteOrcamento
package br.com.fiap.model.relacionamentos; // Ou subpacote

import br.com.fiap.model.Clientes;
import br.com.fiap.model.Orcamento;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;

@Entity
@Table(name = "CO")
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @EqualsAndHashCode(of = "id") @ToString
public class ClienteOrcamento implements Serializable {
    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "co_seq_gen")
    @SequenceGenerator(name = "co_seq_gen", sequenceName = "CO_ID_CO_SEQ", allocationSize = 1)
    @Column(name = "ID_CO")
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumns({ // Usa @JoinColumns (plural) para FK composta de Cliente
            @JoinColumn(name = "CLIENTES_ID_CLI", referencedColumnName = "ID_CLI", nullable = false),
            @JoinColumn(name = "CLIENTES_ENDERECOS_ID_END", referencedColumnName = "ENDERECOS_ID_END", nullable = false)
    })
    private Clientes cliente;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "ORCAMENTOS_ID_ORC", nullable = false)
    private Orcamento orcamento;
}

// --- Arquivo: model\relacionamentos\ClientePagamento.java
// --- Classe: ClientePagamento
package br.com.fiap.model.relacionamentos; // Ou subpacote

import br.com.fiap.model.Clientes;
import br.com.fiap.model.Pagamento;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;

@Entity
@Table(name = "CP")
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @EqualsAndHashCode(of = "id") @ToString
public class ClientePagamento implements Serializable {
    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "cp_seq_gen")
    @SequenceGenerator(name = "cp_seq_gen", sequenceName = "CP_ID_CP_SEQ", allocationSize = 1)
    @Column(name = "ID_CP")
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumns({ // Usa @JoinColumns (plural) para FK composta de Cliente
            @JoinColumn(name = "CLIENTES_ID_CLI", referencedColumnName = "ID_CLI", nullable = false),
            @JoinColumn(name = "CLIENTES_ENDERECOS_ID_END", referencedColumnName = "ENDERECOS_ID_END", nullable = false)
    })
    private Clientes cliente;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "PAGAMENTOS_ID_PAG", nullable = false)
    private Pagamento pagamento;
}

// --- Arquivo: model\relacionamentos\ClienteVeiculo.java
// --- Classe: ClienteVeiculo
package br.com.fiap.model.relacionamentos;

import br.com.fiap.model.Clientes;
import br.com.fiap.model.Veiculo;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;

@Entity
@Table(name = "CV") // Nome da tabela de junção

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "id")
@ToString
public class ClienteVeiculo implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "cv_seq_gen")
    @SequenceGenerator(name = "cv_seq_gen", sequenceName = "CV_ID_CV_SEQ", allocationSize = 1)
    @Column(name = "ID_CV") // PK da tabela CV
    private Long id;

    // Relacionamento ManyToOne com Cliente (usando Chave Composta)
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumns({ // Usa @JoinColumns (plural) para FK composta
            @JoinColumn(name = "CLIENTES_ID_CLI", referencedColumnName = "ID_CLI", nullable = false), // Parte 1 da FK/PK
            @JoinColumn(name = "CLIENTES_ENDERECOS_ID_END", referencedColumnName = "ENDERECOS_ID_END", nullable = false) // Parte 2 da FK/PK
    })
    private Clientes cliente;

    // Relacionamento ManyToOne com Veiculo (chave simples)
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "T_VEICULOS_ID_VEI", nullable = false) // FK para VEICULOS
    private Veiculo veiculo;
}

// --- Arquivo: model\relacionamentos\OficinaOrcamento.java
// --- Classe: OficinaOrcamento
package br.com.fiap.model.relacionamentos; // Ou subpacote

import br.com.fiap.model.Oficina;
import br.com.fiap.model.Orcamento;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;

@Entity
@Table(name = "OFO")
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @EqualsAndHashCode(of = "id") @ToString
public class OficinaOrcamento implements Serializable {
    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "ofo_seq_gen")
    @SequenceGenerator(name = "ofo_seq_gen", sequenceName = "OFO_ID_OFO_SEQ", allocationSize = 1)
    @Column(name = "ID_OFO")
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "OFICINAS_ID_OFIC", nullable = false)
    private Oficina oficina;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "ORCAMENTOS_ID_ORC", nullable = false)
    private Orcamento orcamento;
}

// --- Arquivo: model\relacionamentos\OficinaPeca.java
// --- Classe: OficinaPeca
package br.com.fiap.model.relacionamentos;

import br.com.fiap.model.Oficina;
import br.com.fiap.model.Pecas;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;

@Entity
@Table(name = "OFP") // Nome da tabela de junção

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "id")
@ToString
public class OficinaPeca implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "ofp_seq_gen")
    // !!! Atenção ao nome da sequence no DDL: OFP_ID_OPE_SEQ !!!
    @SequenceGenerator(name = "ofp_seq_gen", sequenceName = "OFP_ID_OPE_SEQ", allocationSize = 1)
    @Column(name = "ID_OPE") // PK da tabela OFP
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "OFICINAS_ID_OFIC", nullable = false) // FK para OFICINAS
    private Oficina oficina;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "PECAS_ID_PEC", nullable = false) // FK para PECAS
    private Pecas peca;
}

// --- Arquivo: model\relacionamentos\OficinaVeiculo.java
// --- Classe: OficinaVeiculo
package br.com.fiap.model.relacionamentos; // Ou subpacote

import br.com.fiap.model.Oficina;
import br.com.fiap.model.Veiculo;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;

@Entity
@Table(name = "OV")
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @EqualsAndHashCode(of = "id") @ToString
public class OficinaVeiculo implements Serializable {
    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "ov_seq_gen")
    @SequenceGenerator(name = "ov_seq_gen", sequenceName = "OV_ID_OV_SEQ", allocationSize = 1)
    @Column(name = "ID_OV")
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "OFICINAS_ID_OFIC", nullable = false)
    private Oficina oficina;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "T_VEICULOS_ID_VEI", nullable = false)
    private Veiculo veiculo;
}

// --- Arquivo: model\relacionamentos\PagamentoOrcamento.java
// --- Classe: PagamentoOrcamento
package br.com.fiap.model.relacionamentos; // Ou subpacote

import br.com.fiap.model.Orcamento;
import br.com.fiap.model.Pagamento;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;

@Entity
@Table(name = "PAO")
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @EqualsAndHashCode(of = "id") @ToString
public class PagamentoOrcamento implements Serializable {
    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "pao_seq_gen")
    @SequenceGenerator(name = "pao_seq_gen", sequenceName = "PAO_ID_PAO_SEQ", allocationSize = 1)
    @Column(name = "ID_PAO")
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "PAGAMENTOS_ID_PAG", nullable = false)
    private Pagamento pagamento;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "ORCAMENTOS_ID_ORC", nullable = false)
    private Orcamento orcamento;
}

// --- Arquivo: model\relacionamentos\PecaVeiculo.java
// --- Classe: PecaVeiculo
package br.com.fiap.model.relacionamentos; // Ou subpacote

import br.com.fiap.model.Pecas;
import br.com.fiap.model.Veiculo;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;

@Entity
@Table(name = "PV")
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @EqualsAndHashCode(of = "id") @ToString
public class PecaVeiculo implements Serializable {
    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "pv_seq_gen")
    @SequenceGenerator(name = "pv_seq_gen", sequenceName = "PV_ID_PV_SEQ", allocationSize = 1)
    @Column(name = "ID_PV")
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "PECAS_ID_PEC", nullable = false)
    private Pecas peca;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "T_VEICULOS_ID_VEI", nullable = false)
    private Veiculo veiculo;
}

// --- Arquivo: repository\AgendaRepository.java
// --- Classe: AgendaRepository
// src/main/java/br/com/fiap/repository/AgendaRepository.java
package br.com.fiap.repository;

import br.com.fiap.dto.relatorio.ContagemMensalResultadoNativo;
import br.com.fiap.dto.relatorio.HistoricoAgendamentoClienteDTO;
import br.com.fiap.dto.relatorio.ServicoAgendadoDTO;
import br.com.fiap.model.Agenda;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import java.time.LocalDate;
import java.util.List;

public interface AgendaRepository extends JpaRepository<Agenda, Long>, JpaSpecificationExecutor<Agenda> {

    Page<Agenda> findByObservacaoContainingIgnoreCase(String observacao, Pageable pageable);

    // Query Nativa não é afetada por comentários Java
    @Query(value = "SELECT TO_CHAR(a.DATA_AGENDAMENTO, 'YYYY-MM') as mesAno, COUNT(a.ID_AGE) as quantidade FROM AGENDAR a GROUP BY TO_CHAR(a.DATA_AGENDAMENTO, 'YYYY-MM') ORDER BY mesAno DESC", nativeQuery = true)
    List<ContagemMensalResultadoNativo> countAgendamentosByMonthNative();

    // Query JPQL para Histórico (sem comentários internos)
    @Query("""
           SELECT new br.com.fiap.dto.relatorio.HistoricoAgendamentoClienteDTO(
               a.dataAgendamento,
               a.observacao,
               v.placa
           )
           FROM Agenda a
           JOIN a.agendaVeiculos av
           JOIN av.veiculo v
           JOIN v.clienteVeiculos cv
           WHERE cv.cliente.id.idCli = :idCliente AND cv.cliente.id.enderecoId = :idEndereco
           ORDER BY a.dataAgendamento DESC
           """)
    List<HistoricoAgendamentoClienteDTO> findHistoricoAgendamentosByClienteId(
            @Param("idCliente") Long idCliente,
            @Param("idEndereco") Long idEndereco
    );

    /**
     * Busca uma página de serviços agendados a partir de uma data inicial,
     * incluindo informações do veículo e diagnóstico da oficina, se disponíveis.
     *
     * @param dataInicio Data inicial para a busca (inclusive). Se null, busca todos os agendamentos.
     * @param pageable   Informações de paginação e ordenação.
     * @return Uma página (Page) de ServicoAgendadoDTO.
     */
    // Query JPQL para Serviços Agendados (sem comentários internos)
    @Query("""
            SELECT new br.com.fiap.dto.relatorio.ServicoAgendadoDTO(
                a.id,
                a.dataAgendamento,
                a.observacao,
                v.placa,
                o.descricaoProblema,
                o.diagnostico
            )
            FROM Agenda a
            LEFT JOIN a.agendaVeiculos av LEFT JOIN av.veiculo v
            LEFT JOIN a.agendaOficinas ao LEFT JOIN ao.oficina o
            WHERE (:dataInicio IS NULL OR a.dataAgendamento >= :dataInicio)
            """)
    Page<ServicoAgendadoDTO> findServicosAgendados(
            @Param("dataInicio") LocalDate dataInicio,
            Pageable pageable
    );
}

// --- Arquivo: repository\AutenticarRepository.java
// --- Classe: AutenticarRepository
package br.com.fiap.repository;

import br.com.fiap.model.Autenticar;
import org.springframework.data.jpa.repository.JpaRepository;

public interface AutenticarRepository extends JpaRepository<Autenticar, Long> {
}

// --- Arquivo: repository\ClientesRepository.java
// --- Classe: ClientesRepository
// src/main/java/br/com/fiap/repository/ClientesRepository.java
package br.com.fiap.repository;

import br.com.fiap.model.Clientes;
import br.com.fiap.model.relacionamentos.ClienteId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor; // <<< ADICIONAR IMPORT

// Adicionar JpaSpecificationExecutor para permitir buscas com Specification
public interface ClientesRepository extends JpaRepository<Clientes, ClienteId>, JpaSpecificationExecutor<Clientes> {
}

// --- Arquivo: repository\ContatoRepository.java
// --- Classe: ContatoRepository
package br.com.fiap.repository;

import br.com.fiap.model.Contato;
import org.springframework.data.jpa.repository.JpaRepository;

public interface ContatoRepository extends JpaRepository<Contato, Long> {
}

// --- Arquivo: repository\EnderecoRepository.java
// --- Classe: EnderecoRepository
package br.com.fiap.repository;

import br.com.fiap.model.Endereco;
import org.springframework.data.jpa.repository.JpaRepository;

public interface EnderecoRepository extends JpaRepository<Endereco, Long> {
}

// --- Arquivo: repository\OficinaRepository.java
// --- Classe: OficinaRepository
package br.com.fiap.repository;

import br.com.fiap.model.Oficina;
import org.springframework.data.jpa.repository.JpaRepository;

public interface OficinaRepository extends JpaRepository<Oficina, Long> {
}

// --- Arquivo: repository\OrcamentoRepository.java
// --- Classe: OrcamentoRepository
package br.com.fiap.repository;

import br.com.fiap.model.Orcamento;
import org.springframework.data.jpa.repository.JpaRepository;

public interface OrcamentoRepository extends JpaRepository<Orcamento, Long> {
}

// --- Arquivo: repository\PagamentoRepository.java
// --- Classe: PagamentoRepository
package br.com.fiap.repository;

import br.com.fiap.model.Pagamento;
import org.springframework.data.jpa.repository.JpaRepository;

public interface PagamentoRepository extends JpaRepository<Pagamento, Long> {
}

// --- Arquivo: repository\PecasRepository.java
// --- Classe: PecasRepository
package br.com.fiap.repository;

import br.com.fiap.model.Pecas;
import org.springframework.data.jpa.repository.JpaRepository;

public interface PecasRepository extends JpaRepository<Pecas, Long> {
}

// --- Arquivo: repository\VeiculoRepository.java
// --- Classe: VeiculoRepository
// src/main/java/br/com/fiap/repository/VeiculoRepository.java
package br.com.fiap.repository;

import br.com.fiap.model.Veiculo;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor; // <<< ADICIONAR IMPORT

// Adicionar JpaSpecificationExecutor para permitir buscas dinâmicas
public interface VeiculoRepository extends JpaRepository<Veiculo, Long>, JpaSpecificationExecutor<Veiculo> {
    // Nenhum método novo precisa ser definido aqui para a busca com Specification
}

// --- Arquivo: repository\relacionamentos\AgendaOficinaRepository.java
// --- Classe: AgendaOficinaRepository
package br.com.fiap.repository.relacionamentos;

import br.com.fiap.model.relacionamentos.AgendaOficina;
import org.springframework.data.jpa.repository.JpaRepository;

public interface AgendaOficinaRepository extends JpaRepository<AgendaOficina, Long> {
}

// --- Arquivo: repository\relacionamentos\AgendaVeiculoRepository.java
// --- Classe: AgendaVeiculoRepository
// --- src/main/java/br/com/fiap/repository/relacionamentos/AgendaVeiculoRepository.java ---
package br.com.fiap.repository.relacionamentos;

import br.com.fiap.model.relacionamentos.AgendaVeiculo;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List; // Importar List
import java.util.Optional; // Importar Optional

// Repositório para a entidade de junção AV
public interface AgendaVeiculoRepository extends JpaRepository<AgendaVeiculo, Long> {

    /**
     * Verifica se uma associação específica já existe pelos IDs das entidades relacionadas.
     * @param agendaId ID da Agenda
     * @param veiculoId ID do Veiculo
     * @return true se a associação existe, false caso contrário.
     */
    boolean existsByAgendaIdAndVeiculoId(Long agendaId, Long veiculoId);

    /**
     * Busca uma associação específica (Optional) pelos IDs das entidades relacionadas.
     * @param agendaId ID da Agenda
     * @param veiculoId ID do Veiculo
     * @return Optional contendo a associação se encontrada, Optional vazio caso contrário.
     */
    Optional<AgendaVeiculo> findByAgendaIdAndVeiculoId(Long agendaId, Long veiculoId);

    /**
     * Busca todas as associações (AgendaVeiculo) para um determinado ID de agenda.
     * Necessário para os métodos deleteById e findVeiculosByAgendaId em AgendaServiceImpl.
     * @param agendaId O ID da Agenda cujas associações devem ser buscadas.
     * @return Uma lista de entidades AgendaVeiculo.
     */
    List<AgendaVeiculo> findByAgendaId(Long agendaId); // <<< MÉTODO QUE ESTAVA FALTANDO

    List<AgendaVeiculo> findByVeiculoIdIn(List<Long> veiculoIds);

}

// --- Arquivo: repository\relacionamentos\ClienteOrcamentoRepository.java
// --- Classe: ClienteOrcamentoRepository
// --- Arquivo: src/main/java/br/com/fiap/repository/relacionamentos/ClienteOrcamentoRepository.java ---
package br.com.fiap.repository.relacionamentos;

import br.com.fiap.model.relacionamentos.ClienteId; // Importar ClienteId
import br.com.fiap.model.relacionamentos.ClienteOrcamento;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List; // Importar List

public interface ClienteOrcamentoRepository extends JpaRepository<ClienteOrcamento, Long> {

    // <<< NOVO MÉTODO ADICIONADO >>>
    List<ClienteOrcamento> findByCliente_Id(ClienteId clienteId);
}

// --- Arquivo: repository\relacionamentos\ClientePagamentoRepository.java
// --- Classe: ClientePagamentoRepository
// --- Arquivo: src/main/java/br/com/fiap/repository/relacionamentos/ClientePagamentoRepository.java ---
package br.com.fiap.repository.relacionamentos;

import br.com.fiap.model.relacionamentos.ClienteId; // Importar ClienteId
import br.com.fiap.model.relacionamentos.ClientePagamento;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List; // Importar List

public interface ClientePagamentoRepository extends JpaRepository<ClientePagamento, Long> {

    // <<< NOVO MÉTODO ADICIONADO >>>
    List<ClientePagamento> findByCliente_Id(ClienteId clienteId);
}

// --- Arquivo: repository\relacionamentos\ClienteVeiculoRepository.java
// --- Classe: ClienteVeiculoRepository
// --- Arquivo: src/main/java/br/com/fiap/repository/relacionamentos/ClienteVeiculoRepository.java ---
package br.com.fiap.repository.relacionamentos;

import br.com.fiap.model.relacionamentos.ClienteId; // Importar ClienteId
import br.com.fiap.model.relacionamentos.ClienteVeiculo;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List; // Importar List

public interface ClienteVeiculoRepository extends JpaRepository<ClienteVeiculo, Long> {

    // <<< NOVO MÉTODO ADICIONADO >>>
    // Busca todas as associações ClienteVeiculo baseadas no ID composto do Cliente.
    // Spring Data JPA entende "cliente" (o nome do campo na entidade ClienteVeiculo)
    // e "id" (o nome do campo @EmbeddedId na entidade Clientes).
    List<ClienteVeiculo> findByCliente_Id(ClienteId clienteId);
}

// --- Arquivo: repository\relacionamentos\OficinaOrcamentoRepository.java
// --- Classe: OficinaOrcamentoRepository
package br.com.fiap.repository.relacionamentos;

import br.com.fiap.model.relacionamentos.OficinaOrcamento;
import org.springframework.data.jpa.repository.JpaRepository;

public interface OficinaOrcamentoRepository extends JpaRepository<OficinaOrcamento, Long> {
}

// --- Arquivo: repository\relacionamentos\OficinaPecaRepository.java
// --- Classe: OficinaPecaRepository
package br.com.fiap.repository.relacionamentos;

import br.com.fiap.model.relacionamentos.OficinaPeca;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

public interface OficinaPecaRepository extends JpaRepository<OficinaPeca, Long> {

    List<OficinaPeca> findByOficinaId(Long oficinaId);
}

// --- Arquivo: repository\relacionamentos\OficinaVeiculoRepository.java
// --- Classe: OficinaVeiculoRepository
package br.com.fiap.repository.relacionamentos;

import br.com.fiap.model.relacionamentos.OficinaVeiculo;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List; // Certifique-se que List está importado


public interface OficinaVeiculoRepository extends JpaRepository<OficinaVeiculo, Long> {

    List<OficinaVeiculo> findByVeiculoIdIn(List<Long> veiculoIds);
}

// --- Arquivo: repository\relacionamentos\PagamentoOrcamentoRepository.java
// --- Classe: PagamentoOrcamentoRepository
package br.com.fiap.repository.relacionamentos;

import br.com.fiap.model.relacionamentos.PagamentoOrcamento;
import org.springframework.data.jpa.repository.JpaRepository;

public interface PagamentoOrcamentoRepository extends JpaRepository<PagamentoOrcamento, Long> {
}

// --- Arquivo: repository\relacionamentos\PecaVeiculoRepository.java
// --- Classe: PecaVeiculoRepository
package br.com.fiap.repository.relacionamentos;

import br.com.fiap.model.relacionamentos.PecaVeiculo;
import org.springframework.data.jpa.repository.JpaRepository;

public interface PecaVeiculoRepository extends JpaRepository<PecaVeiculo, Long> {
}

// --- Arquivo: repository\specification\AgendaSpecification.java
// --- Classe: AgendaSpecification
// --- src/main/java/br/com/fiap/repository/specification/AgendaSpecification.java ---
package br.com.fiap.repository.specification;

import br.com.fiap.model.Agenda;
import org.springframework.data.jpa.domain.Specification;
import jakarta.persistence.criteria.Predicate;
import java.time.LocalDate;

public class AgendaSpecification {

    // Evita instanciação
    private AgendaSpecification() {}

    /**
     * Cria uma Specification para filtrar por data de agendamento >= dataInicio.
     */
    public static Specification<Agenda> dataAgendamentoMaiorOuIgualA(LocalDate dataInicio) {
        return (root, query, criteriaBuilder) ->
                criteriaBuilder.greaterThanOrEqualTo(root.get("dataAgendamento"), dataInicio);
        // "dataAgendamento" é o nome do campo na entidade Agenda
    }

    /**
     * Cria uma Specification para filtrar por data de agendamento <= dataFim.
     */
    public static Specification<Agenda> dataAgendamentoMenorOuIgualA(LocalDate dataFim) {
        return (root, query, criteriaBuilder) ->
                criteriaBuilder.lessThanOrEqualTo(root.get("dataAgendamento"), dataFim);
    }

    /**
     * Cria uma Specification para filtrar por observacao contendo (ignorando case).
     */
    public static Specification<Agenda> observacaoContem(String observacao) {
        return (root, query, criteriaBuilder) ->
                criteriaBuilder.like(criteriaBuilder.lower(root.get("observacao")), "%" + observacao.toLowerCase() + "%");
        // "observacao" é o nome do campo na entidade Agenda
    }
}

// --- Arquivo: repository\specification\ClienteSpecification.java
// --- Classe: ClienteSpecification
// src/main/java/br/com/fiap/repository/specification/ClienteSpecification.java
package br.com.fiap.repository.specification;

import br.com.fiap.model.Clientes;
import org.springframework.data.jpa.domain.Specification;
import jakarta.persistence.criteria.Predicate;

public class ClienteSpecification {

    private ClienteSpecification() {} // Evita instanciação

    public static Specification<Clientes> nomeContains(String nome) {
        return (root, query, cb) -> {
            if (nome == null || nome.isBlank()) {
                return cb.conjunction();
            }
            Predicate nomeMatch = cb.like(cb.lower(root.get("nome")), "%" + nome.toLowerCase() + "%");
            Predicate sobrenomeMatch = cb.like(cb.lower(root.get("sobrenome")), "%" + nome.toLowerCase() + "%");
            return cb.or(nomeMatch, sobrenomeMatch);
        };
    }

    public static Specification<Clientes> numeroDocumentoEquals(String documento) {
        return (root, query, cb) -> {
            if (documento == null || documento.isBlank()) {
                return cb.conjunction();
            }
            return cb.equal(root.get("numeroDocumento"), documento);
        };
    }

    public static Specification<Clientes> idCliEquals(Long idCli) {
        return (root, query, cb) -> {
            if (idCli == null || idCli <= 0) {
                return cb.conjunction();
            }
            // Acessa o campo 'idCli' dentro do 'id' (EmbeddedId)
            return cb.equal(root.get("id").get("idCli"), idCli);
        };
    }
}

// --- Arquivo: repository\specification\VeiculoSpecification.java
// --- Classe: VeiculoSpecification
// src/main/java/br/com/fiap/repository/specification/VeiculoSpecification.java
package br.com.fiap.repository.specification;

import br.com.fiap.model.Veiculo;
import org.springframework.data.jpa.domain.Specification;
import jakarta.persistence.criteria.Predicate;

public class VeiculoSpecification {

    private VeiculoSpecification() {} // Construtor privado para evitar instanciação

    // Busca case-insensitive por parte da placa
    public static Specification<Veiculo> placaContains(String placa) {
        return (root, query, cb) -> {
            if (placa == null || placa.isBlank()) return cb.conjunction(); // Ignora se vazio
            return cb.like(cb.lower(root.get("placa")), "%" + placa.toLowerCase() + "%");
        };
    }

    // Busca case-insensitive por parte do modelo
    public static Specification<Veiculo> modeloContains(String modelo) {
        return (root, query, cb) -> {
            if (modelo == null || modelo.isBlank()) return cb.conjunction();
            return cb.like(cb.lower(root.get("modelo")), "%" + modelo.toLowerCase() + "%");
        };
    }

    // Busca case-insensitive por parte do proprietário
    public static Specification<Veiculo> proprietarioContains(String proprietario) {
        return (root, query, cb) -> {
            if (proprietario == null || proprietario.isBlank()) return cb.conjunction();
            return cb.like(cb.lower(root.get("proprietario")), "%" + proprietario.toLowerCase() + "%");
        };
    }
}

// --- Arquivo: service\agenda\AgendaService.java
// --- Classe: AgendaService
// --- src/main/java/br/com/fiap/service/agenda/AgendaService.java ---
package br.com.fiap.service.agenda;

import br.com.fiap.dto.agenda.AgendaRequestDto;
import br.com.fiap.dto.agenda.AgendaResponseDto;
import br.com.fiap.dto.veiculo.VeiculoResponseDto;
import org.springframework.data.domain.Page; // Importar Page
import org.springframework.data.domain.Pageable; // Importar Pageable
import java.time.LocalDate;
import java.util.List;

public interface AgendaService {

    // Novo método com paginação e filtro
    Page<AgendaResponseDto> findWithFilters(LocalDate dataInicio, LocalDate dataFim, String observacao, Pageable pageable);

    AgendaResponseDto findById(Long id);
    AgendaResponseDto create(AgendaRequestDto agendaDto);
    AgendaResponseDto update(Long id, AgendaRequestDto agendaDto);
    void deleteById(Long id);

    // Métodos para Gerenciar Relacionamento com Veiculo
    void associarVeiculo(Long agendaId, Long veiculoId);
    void desassociarVeiculo(Long agendaId, Long veiculoId);
    List<VeiculoResponseDto> findVeiculosByAgendaId(Long agendaId);
}

// --- Arquivo: service\agenda\AgendaServiceImpl.java
// --- Classe: AgendaServiceImpl
// --- src/main/java/br/com/fiap/service/agenda/AgendaServiceImpl.java ---
package br.com.fiap.service.agenda;

// TODOS OS IMPORTS NECESSÁRIOS (como na resposta anterior)
import br.com.fiap.dto.agenda.AgendaRequestDto;
import br.com.fiap.dto.agenda.AgendaResponseDto;
import br.com.fiap.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.exception.AgendaNotFoundException;
import br.com.fiap.exception.VeiculoNotFoundException;
import br.com.fiap.exception.AssociacaoNotFoundException; // Ou AgendaNotFoundException
import br.com.fiap.mapper.AgendaMapper;
import br.com.fiap.mapper.VeiculoMapper;
import br.com.fiap.model.Agenda;
import br.com.fiap.model.Veiculo;
import br.com.fiap.model.relacionamentos.AgendaVeiculo;
import br.com.fiap.repository.AgendaRepository;
import br.com.fiap.repository.VeiculoRepository;
import br.com.fiap.repository.relacionamentos.AgendaVeiculoRepository;
import br.com.fiap.repository.specification.AgendaSpecification;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.time.LocalDate;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class AgendaServiceImpl implements AgendaService { // Chave de abertura da classe

    private static final Logger log = LoggerFactory.getLogger(AgendaServiceImpl.class);
    private final AgendaRepository agendaRepository;
    private final AgendaMapper agendaMapper;
    private final VeiculoRepository veiculoRepository;
    private final AgendaVeiculoRepository agendaVeiculoRepository;
    private final VeiculoMapper veiculoMapper;

    @Autowired
    public AgendaServiceImpl(AgendaRepository agendaRepository,
                             AgendaMapper agendaMapper,
                             VeiculoRepository veiculoRepository,
                             AgendaVeiculoRepository agendaVeiculoRepository,
                             VeiculoMapper veiculoMapper
    ) {
        this.agendaRepository = agendaRepository;
        this.agendaMapper = agendaMapper;
        this.veiculoRepository = veiculoRepository;
        this.agendaVeiculoRepository = agendaVeiculoRepository;
        this.veiculoMapper = veiculoMapper;
    }

    @Override
    @Transactional(readOnly = true)
    public Page<AgendaResponseDto> findWithFilters(LocalDate dataInicio, LocalDate dataFim, String observacao, Pageable pageable) {
        // ... (código do método findWithFilters - sem alterações)
        log.info("Buscando agendas com filtros: dataInicio={}, dataFim={}, observacao='{}', pageable={}",
                dataInicio, dataFim, observacao, pageable);
        Specification<Agenda> spec = Specification.where(null);
        if (dataInicio != null) {
            spec = spec.and(AgendaSpecification.dataAgendamentoMaiorOuIgualA(dataInicio));
        }
        if (dataFim != null) {
            spec = spec.and(AgendaSpecification.dataAgendamentoMenorOuIgualA(dataFim));
        }
        if (observacao != null && !observacao.isBlank()) {
            spec = spec.and(AgendaSpecification.observacaoContem(observacao));
        }
        Page<Agenda> paginaAgenda = agendaRepository.findAll(spec, pageable);
        log.info("Encontradas {} agendas na página {}/{}", paginaAgenda.getNumberOfElements(), pageable.getPageNumber(), paginaAgenda.getTotalPages());
        return paginaAgenda.map(agendaMapper::toResponseDto);
    }

    @Override
    @Transactional(readOnly = true)
    public AgendaResponseDto findById(Long id) {
        // ... (código do método findById - sem alterações)
        log.info("Buscando agenda por ID: {}", id);
        Agenda agenda = agendaRepository.findById(id)
                .orElseThrow(() -> new AgendaNotFoundException("Agenda não encontrada com ID: " + id));
        return agendaMapper.toResponseDto(agenda);
    }

    @Override
    @Transactional
    public AgendaResponseDto create(AgendaRequestDto agendaDto) {
        // ... (código do método create - sem alterações)
        log.info("Criando nova agenda para data: {}", agendaDto.getDataAgendamento());
        try {
            Agenda agenda = agendaMapper.toEntity(agendaDto);
            Agenda savedAgenda = agendaRepository.save(agenda);
            log.info("Agenda criada com sucesso com ID: {}", savedAgenda.getId());
            return agendaMapper.toResponseDto(savedAgenda);
        } catch (Exception e) {
            log.error("Erro ao salvar nova agenda: {}", e.getMessage(), e);
            throw new RuntimeException("Falha ao criar agenda", e);
        }
    }

    @Override
    @Transactional
    public AgendaResponseDto update(Long id, AgendaRequestDto agendaDto) {
        // ... (código do método update - sem alterações)
        log.info("Atualizando agenda com ID: {}", id);
        Agenda existingAgenda = agendaRepository.findById(id)
                .orElseThrow(() -> new AgendaNotFoundException("Agenda não encontrada para atualização com ID: " + id));
        agendaMapper.updateEntityFromDto(agendaDto, existingAgenda);
        Agenda updatedAgenda = agendaRepository.save(existingAgenda);
        log.info("Agenda atualizada com sucesso com ID: {}", updatedAgenda.getId());
        return agendaMapper.toResponseDto(updatedAgenda);
    }

    @Override
    @Transactional
    public void deleteById(Long id) {
        // ... (código do método deleteById - sem alterações)
        log.info("Deletando agenda com ID: {}", id);
        if (!agendaRepository.existsById(id)) {
            throw new AgendaNotFoundException("Agenda não encontrada para exclusão com ID: " + id);
        }
        try {
            List<AgendaVeiculo> associacoes = agendaVeiculoRepository.findByAgendaId(id);
            if (!associacoes.isEmpty()) {
                agendaVeiculoRepository.deleteAllInBatch(associacoes);
                log.info("Removidas {} associações da tabela AV para Agenda ID {}.", associacoes.size(), id);
            }
            agendaRepository.deleteById(id);
            log.info("Agenda ID {} deletada com sucesso.", id);
        } catch (DataIntegrityViolationException e) {
            log.error("Erro de integridade ao deletar agenda ID {}: Verifique outras dependências.", id, e);
            throw new RuntimeException("Não é possível deletar a agenda pois ela está associada a outros registros.", e);
        } catch (Exception e) {
            log.error("Erro ao deletar agenda com ID {}: {}", id, e.getMessage(), e);
            throw new RuntimeException("Falha ao deletar agenda com ID: " + id, e);
        }
    }

    @Override
    @Transactional
    public void associarVeiculo(Long agendaId, Long veiculoId) { // Chave de abertura do método
        // ... (código do método associarVeiculo - sem alterações)
        log.info("Associando veículo ID {} à agenda ID {}", veiculoId, agendaId);
        Agenda agenda = agendaRepository.findById(agendaId)
                .orElseThrow(() -> new AgendaNotFoundException("Agenda não encontrada com ID: " + agendaId));
        Veiculo veiculo = veiculoRepository.findById(veiculoId)
                .orElseThrow(() -> new VeiculoNotFoundException("Veículo não encontrado com ID: " + veiculoId));
        if (agendaVeiculoRepository.existsByAgendaIdAndVeiculoId(agendaId, veiculoId)) {
            log.warn("Associação entre Agenda ID {} e Veículo ID {} já existe.", agendaId, veiculoId);
            return;
        }
        AgendaVeiculo novaAssociacao = new AgendaVeiculo();
        novaAssociacao.setAgenda(agenda);
        novaAssociacao.setVeiculo(veiculo);
        try {
            agendaVeiculoRepository.save(novaAssociacao);
            log.info("Veículo ID {} associado à Agenda ID {} com sucesso.", veiculoId, agendaId);
        } catch (Exception e) {
            log.error("Erro ao salvar associação entre Agenda {} e Veículo {}: {}", agendaId, veiculoId, e.getMessage(), e);
            throw new RuntimeException("Falha ao associar veículo à agenda.", e);
        }
    } // Chave de fechamento do método associarVeiculo

    @Override
    @Transactional
    public void desassociarVeiculo(Long agendaId, Long veiculoId) { // Chave de abertura do método
        // ... (código do método desassociarVeiculo - sem alterações)
        log.info("Desassociando veículo ID {} da agenda ID {}", veiculoId, agendaId);
        AgendaVeiculo associacao = agendaVeiculoRepository.findByAgendaIdAndVeiculoId(agendaId, veiculoId)
                .orElseThrow(() -> new AssociacaoNotFoundException( // Ou AgendaNotFoundException
                        String.format("Associação entre Agenda ID %d e Veículo ID %d não encontrada.", agendaId, veiculoId))
                );
        try {
            agendaVeiculoRepository.delete(associacao);
            log.info("Veículo ID {} desassociado da Agenda ID {} com sucesso.", veiculoId, agendaId);
        } catch (Exception e) {
            log.error("Erro ao deletar associação entre Agenda {} e Veículo {}: {}", agendaId, veiculoId, e.getMessage(), e);
            throw new RuntimeException("Falha ao desassociar veículo da agenda.", e);
        }
    } // Chave de fechamento do método desassociarVeiculo

    @Override
    @Transactional(readOnly = true)
    public List<VeiculoResponseDto> findVeiculosByAgendaId(Long agendaId) { // Chave de abertura do método
        // ... (código do método findVeiculosByAgendaId - sem alterações)
        log.info("Buscando veículos para agenda ID {}", agendaId);
        if (!agendaRepository.existsById(agendaId)) {
            throw new AgendaNotFoundException("Agenda não encontrada com ID: " + agendaId);
        }
        List<AgendaVeiculo> associacoes = agendaVeiculoRepository.findByAgendaId(agendaId);
        if (associacoes.isEmpty()) {
            log.info("Nenhum veículo associado à Agenda ID {}.", agendaId);
            return Collections.emptyList();
        }
        List<Veiculo> veiculos = associacoes.stream()
                .map(AgendaVeiculo::getVeiculo)
                .collect(Collectors.toList());
        log.info("Retornando {} veículos para a agenda {}", veiculos.size(), agendaId);
        return veiculos.stream()
                .map(veiculoMapper::toResponseDto)
                .collect(Collectors.toList());
    } // Chave de fechamento do método findVeiculosByAgendaId

} // <<<===== CERTIFIQUE-SE DE QUE ESTA CHAVE FINAL EXISTE NO SEU ARQUIVO!

// --- Arquivo: service\cep\CepService.java
// --- Classe: CepService
package br.com.fiap.service.cep;

import br.com.fiap.model.Endereco;
import org.slf4j.Logger; // Usar SLF4J para logging (padrão Spring)
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired; // Para injeção
import org.springframework.stereotype.Service; // Marca como um Service Bean
import org.springframework.web.client.HttpClientErrorException; // Exceção do RestTemplate
import org.springframework.web.client.RestTemplate; // Cliente HTTP do Spring

@Service // 1. Marca esta classe como um Bean de Serviço do Spring
public class CepService {

    private static final Logger log = LoggerFactory.getLogger(CepService.class);
    private static final String VIACEP_URL = "https://viacep.com.br/ws/{cep}/json/"; // Usa placeholder {cep}

    // 2. Injeta o Bean RestTemplate que configuramos anteriormente
    private final RestTemplate restTemplate;

    @Autowired
    public CepService(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    /**
     * Busca um endereço na API ViaCEP dado um CEP.
     *
     * @param cep O CEP a ser buscado (apenas números).
     * @return Um objeto Endereco preenchido ou null se não encontrado ou erro.
     */
    public Endereco buscarEnderecoPorCep(String cep) {
        // Remove caracteres não numéricos do CEP, se houver
        String cepNumerico = cep != null ? cep.replaceAll("[^0-9]", "") : "";
        if (cepNumerico.length() != 8) {
            log.warn("CEP inválido fornecido: {}", cep);
            return null; // Retorna null ou lança exceção de CEP inválido
        }

        log.info("Buscando endereço para o CEP: {}", cepNumerico);
        try {
            // 3. Usa restTemplate.getForObject para fazer a chamada GET
            // O Spring (com Jackson) automaticamente converte o JSON de resposta para o objeto Endereco
            Endereco endereco = restTemplate.getForObject(VIACEP_URL, Endereco.class, cepNumerico);

            // ViaCEP retorna um objeto com campos nulos se o CEP não existe,
            // mas às vezes retorna um {"erro": true}. A verificação do logradouro é uma forma.
            if (endereco != null && endereco.getLogradouro() != null) {
                log.info("Endereço encontrado para CEP {}: {}", cepNumerico, endereco.getLogradouro());
                // Importante: Como este Endereco veio da API, ele NÃO tem um ID do seu banco.
                // Ele precisará ser salvo (persistido) separadamente se for um novo endereço.
                endereco.setCodigo(null); // Garante que não tem ID ao vir da API externa
                return endereco;
            } else {
                log.warn("CEP {} não encontrado na base do ViaCEP.", cepNumerico);
                return null;
            }
        } catch (HttpClientErrorException e) {
            // Erros como 404, 400 etc.
            log.error("Erro HTTP ao buscar CEP {}: {} - {}", cepNumerico, e.getStatusCode(), e.getResponseBodyAsString());
            return null;
        } catch (Exception e) {
            // Outros erros (rede, parsing, etc.)
            log.error("Erro inesperado ao buscar CEP {}: {}", cepNumerico, e.getMessage());
            return null;
        }
    }
}

// --- Arquivo: service\clientes\ClienteService.java
// --- Classe: ClienteService
package br.com.fiap.service.clientes;

import br.com.fiap.dto.cliente.ClienteInfoDTO;    // <<< Importar
import br.com.fiap.dto.cliente.ClienteRequestDto;
import br.com.fiap.dto.cliente.ClienteResponseDto;
import br.com.fiap.model.relacionamentos.ClienteId;
import java.util.List;

public interface ClienteService {
    List<ClienteResponseDto> findAll();
    ClienteResponseDto findById(ClienteId id);
    ClienteResponseDto create(ClienteRequestDto clienteDto);
    ClienteResponseDto update(ClienteId id, ClienteRequestDto clienteDto);
    void deleteById(ClienteId id);

    // Assinatura do novo método de busca
    List<ClienteInfoDTO> buscarClientes(String nome, String documento, Long idCliente);
}

// --- Arquivo: service\clientes\ClienteServiceImpl.java
// --- Classe: ClienteServiceImpl
// src/main/java/br/com/fiap/service/clientes/ClienteServiceImpl.java
package br.com.fiap.service.clientes;

import br.com.fiap.dto.cliente.ClienteInfoDTO; // <<< Importar
import br.com.fiap.dto.cliente.ClienteRequestDto;
import br.com.fiap.dto.cliente.ClienteResponseDto;
import br.com.fiap.exception.ClientesNotFoundException;
import br.com.fiap.mapper.ClienteMapper;
import br.com.fiap.mapper.ContatoMapper;
import br.com.fiap.mapper.EnderecoMapper;
import br.com.fiap.model.Clientes;
import br.com.fiap.model.Contato;
import br.com.fiap.model.Endereco;
import br.com.fiap.model.relacionamentos.ClienteId;
import br.com.fiap.repository.AutenticarRepository; // Se usar
import br.com.fiap.repository.ClientesRepository;
import br.com.fiap.repository.ContatoRepository;
import br.com.fiap.repository.EnderecoRepository;
import br.com.fiap.repository.specification.ClienteSpecification; // <<< Importar Specification
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.jpa.domain.Specification; // <<< Importar Specification
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class ClienteServiceImpl implements ClienteService {

    private static final Logger log = LoggerFactory.getLogger(ClienteServiceImpl.class);
    private final ClientesRepository clienteRepository;
    private final EnderecoRepository enderecoRepository;
    private final ContatoRepository contatoRepository;
    private final AutenticarRepository autenticarRepository; // Mantenha se usar
    private final ClienteMapper clienteMapper;
    private final EnderecoMapper enderecoMapper;
    private final ContatoMapper contatoMapper;

    @Autowired
    public ClienteServiceImpl(ClientesRepository clientesRepository, EnderecoRepository enderecoRepository, ContatoRepository contatoRepository, AutenticarRepository autenticarRepository, ClienteMapper clienteMapper, EnderecoMapper enderecoMapper, ContatoMapper contatoMapper) {
        this.clienteRepository = clientesRepository;
        this.enderecoRepository = enderecoRepository;
        this.contatoRepository = contatoRepository;
        this.autenticarRepository = autenticarRepository;
        this.clienteMapper = clienteMapper;
        this.enderecoMapper = enderecoMapper;
        this.contatoMapper = contatoMapper;
    }

    // --- IMPLEMENTAÇÃO DA BUSCA DE CLIENTES ---
    @Override
    @Transactional(readOnly = true)
    public List<ClienteInfoDTO> buscarClientes(String nome, String documento, Long idCliente) {
        log.info("Buscando clientes com critérios: nome='{}', documento='{}', idCliente={}", nome, documento, idCliente);

        Specification<Clientes> spec = Specification.where(null); // Inicia sem filtro

        // Adiciona filtros conforme os parâmetros recebidos
        if (nome != null && !nome.isBlank()) {
            spec = spec.and(ClienteSpecification.nomeContains(nome));
        }
        if (documento != null && !documento.isBlank()) {
            spec = spec.and(ClienteSpecification.numeroDocumentoEquals(documento));
        }
        if (idCliente != null && idCliente > 0) {
            spec = spec.and(ClienteSpecification.idCliEquals(idCliente));
        }

        // Evita buscar tudo se nenhum critério for fornecido (opcional)
        if ((nome == null || nome.isBlank()) && (documento == null || documento.isBlank()) && (idCliente == null || idCliente <= 0)) {
            log.warn("Busca de clientes chamada sem critérios.");
            return List.of(); // Retorna lista vazia ou lança exceção
        }


        List<Clientes> clientesEncontrados = clienteRepository.findAll(spec);
        log.info("Encontrados {} clientes para os critérios.", clientesEncontrados.size());

        // Mapeia para DTO incluindo os IDs necessários
        return clientesEncontrados.stream()
                .map(cliente -> new ClienteInfoDTO(
                        cliente.getId().getIdCli(),
                        cliente.getId().getEnderecoId(), // <<< Pega o ID do endereço do relacionamento
                        cliente.getNome(),
                        cliente.getSobrenome(),
                        cliente.getNumeroDocumento()
                ))
                .collect(Collectors.toList());
    }
    // ----------------------------------------

    // --- Mantenha seus métodos findAll, findById, create, update, deleteById como estavam ---
    // ... (Seu código existente para os outros métodos do ClienteService) ...

    @Override
    @Transactional(readOnly = true)
    public List<ClienteResponseDto> findAll() {
        log.info("Buscando todos os clientes");
        return clienteRepository.findAll().stream()
                .map(clienteMapper::toResponseDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public ClienteResponseDto findById(ClienteId id) {
        log.info("Buscando cliente por ID: {}", id);
        Clientes cliente = findClienteById(id);
        return clienteMapper.toResponseDto(cliente);
    }

    @Override
    @Transactional
    public ClienteResponseDto create(ClienteRequestDto clienteDto) {
        //...(seu código create como antes)...
        log.info("Criando novo cliente: {}", clienteDto.getNome());
        try {
            Endereco enderecoEntity = enderecoMapper.toEntity(clienteDto.getEndereco());
            Endereco savedEndereco = enderecoRepository.save(enderecoEntity);
            log.info("Endereço criado/salvo com ID: {}", savedEndereco.getCodigo());

            Contato contatoEntity = contatoMapper.toEntity(clienteDto.getContato());
            Contato savedContato = contatoRepository.save(contatoEntity);
            log.info("Contato criado/salvo com ID: {}", savedContato.getCodigo());

            Clientes clienteEntity = clienteMapper.toEntity(clienteDto);
            clienteEntity.setEndereco(savedEndereco);
            clienteEntity.setContato(savedContato);

            // Importante: Inicializar o ClienteId se não for feito automaticamente
            if (clienteEntity.getId() == null) {
                clienteEntity.setId(new ClienteId());
            }
            // O @MapsId no relacionamento com Endereco deve cuidar de setar enderecoId
            // O idCli será gerado pelo sequence/trigger do banco

            Clientes savedCliente = clienteRepository.save(clienteEntity);
            log.info("Cliente criado com ID_CLI: {}, ID_ENDERECO: {}", savedCliente.getId().getIdCli(), savedCliente.getId().getEnderecoId());

            return clienteMapper.toResponseDto(savedCliente);

        } catch (Exception e) {
            log.error("Erro ao criar cliente: {}", e.getMessage(), e);
            throw new RuntimeException("Falha ao criar cliente", e);
        }
    }

    @Override
    @Transactional
    public ClienteResponseDto update(ClienteId id, ClienteRequestDto clienteDto) {
        //...(seu código update como antes)...
        log.info("Atualizando cliente com ID: {}", id);
        Clientes existingCliente = findClienteById(id);
        Endereco existingEndereco = existingCliente.getEndereco();
        if (existingEndereco != null && clienteDto.getEndereco() != null) {
            enderecoMapper.updateEntityFromDto(clienteDto.getEndereco(), existingEndereco);
            enderecoRepository.save(existingEndereco);
        } else {
            log.warn("Endereço existente ou DTO de endereço nulo para cliente ID {}. Não foi possível atualizar o endereço.", id);
        }

        Contato existingContato = existingCliente.getContato();
        if (existingContato != null && clienteDto.getContato() != null) {
            contatoMapper.updateEntityFromDto(clienteDto.getContato(), existingContato);
            contatoRepository.save(existingContato);
        } else {
            log.warn("Contato existente ou DTO de contato nulo para cliente ID {}. Não foi possível atualizar o contato.", id);
        }

        clienteMapper.updateEntityFromDto(clienteDto, existingCliente);
        Clientes updatedCliente = clienteRepository.save(existingCliente);
        log.info("Cliente atualizado com ID: {}", updatedCliente.getId());
        return clienteMapper.toResponseDto(updatedCliente);
    }

    @Override
    @Transactional
    public void deleteById(ClienteId id) {
        //...(seu código deleteById como antes)...
        log.info("Deletando cliente com ID: {}", id);
        Clientes cliente = findClienteById(id);
        try {
            clienteRepository.delete(cliente);
            log.info("Cliente deletado com ID: {}", id);
            // Considere deletar Endereco/Contato órfãos aqui se necessário e seguro
        } catch (Exception e) {
            log.error("Erro ao deletar cliente com ID {}: {}", id, e.getMessage(), e);
            throw new RuntimeException("Falha ao deletar cliente com ID: " + id, e);
        }
    }

    private Clientes findClienteById(ClienteId id) {
        if (id == null || id.getIdCli() == null || id.getEnderecoId() == null) {
            throw new IllegalArgumentException("ID do Cliente (composto) não pode ser nulo ou incompleto.");
        }
        return clienteRepository.findById(id)
                .orElseThrow(() -> new ClientesNotFoundException("Cliente não encontrado com ID: " + id));
    }
}

// --- Arquivo: service\ia\GoogleGeminiService.java
// --- Classe: GoogleGeminiService
// ===========================================================================
// 1. Interface (Arquivo: src/main/java/br/com/fiap/service/ia/GoogleGeminiService.java)
// ===========================================================================
package br.com.fiap.service.ia;

/**
 * Interface definindo o contrato para serviços que geram diagnósticos via API Google Gemini.
 */
public interface GoogleGeminiService { // <<< Interface Renomeada

    /**
     * Gera um diagnóstico sugerido com base na descrição do problema.
     * @param descricaoProblema A descrição fornecida pelo usuário.
     * @return Uma string com o diagnóstico sugerido pela IA, ou uma mensagem de erro/padrão.
     */
    String gerarDiagnostico(String descricaoProblema);
}

// --- Arquivo: service\ia\GoogleGeminiServiceImpl.java
// --- Classe: GoogleGeminiServiceImpl
package br.com.fiap.service.ia;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.ai.chat.client.ChatClient; // Importar ChatClient
import org.springframework.ai.chat.model.ChatResponse; // Para pegar a resposta
import org.springframework.ai.chat.prompt.Prompt;     // Para criar o prompt
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class GoogleGeminiServiceImpl implements GoogleGeminiService {

    private static final Logger log = LoggerFactory.getLogger(GoogleGeminiServiceImpl.class);
    private final ChatClient chatClient;

    @Autowired
    public GoogleGeminiServiceImpl(ChatClient.Builder chatClientBuilder) {
        this.chatClient = chatClientBuilder.build();
        log.info("ChatClient do Spring AI (Vertex AI/Gemini) inicializado.");
    }

    @Override
    public String gerarDiagnostico(String descricaoProblema) {
        log.info("Chamando IA (Vertex AI/Gemini) via Spring AI ChatClient para: '{}'", descricaoProblema);

        String promptTexto = String.format(
                "Aja como um mecânico experiente. Gere um possível diagnóstico técnico conciso (max 1-2 frases), liste as prováveis partes afetadas (max 3-4 itens em lista simples) e estime um número de horas de trabalho (apenas o número, ex: '2.5') para um veículo com o seguinte problema descrito pelo cliente: \"%s\"",
                descricaoProblema
        );

        try {
            Prompt prompt = new Prompt(promptTexto);
            ChatResponse response = chatClient.prompt(prompt).call().chatResponse();

            // --- CORREÇÃO APLICADA AQUI ---
            // Pega o conteúdo da resposta usando getText()
            String diagnosticoGerado = response.getResult().getOutput().getText();
            // -----------------------------

            if (diagnosticoGerado == null || diagnosticoGerado.isBlank()) {
                log.warn("Resposta da IA via Spring AI veio vazia ou nula.");
                return "Não foi possível gerar um diagnóstico (resposta vazia da IA).";
            }

            log.info("Diagnóstico Spring AI recebido com sucesso.");
            // Limita tamanho
            return diagnosticoGerado.substring(0, Math.min(diagnosticoGerado.length(), 4000));

        } catch (Exception e) {
            log.error("Erro ao chamar IA via Spring AI: {}", e.getMessage(), e);
            return "Erro ao se comunicar com o serviço de IA.";
        }
    }
}

// --- Arquivo: service\oficina\OficinaService.java
// --- Classe: OficinaService
package br.com.fiap.service.oficina;

import br.com.fiap.dto.oficina.OficinaRequestDto;
import br.com.fiap.dto.oficina.OficinaResponseDto;
import java.util.List;

public interface OficinaService {
    List<OficinaResponseDto> findAll();
    OficinaResponseDto findById(Long id);
    OficinaResponseDto create(OficinaRequestDto oficinaDto);
    OficinaResponseDto update(Long id, OficinaRequestDto oficinaDto);
    void deleteById(Long id);
}

// --- Arquivo: service\oficina\OficinaServiceImpl.java
// --- Classe: OficinaServiceImpl
// ===========================================================================
// 3. OficinaServiceImpl (Injeção Atualizada)
// Arquivo: src/main/java/br/com/fiap/service/oficina/OficinaServiceImpl.java
// ===========================================================================
package br.com.fiap.service.oficina;

// ... (Importações) ...
import br.com.fiap.service.ia.GoogleGeminiService; // <<< Importa a NOVA interface
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import br.com.fiap.dto.oficina.OficinaRequestDto;
import br.com.fiap.dto.oficina.OficinaResponseDto;
import br.com.fiap.exception.OficinaNotFoundException;
import br.com.fiap.mapper.OficinaMapper;
import br.com.fiap.model.Oficina;
import br.com.fiap.repository.OficinaRepository;
import java.util.List;
import java.util.stream.Collectors;


@Service
public class OficinaServiceImpl implements OficinaService {

    private static final Logger log = LoggerFactory.getLogger(OficinaServiceImpl.class);
    private final OficinaRepository oficinaRepository;
    private final OficinaMapper oficinaMapper;
    // Injeção usa o novo nome da interface (pode ser removida se não usada aqui)
    // private final GoogleGeminiService iaService;

    @Autowired
    public OficinaServiceImpl(OficinaRepository oficinaRepository,
                              OficinaMapper oficinaMapper
            /* , GoogleGeminiService iaService */ ) { // <<< Tipo atualizado (removido do construtor se não for usado aqui)
        this.oficinaRepository = oficinaRepository;
        this.oficinaMapper = oficinaMapper;
        // this.iaService = iaService;
    }

    // ... (Restante da classe OficinaServiceImpl, método create SEM a chamada iaService) ...
    @Override
    @Transactional
    public OficinaResponseDto create(OficinaRequestDto oficinaDto) {
        log.info("Criando nova oficina (diagnóstico vindo do DTO)");
        try {
            Oficina oficina = oficinaMapper.toEntity(oficinaDto);
            // Chamada IA foi removida daqui
            Oficina savedOficina = oficinaRepository.save(oficina);
            log.info("Oficina criada com ID: {}", savedOficina.getId());
            return oficinaMapper.toResponseDto(savedOficina);
        } catch (Exception e) {
            log.error("Erro ao criar oficina: {}", e.getMessage(), e);
            throw new RuntimeException("Falha ao criar oficina", e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public List<OficinaResponseDto> findAll() {
        log.info("Buscando todas as oficinas");
        return oficinaRepository.findAll().stream()
                .map(oficinaMapper::toResponseDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public OficinaResponseDto findById(Long id) {
        log.info("Buscando oficina por ID: {}", id);
        Oficina oficina = findOficinaById(id);
        return oficinaMapper.toResponseDto(oficina);
    }

    @Override
    @Transactional
    public OficinaResponseDto update(Long id, OficinaRequestDto oficinaDto) {
        log.info("Atualizando oficina com ID: {}", id);
        Oficina existingOficina = findOficinaById(id);
        oficinaMapper.updateEntityFromDto(oficinaDto, existingOficina);
        Oficina updatedOficina = oficinaRepository.save(existingOficina);
        log.info("Oficina atualizada com ID: {}", updatedOficina.getId());
        return oficinaMapper.toResponseDto(updatedOficina);
    }

    @Override
    @Transactional
    public void deleteById(Long id) {
        log.info("Deletando oficina com ID: {}", id);
        Oficina oficina = findOficinaById(id); // Verifica existência
        try {
            oficinaRepository.delete(oficina);
            log.info("Oficina deletada com ID: {}", id);
        } catch (Exception e) {
            log.error("Erro ao deletar oficina com ID {}: {}", id, e.getMessage(), e);
            throw new RuntimeException("Falha ao deletar oficina com ID: " + id, e);
        }
    }

    private Oficina findOficinaById(Long id) {
        return oficinaRepository.findById(id)
                .orElseThrow(() -> new OficinaNotFoundException("Oficina não encontrada com ID: " + id));
    }
}


// --- Arquivo: service\orcamento\OrcamentoService.java
// --- Classe: OrcamentoService
package br.com.fiap.service.orcamento;

import br.com.fiap.dto.orcamento.OrcamentoRequestDto;
import br.com.fiap.dto.orcamento.OrcamentoResponseDto;
import java.util.List;

public interface OrcamentoService {
    List<OrcamentoResponseDto> findAll();
    OrcamentoResponseDto findById(Long id);
    OrcamentoResponseDto create(OrcamentoRequestDto orcamentoDto);
    OrcamentoResponseDto update(Long id, OrcamentoRequestDto orcamentoDto);
    void deleteById(Long id);
}

// --- Arquivo: service\orcamento\OrcamentoServiceImpl.java
// --- Classe: OrcamentoServiceImpl
// --- src/main/java/br/com/fiap/service/orcamento/OrcamentoServiceImpl.java ---
package br.com.fiap.service.orcamento;

import br.com.fiap.dto.orcamento.OrcamentoRequestDto;
import br.com.fiap.dto.orcamento.OrcamentoResponseDto;
import br.com.fiap.exception.OrcamentoNotFoundException;
import br.com.fiap.mapper.OrcamentoMapper; // Importar Mapper
import br.com.fiap.model.Orcamento;
import br.com.fiap.repository.OrcamentoRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;
import java.util.stream.Collectors;
// import java.math.BigDecimal; // Se for implementar cálculo

@Service
public class OrcamentoServiceImpl implements OrcamentoService {

    private static final Logger log = LoggerFactory.getLogger(OrcamentoServiceImpl.class);
    private final OrcamentoRepository orcamentoRepository;
    private final OrcamentoMapper orcamentoMapper; // <-- Injetar Mapper

    @Autowired
    public OrcamentoServiceImpl(OrcamentoRepository orcamentoRepository, OrcamentoMapper orcamentoMapper) { // <-- Injetar
        this.orcamentoRepository = orcamentoRepository;
        this.orcamentoMapper = orcamentoMapper; // <-- Inicializar
    }

    @Override
    @Transactional(readOnly = true)
    public List<OrcamentoResponseDto> findAll() {
        log.info("Buscando todos os orçamentos");
        return orcamentoRepository.findAll().stream()
                .map(orcamentoMapper::toResponseDto) // <-- Usar Mapper
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public OrcamentoResponseDto findById(Long id) {
        log.info("Buscando orçamento por ID: {}", id);
        Orcamento orcamento = findOrcamentoById(id);
        return orcamentoMapper.toResponseDto(orcamento); // <-- Usar Mapper
    }

    @Override
    @Transactional
    public OrcamentoResponseDto create(OrcamentoRequestDto orcamentoDto) {
        log.info("Criando novo orçamento");
        // Adicionar lógica de cálculo se necessário antes de mapear/salvar
        try {
            Orcamento orcamento = orcamentoMapper.toEntity(orcamentoDto); // <-- Usar Mapper
            // Recalcular valor total aqui se a regra for essa
            // orcamento.setValorTotal(calcularValorTotal(orcamento));
            Orcamento savedOrcamento = orcamentoRepository.save(orcamento);
            log.info("Orçamento criado com ID: {}", savedOrcamento.getId());
            return orcamentoMapper.toResponseDto(savedOrcamento); // <-- Usar Mapper
        } catch (Exception e) {
            log.error("Erro ao criar orçamento: {}", e.getMessage(), e);
            throw new RuntimeException("Falha ao criar orçamento", e);
        }
    }

    @Override
    @Transactional
    public OrcamentoResponseDto update(Long id, OrcamentoRequestDto orcamentoDto) {
        log.info("Atualizando orçamento com ID: {}", id);
        Orcamento existingOrcamento = findOrcamentoById(id);
        orcamentoMapper.updateEntityFromDto(orcamentoDto, existingOrcamento); // <-- Usar Mapper
        // Recalcular valor total se necessário
        // existingOrcamento.setValorTotal(calcularValorTotal(existingOrcamento));
        Orcamento updatedOrcamento = orcamentoRepository.save(existingOrcamento);
        log.info("Orçamento atualizado com ID: {}", updatedOrcamento.getId());
        return orcamentoMapper.toResponseDto(updatedOrcamento); // <-- Usar Mapper
    }

    @Override
    @Transactional
    public void deleteById(Long id) {
        log.info("Deletando orçamento com ID: {}", id);
        Orcamento orcamento = findOrcamentoById(id); // Verifica existência
        try {
            orcamentoRepository.delete(orcamento);
            log.info("Orçamento deletado com ID: {}", id);
        } catch (Exception e) {
            log.error("Erro ao deletar orçamento com ID {}: {}", id, e.getMessage(), e);
            throw new RuntimeException("Falha ao deletar orçamento com ID: " + id, e);
        }
    }

    // --- Método auxiliar ---
    private Orcamento findOrcamentoById(Long id) {
        return orcamentoRepository.findById(id)
                .orElseThrow(() -> new OrcamentoNotFoundException("Orçamento não encontrado com ID: " + id));
    }

    // REMOVER os métodos manuais de mapeamento:
    // mapEntityToResponseDto(Orcamento entity)
    // mapRequestDtoToEntity(OrcamentoRequestDto dto)
    // updateEntityFromDto(Orcamento entity, OrcamentoRequestDto dto)

    // Manter método de cálculo se existir e for usado:
    // private BigDecimal calcularValorTotal(Orcamento orcamento) { ... }
}

// --- Arquivo: service\pagamento\PagamentoService.java
// --- Classe: PagamentoService
package br.com.fiap.service.pagamento;

import br.com.fiap.dto.pagamento.PagamentoRequestDto;
import br.com.fiap.dto.pagamento.PagamentoResponseDto;
import java.util.List;

public interface PagamentoService {
    List<PagamentoResponseDto> findAll();
    PagamentoResponseDto findById(Long id);
    PagamentoResponseDto create(PagamentoRequestDto pagamentoDto);
    PagamentoResponseDto update(Long id, PagamentoRequestDto pagamentoDto);
    void deleteById(Long id);
}

// --- Arquivo: service\pagamento\PagamentoServiceImpl.java
// --- Classe: PagamentoServiceImpl
// --- src/main/java/br/com/fiap/service/pagamento/PagamentoServiceImpl.java ---
package br.com.fiap.service.pagamento;

import br.com.fiap.dto.pagamento.PagamentoRequestDto;
import br.com.fiap.dto.pagamento.PagamentoResponseDto;
import br.com.fiap.exception.PagamentoNotFoundException;
import br.com.fiap.mapper.PagamentoMapper; // Importar Mapper
import br.com.fiap.model.Pagamento;
import br.com.fiap.repository.PagamentoRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class PagamentoServiceImpl implements PagamentoService {

    private static final Logger log = LoggerFactory.getLogger(PagamentoServiceImpl.class);
    private final PagamentoRepository pagamentoRepository;
    private final PagamentoMapper pagamentoMapper; // <-- Injetar Mapper

    @Autowired
    public PagamentoServiceImpl(PagamentoRepository pagamentoRepository, PagamentoMapper pagamentoMapper) { // <-- Injetar
        this.pagamentoRepository = pagamentoRepository;
        this.pagamentoMapper = pagamentoMapper; // <-- Inicializar
    }

    @Override
    @Transactional(readOnly = true)
    public List<PagamentoResponseDto> findAll() {
        log.info("Buscando todos os pagamentos");
        return pagamentoRepository.findAll().stream()
                .map(pagamentoMapper::toResponseDto) // <-- Usar Mapper
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public PagamentoResponseDto findById(Long id) {
        log.info("Buscando pagamento por ID: {}", id);
        Pagamento pagamento = findPagamentoById(id);
        return pagamentoMapper.toResponseDto(pagamento); // <-- Usar Mapper
    }

    @Override
    @Transactional
    public PagamentoResponseDto create(PagamentoRequestDto pagamentoDto) {
        log.info("Criando novo pagamento");
        // Adicionar lógica de cálculo se necessário
        try {
            Pagamento pagamento = pagamentoMapper.toEntity(pagamentoDto); // <-- Usar Mapper
            Pagamento savedPagamento = pagamentoRepository.save(pagamento);
            log.info("Pagamento criado com ID: {}", savedPagamento.getId());
            return pagamentoMapper.toResponseDto(savedPagamento); // <-- Usar Mapper
        } catch (Exception e) {
            log.error("Erro ao criar pagamento: {}", e.getMessage(), e);
            throw new RuntimeException("Falha ao criar pagamento", e);
        }
    }

    @Override
    @Transactional
    public PagamentoResponseDto update(Long id, PagamentoRequestDto pagamentoDto) {
        log.info("Atualizando pagamento com ID: {}", id);
        Pagamento existingPagamento = findPagamentoById(id);
        pagamentoMapper.updateEntityFromDto(pagamentoDto, existingPagamento); // <-- Usar Mapper
        // Recalcular campos se necessário
        Pagamento updatedPagamento = pagamentoRepository.save(existingPagamento);
        log.info("Pagamento atualizado com ID: {}", updatedPagamento.getId());
        return pagamentoMapper.toResponseDto(updatedPagamento); // <-- Usar Mapper
    }

    @Override
    @Transactional
    public void deleteById(Long id) {
        log.info("Deletando pagamento com ID: {}", id);
        Pagamento pagamento = findPagamentoById(id); // Verifica existência
        try {
            pagamentoRepository.delete(pagamento);
            log.info("Pagamento deletado com ID: {}", id);
        } catch (Exception e) {
            log.error("Erro ao deletar pagamento com ID {}: {}", id, e.getMessage(), e);
            throw new RuntimeException("Falha ao deletar pagamento com ID: " + id, e);
        }
    }

    // --- Método auxiliar ---
    private Pagamento findPagamentoById(Long id) {
        return pagamentoRepository.findById(id)
                .orElseThrow(() -> new PagamentoNotFoundException("Pagamento não encontrado com ID: " + id));
    }

    // REMOVER os métodos manuais de mapeamento:
    // mapEntityToResponseDto(Pagamento entity)
    // mapRequestDtoToEntity(PagamentoRequestDto dto)
    // updateEntityFromDto(Pagamento entity, PagamentoRequestDto dto)
}

// --- Arquivo: service\pecas\PecasService.java
// --- Classe: PecasService
package br.com.fiap.service.pecas;

import br.com.fiap.dto.pecas.PecasRequestDto;
import br.com.fiap.dto.pecas.PecasResponseDto;
import java.util.List;

public interface PecasService {
    List<PecasResponseDto> findAll();
    PecasResponseDto findById(Long id);
    PecasResponseDto create(PecasRequestDto pecasDto);
    PecasResponseDto update(Long id, PecasRequestDto pecasDto);
    void deleteById(Long id);
}

// --- Arquivo: service\pecas\PecasServiceImpl.java
// --- Classe: PecasServiceImpl
// --- src/main/java/br/com/fiap/service/pecas/PecasServiceImpl.java ---
package br.com.fiap.service.pecas;

import br.com.fiap.dto.pecas.PecasRequestDto;
import br.com.fiap.dto.pecas.PecasResponseDto;
import br.com.fiap.exception.PecasNotFoundException;
import br.com.fiap.mapper.PecasMapper; // Importar Mapper
import br.com.fiap.model.Pecas;
import br.com.fiap.repository.PecasRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class PecasServiceImpl implements PecasService {

    private static final Logger log = LoggerFactory.getLogger(PecasServiceImpl.class);
    private final PecasRepository pecasRepository;
    private final PecasMapper pecasMapper; // <-- Injetar Mapper

    @Autowired
    public PecasServiceImpl(PecasRepository pecasRepository, PecasMapper pecasMapper) { // <-- Injetar
        this.pecasRepository = pecasRepository;
        this.pecasMapper = pecasMapper; // <-- Inicializar
    }

    @Override
    @Transactional(readOnly = true)
    public List<PecasResponseDto> findAll() {
        log.info("Buscando todas as peças");
        return pecasRepository.findAll().stream()
                .map(pecasMapper::toResponseDto) // <-- Usar Mapper
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public PecasResponseDto findById(Long id) {
        log.info("Buscando peça por ID: {}", id);
        Pecas peca = findPecaById(id);
        return pecasMapper.toResponseDto(peca); // <-- Usar Mapper
    }

    @Override
    @Transactional
    public PecasResponseDto create(PecasRequestDto pecasDto) {
        log.info("Criando nova peça");
        // Adicionar lógica de cálculo se necessário
        try {
            Pecas peca = pecasMapper.toEntity(pecasDto); // <-- Usar Mapper
            Pecas savedPeca = pecasRepository.save(peca);
            log.info("Peça criada com ID: {}", savedPeca.getId());
            return pecasMapper.toResponseDto(savedPeca); // <-- Usar Mapper
        } catch (Exception e) {
            log.error("Erro ao criar peça: {}", e.getMessage(), e);
            throw new RuntimeException("Falha ao criar peça", e);
        }
    }

    @Override
    @Transactional
    public PecasResponseDto update(Long id, PecasRequestDto pecasDto) {
        log.info("Atualizando peça com ID: {}", id);
        Pecas existingPeca = findPecaById(id);
        pecasMapper.updateEntityFromDto(pecasDto, existingPeca); // <-- Usar Mapper
        // Recalcular campos se necessário
        Pecas updatedPeca = pecasRepository.save(existingPeca);
        log.info("Peça atualizada com ID: {}", updatedPeca.getId());
        return pecasMapper.toResponseDto(updatedPeca); // <-- Usar Mapper
    }

    @Override
    @Transactional
    public void deleteById(Long id) {
        log.info("Deletando peça com ID: {}", id);
        Pecas peca = findPecaById(id); // Verifica existência
        try {
            pecasRepository.delete(peca);
            log.info("Peça deletada com ID: {}", id);
        } catch (Exception e) {
            log.error("Erro ao deletar peça com ID {}: {}", id, e.getMessage(), e);
            throw new RuntimeException("Falha ao deletar peça com ID: " + id, e);
        }
    }

    // --- Método auxiliar ---
    private Pecas findPecaById(Long id) {
        return pecasRepository.findById(id)
                .orElseThrow(() -> new PecasNotFoundException("Peça não encontrada com ID: " + id));
    }

    // REMOVER os métodos manuais de mapeamento:
    // mapEntityToResponseDto(Pecas entity)
    // mapRequestDtoToEntity(PecasRequestDto dto)
    // updateEntityFromDto(Pecas entity, PecasRequestDto dto)
}

// --- Arquivo: service\relatorio\RelatorioService.java
// --- Classe: RelatorioService
// src/main/java/br/com/fiap/service/relatorio/RelatorioService.java
package br.com.fiap.service.relatorio;

import br.com.fiap.dto.relatorio.ContagemMensalDTO;
import br.com.fiap.dto.relatorio.HistoricoAgendamentoClienteDTO;
import br.com.fiap.dto.relatorio.ServicoAgendadoDTO; // <<< Importar
import br.com.fiap.model.relacionamentos.ClienteId;
import org.springframework.data.domain.Page;      // <<< Importar Page
import org.springframework.data.domain.Pageable;   // <<< Importar Pageable
import java.time.LocalDate;                     // <<< Importar LocalDate
import java.util.List;

public interface RelatorioService {

    List<ContagemMensalDTO> getContagemMensalAgendamentos();
    List<HistoricoAgendamentoClienteDTO> getHistoricoAgendamentosCliente(ClienteId id);

    // <<< Assinatura Adicionada >>>
    Page<ServicoAgendadoDTO> findServicosAgendados(LocalDate dataInicio, Pageable pageable);
    // ---------------------------
}

// --- Arquivo: service\relatorio\RelatorioServiceImpl.java
// --- Classe: RelatorioServiceImpl
// src/main/java/br/com/fiap/service/relatorio/RelatorioServiceImpl.java
package br.com.fiap.service.relatorio;

import br.com.fiap.dto.relatorio.ContagemMensalDTO;
import br.com.fiap.dto.relatorio.ContagemMensalResultadoNativo;
import br.com.fiap.dto.relatorio.HistoricoAgendamentoClienteDTO;
import br.com.fiap.dto.relatorio.ServicoAgendadoDTO;
import br.com.fiap.exception.ClientesNotFoundException;
import br.com.fiap.model.relacionamentos.ClienteId;
import br.com.fiap.repository.AgendaRepository;
import br.com.fiap.repository.ClientesRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.time.LocalDate;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class RelatorioServiceImpl implements RelatorioService {

    private static final Logger log = LoggerFactory.getLogger(RelatorioServiceImpl.class);
    private final AgendaRepository agendaRepository;
    private final ClientesRepository clientesRepository;

    @Autowired
    public RelatorioServiceImpl(AgendaRepository agendaRepository, ClientesRepository clientesRepository) {
        this.agendaRepository = agendaRepository;
        this.clientesRepository = clientesRepository;
    }

    @Override
    @Transactional(readOnly = true)
    public List<ContagemMensalDTO> getContagemMensalAgendamentos() {
        log.info("Gerando relatório de contagem mensal de agendamentos.");
        try {
            List<ContagemMensalResultadoNativo> resultadosNativos = agendaRepository.countAgendamentosByMonthNative();
            List<ContagemMensalDTO> resultadoDTO = resultadosNativos.stream()
                    .map(nativo -> new ContagemMensalDTO(nativo.getMesAno(), nativo.getQuantidade()))
                    .collect(Collectors.toList());
            log.info("Relatório de contagem mensal gerado com {} resultados.", resultadoDTO.size());
            return resultadoDTO; // <<< CORREÇÃO: ADICIONADO O RETURN AQUI
        } catch (Exception e) {
            log.error("Erro ao gerar relatório de contagem mensal: {}", e.getMessage(), e);
            return Collections.emptyList();
        }
    }

    @Override
    @Transactional(readOnly = true)
    public List<HistoricoAgendamentoClienteDTO> getHistoricoAgendamentosCliente(ClienteId id) {
        log.info("Buscando histórico de agendamentos para Cliente ID: {}", id);
        // 1. Valida ID composto
        if (id == null || id.getIdCli() == null || id.getEnderecoId() == null) {
            throw new IllegalArgumentException("ID do Cliente (composto) inválido para buscar histórico.");
        }
        // 2. Verifica se o cliente existe
        if (!clientesRepository.existsById(id)) {
            log.warn("Tentativa de buscar histórico para cliente inexistente: {}", id);
            throw new ClientesNotFoundException("Cliente não encontrado com ID: " + id);
        }
        // 3. Busca o histórico
        try {
            List<HistoricoAgendamentoClienteDTO> historico = agendaRepository.findHistoricoAgendamentosByClienteId(id.getIdCli(), id.getEnderecoId());
            log.info("Encontrados {} registros de histórico para o cliente ID {}", historico.size(), id);
            return historico; // Return no sucesso
        } catch (Exception e) {
            log.error("Erro ao buscar histórico para cliente ID {}: {}", id, e.getMessage(), e);
            return Collections.emptyList(); // Return no erro
        }
        // Não há return fora do try/catch pois todas as branches retornam
    }


    @Override
    @Transactional(readOnly = true)
    public Page<ServicoAgendadoDTO> findServicosAgendados(LocalDate dataInicio, Pageable pageable) {
        log.info("Buscando relatório de serviços agendados a partir de {} com paginação {}", dataInicio, pageable);
        try {
            Page<ServicoAgendadoDTO> pagina = agendaRepository.findServicosAgendados(dataInicio, pageable);
            log.info("Encontrados {} serviços agendados na página {}/{}",
                    pagina.getNumberOfElements(),
                    pageable.getPageNumber(),
                    pagina.getTotalPages());
            return pagina; // Return no sucesso
        } catch (Exception e) {
            log.error("Erro ao buscar relatório de serviços agendados: {}", e.getMessage(), e);
            return Page.empty(pageable); // Return no erro
        }
        // Não há return fora do try/catch pois todas as branches retornam
    }
}

// --- Arquivo: service\relatorio\cliente\RelatorioClienteService.java
// --- Classe: RelatorioClienteService
// --- Arquivo: src/main/java/br/com/fiap/service/relatorio/cliente/RelatorioClienteService.java ---
package br.com.fiap.service.relatorio.cliente;

import br.com.fiap.dto.relatorio.ClienteRelatorioCompletoDTO;

/**
 * Interface para serviços de geração de relatórios específicos de clientes.
 */
public interface RelatorioClienteService {

    /**
     * Busca e compila um relatório completo com todos os dados associados
     * a um cliente, encontrado por ID ou Documento.
     *
     * @param tipoBusca "id" ou "documento"
     * @param valorBusca O valor correspondente (ID_CLI ou CPF/CNPJ)
     * @return Um DTO contendo todas as informações agregadas do cliente.
     * @throws br.com.fiap.exception.ClientesNotFoundException Se o cliente não for encontrado.
     * @throws IllegalArgumentException Se o tipoBusca for inválido ou o valorBusca não for compatível.
     */
    ClienteRelatorioCompletoDTO getRelatorioCompletoCliente(String tipoBusca, String valorBusca);

}

// --- Arquivo: service\relatorio\cliente\RelatorioClienteServiceImpl.java
// --- Classe: RelatorioClienteServiceImpl
// --- Arquivo: src/main/java/br/com/fiap/service/relatorio/cliente/RelatorioClienteServiceImpl.java ---
package br.com.fiap.service.relatorio.cliente;

// --- Imports Verificados e Completos ---
import br.com.fiap.dto.relatorio.ClienteRelatorioCompletoDTO;
import br.com.fiap.dto.relatorio.ClienteRelatorioCompletoDTO.*; // Para Sub-DTOs aninhados
import br.com.fiap.dto.cliente.ClienteResponseDto; // Import do DTO Cliente
import br.com.fiap.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.dto.orcamento.OrcamentoResponseDto; // <<< IMPORT ESSENCIAL
import br.com.fiap.dto.pagamento.PagamentoResponseDto; // <<< IMPORT ESSENCIAL
// Importe outros DTOs usados se necessário (AgendaSimplificadoDTO, OficinaServicoDTO, etc., se não forem aninhados)

import br.com.fiap.exception.ClientesNotFoundException;
import br.com.fiap.mapper.*;
import br.com.fiap.model.*;
import br.com.fiap.model.relacionamentos.*;
import br.com.fiap.repository.*;
import br.com.fiap.repository.relacionamentos.*;
import br.com.fiap.repository.specification.ClienteSpecification;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
// ---------------------------------------

@Service
public class RelatorioClienteServiceImpl implements RelatorioClienteService {

    private static final Logger log = LoggerFactory.getLogger(RelatorioClienteServiceImpl.class);

    // --- Injeções (sem alterações) ---
    private final ClientesRepository clienteRepository;
    private final VeiculoRepository veiculoRepository;
    private final AgendaRepository agendaRepository;
    private final OficinaRepository oficinaRepository;
    private final PecasRepository pecasRepository;
    private final OrcamentoRepository orcamentoRepository;
    private final PagamentoRepository pagamentoRepository;
    private final ClienteVeiculoRepository clienteVeiculoRepository;
    private final AgendaVeiculoRepository agendaVeiculoRepository;
    private final OficinaVeiculoRepository oficinaVeiculoRepository;
    private final OficinaPecaRepository oficinaPecaRepository;
    private final ClienteOrcamentoRepository clienteOrcamentoRepository;
    private final ClientePagamentoRepository clientePagamentoRepository;
    private final ClienteMapper clienteMapper;
    private final VeiculoMapper veiculoMapper;
    private final AgendaMapper agendaMapper;
    private final OficinaMapper oficinaMapper;
    private final PecasMapper pecasMapper;
    private final OrcamentoMapper orcamentoMapper;
    private final PagamentoMapper pagamentoMapper;
    private final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");

    @Autowired
    public RelatorioClienteServiceImpl(
            ClientesRepository clienteRepository, VeiculoRepository veiculoRepository,
            AgendaRepository agendaRepository, OficinaRepository oficinaRepository,
            PecasRepository pecasRepository, OrcamentoRepository orcamentoRepository,
            PagamentoRepository pagamentoRepository,
            ClienteVeiculoRepository clienteVeiculoRepository,
            AgendaVeiculoRepository agendaVeiculoRepository,
            OficinaVeiculoRepository oficinaVeiculoRepository,
            OficinaPecaRepository oficinaPecaRepository,
            ClienteOrcamentoRepository clienteOrcamentoRepository,
            ClientePagamentoRepository clientePagamentoRepository,
            ClienteMapper clienteMapper, VeiculoMapper veiculoMapper,
            AgendaMapper agendaMapper, OficinaMapper oficinaMapper,
            PecasMapper pecasMapper, OrcamentoMapper orcamentoMapper,
            PagamentoMapper pagamentoMapper) {
        // ... atribuições do construtor ...
        this.clienteRepository = clienteRepository;
        this.veiculoRepository = veiculoRepository;
        this.agendaRepository = agendaRepository;
        this.oficinaRepository = oficinaRepository;
        this.pecasRepository = pecasRepository;
        this.orcamentoRepository = orcamentoRepository;
        this.pagamentoRepository = pagamentoRepository;
        this.clienteVeiculoRepository = clienteVeiculoRepository;
        this.agendaVeiculoRepository = agendaVeiculoRepository;
        this.oficinaVeiculoRepository = oficinaVeiculoRepository;
        this.oficinaPecaRepository = oficinaPecaRepository;
        this.clienteOrcamentoRepository = clienteOrcamentoRepository;
        this.clientePagamentoRepository = clientePagamentoRepository;
        this.clienteMapper = clienteMapper;
        this.veiculoMapper = veiculoMapper;
        this.agendaMapper = agendaMapper;
        this.oficinaMapper = oficinaMapper;
        this.pecasMapper = pecasMapper;
        this.orcamentoMapper = orcamentoMapper;
        this.pagamentoMapper = pagamentoMapper;
    }

    @Override
    @Transactional(readOnly = true)
    public ClienteRelatorioCompletoDTO getRelatorioCompletoCliente(String tipoBusca, String valorBusca) {
        log.info("Gerando relatório completo para cliente: tipo={}, valor={}", tipoBusca, valorBusca);

        // 1. Encontrar o Cliente (sem alterações)
        Specification<Clientes> spec = Specification.where(null);
        if ("id".equalsIgnoreCase(tipoBusca)) {
            try { Long idCli = Long.parseLong(valorBusca); spec = spec.and(ClienteSpecification.idCliEquals(idCli)); }
            catch (NumberFormatException e) { throw new IllegalArgumentException("ID do cliente inválido: " + valorBusca); }
        } else if ("documento".equalsIgnoreCase(tipoBusca)) {
            spec = spec.and(ClienteSpecification.numeroDocumentoEquals(valorBusca));
        } else { throw new IllegalArgumentException("Tipo de busca inválido: " + tipoBusca); }

        Optional<Clientes> clienteOpt = clienteRepository.findAll(spec).stream().findFirst();
        if (clienteOpt.isEmpty()) { throw new ClientesNotFoundException("Cliente não encontrado para os critérios fornecidos."); }
        Clientes cliente = clienteOpt.get();
        ClienteId clienteId = cliente.getId();

        // 2. Mapear Dados Básicos (sem alterações)
        ClienteRelatorioCompletoDTO relatorio = new ClienteRelatorioCompletoDTO();
        relatorio.setCliente(clienteMapper.toResponseDto(cliente));

        // 3. Buscar Veículos Associados (Usa o método correto do repo)
        List<ClienteVeiculo> clienteVeiculos = clienteVeiculoRepository.findByCliente_Id(clienteId); // CORRIGIDO
        List<VeiculoResponseDto> veiculosDto = clienteVeiculos.stream()
                .map(cv -> veiculoMapper.toResponseDto(cv.getVeiculo()))
                .collect(Collectors.toList());
        relatorio.setVeiculos(veiculosDto);
        List<Long> veiculoIds = clienteVeiculos.stream().map(cv -> cv.getVeiculo().getId()).collect(Collectors.toList());

        // 4. Buscar Agendamentos (Usa o método correto do repo e ordena antes)
        if (!veiculoIds.isEmpty()) {
            List<AgendaVeiculo> agendaVeiculos = agendaVeiculoRepository.findByVeiculoIdIn(veiculoIds); // CORRIGIDO
            List<AgendaSimplificadoDTO> agendamentosDto = agendaVeiculos.stream()
                    .sorted(Comparator.comparing( (AgendaVeiculo av) -> av.getAgenda().getDataAgendamento(), Comparator.nullsLast(Comparator.reverseOrder()) ))
                    .map(av -> {
                        AgendaSimplificadoDTO dto = new AgendaSimplificadoDTO();
                        dto.setId(av.getAgenda().getId());
                        dto.setDataAgendamento(av.getAgenda().getDataAgendamento() != null ? av.getAgenda().getDataAgendamento().format(dateFormatter) : null);
                        dto.setObservacao(av.getAgenda().getObservacao());
                        dto.setVeiculoPlaca(av.getVeiculo().getPlaca());
                        return dto;
                    })
                    .collect(Collectors.toList());
            relatorio.setAgendamentos(agendamentosDto);
            relatorio.setTotalAgendamentos(agendamentosDto.size());
        } else {
            relatorio.setAgendamentos(Collections.emptyList());
            relatorio.setTotalAgendamentos(0);
        }

        // 5. Buscar Serviços de Oficina e Peças (Usa os métodos corretos dos repos e ordena antes)
        if (!veiculoIds.isEmpty()) {
            List<OficinaVeiculo> oficinaVeiculos = oficinaVeiculoRepository.findByVeiculoIdIn(veiculoIds); // CORRIGIDO
            List<OficinaServicoDTO> servicosDto = oficinaVeiculos.stream()
                    .sorted(Comparator.comparing( (OficinaVeiculo ov) -> ov.getOficina().getDataOficina(), Comparator.nullsLast(Comparator.reverseOrder()) ))
                    .map(ov -> {
                        Oficina oficina = ov.getOficina();
                        OficinaServicoDTO dto = new OficinaServicoDTO();
                        dto.setIdOficina(oficina.getId());
                        dto.setDataOficina(oficina.getDataOficina() != null ? oficina.getDataOficina().format(dateFormatter) : null);
                        dto.setDescricaoProblema(oficina.getDescricaoProblema());
                        dto.setDiagnostico(oficina.getDiagnostico());
                        dto.setPartesAfetadas(oficina.getPartesAfetadas());
                        dto.setHorasTrabalhadas(oficina.getHorasTrabalhadas());
                        dto.setVeiculoPlaca(ov.getVeiculo().getPlaca());

                        List<OficinaPeca> oficinaPecas = oficinaPecaRepository.findByOficinaId(oficina.getId()); // CORRIGIDO
                        List<PecaUtilizadaDTO> pecasDto = oficinaPecas.stream()
                                .map(op -> {
                                    Pecas peca = op.getPeca();
                                    PecaUtilizadaDTO pecaDto = new PecaUtilizadaDTO();
                                    pecaDto.setIdPeca(peca.getId());
                                    pecaDto.setDescricaoPeca(peca.getDescricao());
                                    pecaDto.setFabricante(peca.getFabricante());
                                    return pecaDto;
                                })
                                .collect(Collectors.toList());
                        dto.setPecasUtilizadas(pecasDto);
                        return dto;
                    })
                    .collect(Collectors.toList());
            relatorio.setServicosOficina(servicosDto);
        } else {
            relatorio.setServicosOficina(Collections.emptyList());
        }

        // 6. Buscar Orçamentos (Já estava correto, apenas garantindo import)
        List<ClienteOrcamento> clienteOrcamentos = clienteOrcamentoRepository.findByCliente_Id(clienteId);
        List<OrcamentoResponseDto> orcamentosDto = clienteOrcamentos.stream()
                .map(co -> orcamentoMapper.toResponseDto(co.getOrcamento()))
                .sorted(Comparator.comparing( OrcamentoResponseDto::getDataOrcamento, Comparator.nullsLast(Comparator.reverseOrder()) ))
                .collect(Collectors.toList());
        relatorio.setOrcamentos(orcamentosDto);

        // 7. Buscar Pagamentos (Já estava correto, apenas garantindo import)
        List<ClientePagamento> clientePagamentos = clientePagamentoRepository.findByCliente_Id(clienteId);
        List<PagamentoResponseDto> pagamentosDto = clientePagamentos.stream()
                .map(cp -> pagamentoMapper.toResponseDto(cp.getPagamento()))
                .sorted(Comparator.comparing( PagamentoResponseDto::getDataPagamento, Comparator.nullsLast(Comparator.reverseOrder()) ))
                .collect(Collectors.toList());
        relatorio.setPagamentos(pagamentosDto);

        log.info("Relatório completo gerado com sucesso para cliente ID: {}", clienteId);
        return relatorio;
    }
}

// --- Arquivo: service\veiculo\VeiculoService.java
// --- Classe: VeiculoService
// src/main/java/br/com/fiap/service/veiculo/VeiculoService.java
package br.com.fiap.service.veiculo;

import br.com.fiap.dto.veiculo.VeiculoRequestDto;
import br.com.fiap.dto.veiculo.VeiculoResponseDto;
import java.util.List;

public interface VeiculoService {
    List<VeiculoResponseDto> findAll();
    VeiculoResponseDto findById(Long id);
    VeiculoResponseDto create(VeiculoRequestDto veiculoDto);
    VeiculoResponseDto update(Long id, VeiculoRequestDto veiculoDto);
    void deleteById(Long id);

    // <<< NOVA ASSINATURA PARA BUSCA >>>
    List<VeiculoResponseDto> buscarVeiculos(String placa, String modelo, String proprietario);
    // ---------------------------------
}

// --- Arquivo: service\veiculo\VeiculoServiceImpl.java
// --- Classe: VeiculoServiceImpl
// src/main/java/br/com/fiap/service/veiculo/VeiculoServiceImpl.java
package br.com.fiap.service.veiculo;

// --- Imports ---
import br.com.fiap.dto.veiculo.VeiculoRequestDto;
import br.com.fiap.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.exception.VeiculoNotFoundException;
import br.com.fiap.mapper.VeiculoMapper;
import br.com.fiap.model.Veiculo;
import br.com.fiap.repository.VeiculoRepository;
import br.com.fiap.repository.specification.VeiculoSpecification;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;
import java.util.stream.Collectors;
// ---------------

@Service
public class VeiculoServiceImpl implements VeiculoService {

    private static final Logger log = LoggerFactory.getLogger(VeiculoServiceImpl.class);
    private final VeiculoRepository veiculoRepository;
    private final VeiculoMapper veiculoMapper;

    @Autowired
    public VeiculoServiceImpl(VeiculoRepository veiculoRepository, VeiculoMapper veiculoMapper) {
        this.veiculoRepository = veiculoRepository;
        this.veiculoMapper = veiculoMapper;
    }

    // --- IMPLEMENTAÇÃO DO MÉTODO DE BUSCA ---
    @Override
    @Transactional(readOnly = true)
    public List<VeiculoResponseDto> buscarVeiculos(String placa, String modelo, String proprietario) {
        log.info("Buscando veículos com critérios: placa='{}', modelo='{}', proprietario='{}'", placa, modelo, proprietario);

        // Combina as especificações baseadas nos parâmetros não nulos/vazios
        Specification<Veiculo> spec = Specification.where(null); // Base neutra
        if (placa != null && !placa.isBlank()) {
            spec = spec.and(VeiculoSpecification.placaContains(placa));
        }
        if (modelo != null && !modelo.isBlank()) {
            spec = spec.and(VeiculoSpecification.modeloContains(modelo));
        }
        if (proprietario != null && !proprietario.isBlank()) {
            spec = spec.and(VeiculoSpecification.proprietarioContains(proprietario));
        }

        // Validação para evitar busca sem critério (se desejado)
        if ((placa == null || placa.isBlank()) && (modelo == null || modelo.isBlank()) && (proprietario == null || proprietario.isBlank())) {
            log.warn("Busca de veículos chamada sem critérios válidos.");
            return List.of(); // Retorna lista vazia
        }

        List<Veiculo> veiculosEncontrados = veiculoRepository.findAll(spec); // Usa findAll com Specification
        log.info("Encontrados {} veículos para os critéiros.", veiculosEncontrados.size());

        return veiculosEncontrados.stream()
                .map(veiculoMapper::toResponseDto)
                .collect(Collectors.toList());
    }
    // <<< FIM DA IMPLEMENTAÇÃO DA BUSCA >>>


    // --- Métodos CRUD e Auxiliar (como antes) ---
    @Override
    @Transactional(readOnly = true)
    public List<VeiculoResponseDto> findAll() {
        log.info("Buscando todos os veículos");
        return veiculoRepository.findAll().stream()
                .map(veiculoMapper::toResponseDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public VeiculoResponseDto findById(Long id) {
        log.info("Buscando veículo por ID: {}", id);
        Veiculo veiculo = findVeiculoById(id);
        return veiculoMapper.toResponseDto(veiculo);
    }

    @Override
    @Transactional
    public VeiculoResponseDto create(VeiculoRequestDto veiculoDto) {
        log.info("Criando novo veículo, placa: {}", veiculoDto.getPlaca());
        try {
            Veiculo veiculo = veiculoMapper.toEntity(veiculoDto);
            Veiculo savedVeiculo = veiculoRepository.save(veiculo);
            log.info("Veículo criado com ID: {}", savedVeiculo.getId());
            return veiculoMapper.toResponseDto(savedVeiculo);
        } catch (Exception e) {
            log.error("Erro ao criar veículo: {}", e.getMessage(), e);
            throw new RuntimeException("Falha ao criar veículo", e);
        }
    }

    @Override
    @Transactional
    public VeiculoResponseDto update(Long id, VeiculoRequestDto veiculoDto) {
        log.info("Atualizando veículo com ID: {}", id);
        Veiculo existingVeiculo = findVeiculoById(id);
        veiculoMapper.updateEntityFromDto(veiculoDto, existingVeiculo);
        Veiculo updatedVeiculo = veiculoRepository.save(existingVeiculo);
        log.info("Veículo atualizado com ID: {}", updatedVeiculo.getId());
        return veiculoMapper.toResponseDto(updatedVeiculo);
    }

    @Override
    @Transactional
    public void deleteById(Long id) {
        log.info("Deletando veículo com ID: {}", id);
        Veiculo veiculo = findVeiculoById(id); // Verifica existência
        try {
            veiculoRepository.delete(veiculo);
            log.info("Veículo deletado com ID: {}", id);
        } catch (Exception e) {
            log.error("Erro ao deletar veículo com ID {}: {}", id, e.getMessage(), e);
            throw new RuntimeException("Falha ao deletar veículo com ID: " + id, e);
        }
    }

    // --- Método auxiliar ---
    private Veiculo findVeiculoById(Long id) {
        return veiculoRepository.findById(id)
                .orElseThrow(() -> new VeiculoNotFoundException("Veículo não encontrado com ID: " + id));
    }
}

