// Script: converte-classes-java-em-txt-unico (v3)
// Data de criaÃ§Ã£o do arquivo de saÃ­da: 2025-05-12 15:58:34

// Estrutura de diretÃ³rios do projeto:
src/
    main/
        java/
            br/
                com/
                    fiap/
                        mottu/
                            config/
                            controller/
                            dto/
                                box/
                                cliente/
                                contato/
                                endereco/
                                patio/
                                rastreamento/
                                veiculo/
                                zona/
                            exception/
                                handler/
                            external/
                                outro/
                                viacep/
                            filter/
                            mapper/
                            model/
                                relacionamento/
                            repository/
                                relacionamento/
                            service/
                            specification/
        resources/
            static/
            templates/
    test/
        java/
            br/
                com/
                    fiap/
                        mottu/

// Arquivos encontrados (FQN => caminho relativo):
// br.com.fiap.mottu.MottuApplication => main\java\br\com\fiap\mottu\MottuApplication.java
// br.com.fiap.mottu.config.CorsConfig => main\java\br\com\fiap\mottu\config\CorsConfig.java
// br.com.fiap.mottu.config.OpenApiConfig => main\java\br\com\fiap\mottu\config\OpenApiConfig.java
// br.com.fiap.mottu.config.SwaggerBrowserLauncher => main\java\br\com\fiap\mottu\config\SwaggerBrowserLauncher.java
// br.com.fiap.mottu.controller.BoxController => main\java\br\com\fiap\mottu\controller\BoxController.java
// br.com.fiap.mottu.controller.ClienteController => main\java\br\com\fiap\mottu\controller\ClienteController.java
// br.com.fiap.mottu.controller.ContatoController => main\java\br\com\fiap\mottu\controller\ContatoController.java
// br.com.fiap.mottu.controller.EnderecoController => main\java\br\com\fiap\mottu\controller\EnderecoController.java
// br.com.fiap.mottu.controller.PatioController => main\java\br\com\fiap\mottu\controller\PatioController.java
// br.com.fiap.mottu.controller.RastreamentoController => main\java\br\com\fiap\mottu\controller\RastreamentoController.java
// br.com.fiap.mottu.controller.VeiculoController => main\java\br\com\fiap\mottu\controller\VeiculoController.java
// br.com.fiap.mottu.controller.ZonaController => main\java\br\com\fiap\mottu\controller\ZonaController.java
// br.com.fiap.mottu.dto.box.BoxRequestDto => main\java\br\com\fiap\mottu\dto\box\BoxRequestDto.java
// br.com.fiap.mottu.dto.box.BoxResponseDto => main\java\br\com\fiap\mottu\dto\box\BoxResponseDto.java
// br.com.fiap.mottu.dto.cliente.ClienteRequestDto => main\java\br\com\fiap\mottu\dto\cliente\ClienteRequestDto.java
// br.com.fiap.mottu.dto.cliente.ClienteResponseDto => main\java\br\com\fiap\mottu\dto\cliente\ClienteResponseDto.java
// br.com.fiap.mottu.dto.contato.ContatoRequestDto => main\java\br\com\fiap\mottu\dto\contato\ContatoRequestDto.java
// br.com.fiap.mottu.dto.contato.ContatoResponseDto => main\java\br\com\fiap\mottu\dto\contato\ContatoResponseDto.java
// br.com.fiap.mottu.dto.endereco.EnderecoRequestDto => main\java\br\com\fiap\mottu\dto\endereco\EnderecoRequestDto.java
// br.com.fiap.mottu.dto.endereco.EnderecoResponseDto => main\java\br\com\fiap\mottu\dto\endereco\EnderecoResponseDto.java
// br.com.fiap.mottu.dto.patio.PatioRequestDto => main\java\br\com\fiap\mottu\dto\patio\PatioRequestDto.java
// br.com.fiap.mottu.dto.patio.PatioResponseDto => main\java\br\com\fiap\mottu\dto\patio\PatioResponseDto.java
// br.com.fiap.mottu.dto.rastreamento.RastreamentoRequestDto => main\java\br\com\fiap\mottu\dto\rastreamento\RastreamentoRequestDto.java
// br.com.fiap.mottu.dto.rastreamento.RastreamentoResponseDto => main\java\br\com\fiap\mottu\dto\rastreamento\RastreamentoResponseDto.java
// br.com.fiap.mottu.dto.veiculo.VeiculoLocalizacaoResponseDto => main\java\br\com\fiap\mottu\dto\veiculo\VeiculoLocalizacaoResponseDto.java
// br.com.fiap.mottu.dto.veiculo.VeiculoRequestDto => main\java\br\com\fiap\mottu\dto\veiculo\VeiculoRequestDto.java
// br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto => main\java\br\com\fiap\mottu\dto\veiculo\VeiculoResponseDto.java
// br.com.fiap.mottu.dto.zona.ZonaRequestDto => main\java\br\com\fiap\mottu\dto\zona\ZonaRequestDto.java
// br.com.fiap.mottu.dto.zona.ZonaResponseDto => main\java\br\com\fiap\mottu\dto\zona\ZonaResponseDto.java
// br.com.fiap.mottu.exception.DuplicatedResourceException => main\java\br\com\fiap\mottu\exception\DuplicatedResourceException.java
// br.com.fiap.mottu.exception.InvalidInputException => main\java\br\com\fiap\mottu\exception\InvalidInputException.java
// br.com.fiap.mottu.exception.ResourceNotFoundException => main\java\br\com\fiap\mottu\exception\ResourceNotFoundException.java
// br.com.fiap.mottu.exception.handler.GlobalExceptionHandler => main\java\br\com\fiap\mottu\exception\handler\GlobalExceptionHandler.java
// br.com.fiap.mottu.external.viacep.ViaCepResponse => main\java\br\com\fiap\mottu\external\viacep\ViaCepResponse.java
// br.com.fiap.mottu.external.viacep.ViaCepService => main\java\br\com\fiap\mottu\external\viacep\ViaCepService.java
// br.com.fiap.mottu.filter.BoxFilter => main\java\br\com\fiap\mottu\filter\BoxFilter.java
// br.com.fiap.mottu.filter.ClienteFilter => main\java\br\com\fiap\mottu\filter\ClienteFilter.java
// br.com.fiap.mottu.filter.ContatoFilter => main\java\br\com\fiap\mottu\filter\ContatoFilter.java
// br.com.fiap.mottu.filter.EnderecoFilter => main\java\br\com\fiap\mottu\filter\EnderecoFilter.java
// br.com.fiap.mottu.filter.PatioFilter => main\java\br\com\fiap\mottu\filter\PatioFilter.java
// br.com.fiap.mottu.filter.RastreamentoFilter => main\java\br\com\fiap\mottu\filter\RastreamentoFilter.java
// br.com.fiap.mottu.filter.VeiculoFilter => main\java\br\com\fiap\mottu\filter\VeiculoFilter.java
// br.com.fiap.mottu.filter.ZonaFilter => main\java\br\com\fiap\mottu\filter\ZonaFilter.java
// br.com.fiap.mottu.mapper.BoxMapper => main\java\br\com\fiap\mottu\mapper\BoxMapper.java
// br.com.fiap.mottu.mapper.ClienteMapper => main\java\br\com\fiap\mottu\mapper\ClienteMapper.java
// br.com.fiap.mottu.mapper.ContatoMapper => main\java\br\com\fiap\mottu\mapper\ContatoMapper.java
// br.com.fiap.mottu.mapper.EnderecoMapper => main\java\br\com\fiap\mottu\mapper\EnderecoMapper.java
// br.com.fiap.mottu.mapper.PatioMapper => main\java\br\com\fiap\mottu\mapper\PatioMapper.java
// br.com.fiap.mottu.mapper.RastreamentoMapper => main\java\br\com\fiap\mottu\mapper\RastreamentoMapper.java
// br.com.fiap.mottu.mapper.VeiculoMapper => main\java\br\com\fiap\mottu\mapper\VeiculoMapper.java
// br.com.fiap.mottu.mapper.ZonaMapper => main\java\br\com\fiap\mottu\mapper\ZonaMapper.java
// br.com.fiap.mottu.model.Box => main\java\br\com\fiap\mottu\model\Box.java
// br.com.fiap.mottu.model.Cliente => main\java\br\com\fiap\mottu\model\Cliente.java
// br.com.fiap.mottu.model.Contato => main\java\br\com\fiap\mottu\model\Contato.java
// br.com.fiap.mottu.model.Endereco => main\java\br\com\fiap\mottu\model\Endereco.java
// br.com.fiap.mottu.model.Patio => main\java\br\com\fiap\mottu\model\Patio.java
// br.com.fiap.mottu.model.Rastreamento => main\java\br\com\fiap\mottu\model\Rastreamento.java
// br.com.fiap.mottu.model.Veiculo => main\java\br\com\fiap\mottu\model\Veiculo.java
// br.com.fiap.mottu.model.Zona => main\java\br\com\fiap\mottu\model\Zona.java
// br.com.fiap.mottu.model.relacionamento.ClienteVeiculo => main\java\br\com\fiap\mottu\model\relacionamento\ClienteVeiculo.java
// br.com.fiap.mottu.model.relacionamento.ClienteVeiculoId => main\java\br\com\fiap\mottu\model\relacionamento\ClienteVeiculoId.java
// br.com.fiap.mottu.model.relacionamento.ContatoPatio => main\java\br\com\fiap\mottu\model\relacionamento\ContatoPatio.java
// br.com.fiap.mottu.model.relacionamento.ContatoPatioId => main\java\br\com\fiap\mottu\model\relacionamento\ContatoPatioId.java
// br.com.fiap.mottu.model.relacionamento.EnderecoPatio => main\java\br\com\fiap\mottu\model\relacionamento\EnderecoPatio.java
// br.com.fiap.mottu.model.relacionamento.EnderecoPatioId => main\java\br\com\fiap\mottu\model\relacionamento\EnderecoPatioId.java
// br.com.fiap.mottu.model.relacionamento.PatioBox => main\java\br\com\fiap\mottu\model\relacionamento\PatioBox.java
// br.com.fiap.mottu.model.relacionamento.PatioBoxId => main\java\br\com\fiap\mottu\model\relacionamento\PatioBoxId.java
// br.com.fiap.mottu.model.relacionamento.VeiculoBox => main\java\br\com\fiap\mottu\model\relacionamento\VeiculoBox.java
// br.com.fiap.mottu.model.relacionamento.VeiculoBoxId => main\java\br\com\fiap\mottu\model\relacionamento\VeiculoBoxId.java
// br.com.fiap.mottu.model.relacionamento.VeiculoPatio => main\java\br\com\fiap\mottu\model\relacionamento\VeiculoPatio.java
// br.com.fiap.mottu.model.relacionamento.VeiculoPatioId => main\java\br\com\fiap\mottu\model\relacionamento\VeiculoPatioId.java
// br.com.fiap.mottu.model.relacionamento.VeiculoRastreamento => main\java\br\com\fiap\mottu\model\relacionamento\VeiculoRastreamento.java
// br.com.fiap.mottu.model.relacionamento.VeiculoRastreamentoId => main\java\br\com\fiap\mottu\model\relacionamento\VeiculoRastreamentoId.java
// br.com.fiap.mottu.model.relacionamento.VeiculoZona => main\java\br\com\fiap\mottu\model\relacionamento\VeiculoZona.java
// br.com.fiap.mottu.model.relacionamento.VeiculoZonaId => main\java\br\com\fiap\mottu\model\relacionamento\VeiculoZonaId.java
// br.com.fiap.mottu.model.relacionamento.ZonaBox => main\java\br\com\fiap\mottu\model\relacionamento\ZonaBox.java
// br.com.fiap.mottu.model.relacionamento.ZonaBoxId => main\java\br\com\fiap\mottu\model\relacionamento\ZonaBoxId.java
// br.com.fiap.mottu.model.relacionamento.ZonaPatio => main\java\br\com\fiap\mottu\model\relacionamento\ZonaPatio.java
// br.com.fiap.mottu.model.relacionamento.ZonaPatioId => main\java\br\com\fiap\mottu\model\relacionamento\ZonaPatioId.java
// br.com.fiap.mottu.repository.BoxRepository => main\java\br\com\fiap\mottu\repository\BoxRepository.java
// br.com.fiap.mottu.repository.ClienteRepository => main\java\br\com\fiap\mottu\repository\ClienteRepository.java
// br.com.fiap.mottu.repository.ContatoRepository => main\java\br\com\fiap\mottu\repository\ContatoRepository.java
// br.com.fiap.mottu.repository.EnderecoRepository => main\java\br\com\fiap\mottu\repository\EnderecoRepository.java
// br.com.fiap.mottu.repository.PatioRepository => main\java\br\com\fiap\mottu\repository\PatioRepository.java
// br.com.fiap.mottu.repository.RastreamentoRepository => main\java\br\com\fiap\mottu\repository\RastreamentoRepository.java
// br.com.fiap.mottu.repository.VeiculoRepository => main\java\br\com\fiap\mottu\repository\VeiculoRepository.java
// br.com.fiap.mottu.repository.ZonaRepository => main\java\br\com\fiap\mottu\repository\ZonaRepository.java
// br.com.fiap.mottu.repository.relacionamento.ClienteVeiculoRepository => main\java\br\com\fiap\mottu\repository\relacionamento\ClienteVeiculoRepository.java
// br.com.fiap.mottu.repository.relacionamento.ContatoPatioRepository => main\java\br\com\fiap\mottu\repository\relacionamento\ContatoPatioRepository.java
// br.com.fiap.mottu.repository.relacionamento.EnderecoPatioRepository => main\java\br\com\fiap\mottu\repository\relacionamento\EnderecoPatioRepository.java
// br.com.fiap.mottu.repository.relacionamento.PatioBoxRepository => main\java\br\com\fiap\mottu\repository\relacionamento\PatioBoxRepository.java
// br.com.fiap.mottu.repository.relacionamento.VeiculoBoxRepository => main\java\br\com\fiap\mottu\repository\relacionamento\VeiculoBoxRepository.java
// br.com.fiap.mottu.repository.relacionamento.VeiculoPatioRepository => main\java\br\com\fiap\mottu\repository\relacionamento\VeiculoPatioRepository.java
// br.com.fiap.mottu.repository.relacionamento.VeiculoRastreamentoRepository => main\java\br\com\fiap\mottu\repository\relacionamento\VeiculoRastreamentoRepository.java
// br.com.fiap.mottu.repository.relacionamento.VeiculoZonaRepository => main\java\br\com\fiap\mottu\repository\relacionamento\VeiculoZonaRepository.java
// br.com.fiap.mottu.repository.relacionamento.ZonaBoxRepository => main\java\br\com\fiap\mottu\repository\relacionamento\ZonaBoxRepository.java
// br.com.fiap.mottu.repository.relacionamento.ZonaPatioRepository => main\java\br\com\fiap\mottu\repository\relacionamento\ZonaPatioRepository.java
// br.com.fiap.mottu.service.BoxService => main\java\br\com\fiap\mottu\service\BoxService.java
// br.com.fiap.mottu.service.ClienteService => main\java\br\com\fiap\mottu\service\ClienteService.java
// br.com.fiap.mottu.service.ContatoService => main\java\br\com\fiap\mottu\service\ContatoService.java
// br.com.fiap.mottu.service.EnderecoService => main\java\br\com\fiap\mottu\service\EnderecoService.java
// br.com.fiap.mottu.service.PatioService => main\java\br\com\fiap\mottu\service\PatioService.java
// br.com.fiap.mottu.service.RastreamentoService => main\java\br\com\fiap\mottu\service\RastreamentoService.java
// br.com.fiap.mottu.service.VeiculoService => main\java\br\com\fiap\mottu\service\VeiculoService.java
// br.com.fiap.mottu.service.ZonaService => main\java\br\com\fiap\mottu\service\ZonaService.java
// br.com.fiap.mottu.specification.BoxSpecification => main\java\br\com\fiap\mottu\specification\BoxSpecification.java
// br.com.fiap.mottu.specification.ClienteSpecification => main\java\br\com\fiap\mottu\specification\ClienteSpecification.java
// br.com.fiap.mottu.specification.ContatoSpecification => main\java\br\com\fiap\mottu\specification\ContatoSpecification.java
// br.com.fiap.mottu.specification.EnderecoSpecification => main\java\br\com\fiap\mottu\specification\EnderecoSpecification.java
// br.com.fiap.mottu.specification.PatioSpecification => main\java\br\com\fiap\mottu\specification\PatioSpecification.java
// br.com.fiap.mottu.specification.RastreamentoSpecification => main\java\br\com\fiap\mottu\specification\RastreamentoSpecification.java
// br.com.fiap.mottu.specification.VeiculoSpecification => main\java\br\com\fiap\mottu\specification\VeiculoSpecification.java
// br.com.fiap.mottu.specification.ZonaSpecification => main\java\br\com\fiap\mottu\specification\ZonaSpecification.java
// br.com.fiap.mottu.MottuApplicationTests => test\java\br\com\fiap\mottu\MottuApplicationTests.java

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\MottuApplication.java   |   package br.com.fiap.mottu   |   class MottuApplication
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu; // Este Ã© o pacote correto

// import io.swagger.v3.oas.annotations.OpenAPIDefinition;
// import io.swagger.v3.oas.annotations.info.Info;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.web.client.RestTemplate; // <-- Importar RestTemplate
import org.springframework.web.reactive.function.client.WebClient; // <-- Adicione esta importaÃ§Ã£o AQUI!


@EnableJpaRepositories
@SpringBootApplication
@EnableCaching
// @OpenAPIDefinition(info = @Info(title="CHALLENGE-2025-FIAP-TEMMU-METAMIND SOLUTIONS-1.0", description = "CHALLENGE FIAP 2025", version = "v1"))
public class MottuApplication {

	public static void main(String[] args) {
		SpringApplication.run(MottuApplication.class, args);
	}

	@Bean
	public RestTemplate restTemplate(){
		return new RestTemplate();
	}

	// Adicionado para suportar WebClient no EnderecoService
	@Bean // <-- Adicione este Bean AQUI!
	public WebClient.Builder webClientBuilder() {
		return WebClient.builder();
	}
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\config\CorsConfig.java   |   package br.com.fiap.mottu.config   |   class CorsConfig
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class CorsConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("*")
                .allowedMethods("GET", "POST", "DELETE", "PUT")
                .allowedHeaders("*");
    }

}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\config\OpenApiConfig.java   |   package br.com.fiap.mottu.config   |   class OpenApiConfig
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.servers.Server; // ImportaÃ§Ã£o necessÃ¡ria para a classe Server
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.List; // ImportaÃ§Ã£o necessÃ¡ria para List

/**
 * Classe de configuraÃ§Ã£o do Springdoc OpenAPI para definir as informaÃ§Ãµes detalhadas da API.
 * Isso inclui tÃ­tulo, versÃ£o, descriÃ§Ã£o completa com Markdown, informaÃ§Ãµes de contato da equipe
 * e detalhes de licenÃ§a, que serÃ£o exibidos na interface do Swagger UI.
 */
@Configuration
public class OpenApiConfig {

    private static final Logger log = LoggerFactory.getLogger(OpenApiConfig.class);

    @Bean
    public OpenAPI customOpenAPI() {
        log.info("ðŸ”§ ConfiguraÃ§Ã£o personalizada do OpenAPI inicializada com dados completos.");

        return new OpenAPI()
                .info(new Info()
                        .title("Challenge-2025-FIAP-TEMMU-METAMIND SOLUTIONS") // TÃ­tulo completo do seu projeto
                        .version("1.0") // VersÃ£o do seu projeto
                        .description("""
                                **CHALLENGE FIAP 2025**

                                API RESTful para o Challenge Mottu - GestÃ£o de Clientes, VeÃ­culos, EndereÃ§os, Contatos e mais.

                                **EndereÃ§o do Projeto GitHub:** [GitHub - Mottu](https://github.com/carmipa/challenge_2025_1_semestre_mottu)

                                **Turma:** 2TDSPV / 2TDSPZ

                                **Contatos da Equipe:**
                                - Arthur Bispo de Lima RM557568: [RM557568@fiap.com.br](mailto:RM557568@fiap.com.br) | [GitHub](https://github.com/ArthurBispo00)
                                - JoÃ£o Paulo Moreira RM557808: [RM557808@fiap.com.br](mailto:RM557808@fiap.com.br) | [GitHub](https://github.com/joao1015)
                                - Paulo AndrÃ© Carminati RM557881: [RM557881@fiap.com.br](mailto:RM557881@fiap.com.br) | [GitHub](https://github.com/carmipa)
                                """)
                        .contact(new Contact()
                                .name("Metamind Solution") // Nome da equipe
                                .email("RM557568@fiap.com.br") // E-mail de contato da equipe
                                .url("https://github.com/carmipa/challenge_2025_1_semestre_mottu") // URL do projeto ou da equipe
                        )
                        .license(new License()
                                .name("LicenÃ§a de Uso") // Nome da licenÃ§a
                                .url("https://github.com/carmipa/challenge_2025_1_semestre_mottu/tree/main/Java_Advanced") // URL da licenÃ§a
                        )
                )
                // Adicione a seÃ§Ã£o de servidores se desejar, como vocÃª tinha no seu cÃ³digo anterior
                .servers(List.of(new Server().url("http://localhost:8080").description("Servidor Local")));
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\config\SwaggerBrowserLauncher.java   |   package br.com.fiap.mottu.config   |   class SwaggerBrowserLauncher
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.config;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

import java.awt.Desktop;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;

@Component
public class SwaggerBrowserLauncher {

    private static final Logger log = LoggerFactory.getLogger(SwaggerBrowserLauncher.class);

    @Value("${server.port:8080}")
    private String serverPort;

    @Value("${server.servlet.context-path:}")
    private String contextPath;

    @Value("${springdoc.swagger-ui.path:/swagger-ui/index.html}")
    private String swaggerUiPath;

    @Value("${app.launch-swagger-on-startup:true}")
    private boolean launchSwaggerOnStartup;

    @EventListener(ApplicationReadyEvent.class)
    public void launchBrowserOnStartup() {
        if (!launchSwaggerOnStartup) {
            log.info("Abertura automÃ¡tica do Swagger no navegador estÃ¡ desabilitada.");
            return;
        }

        String url = "http://localhost:" + serverPort + contextPath + swaggerUiPath;
        log.info("Tentando abrir o Swagger UI em: {}", url);

        if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {
            try {
                Desktop.getDesktop().browse(new URI(url));
                log.info("Navegador aberto com sucesso na URL do Swagger UI.");
            } catch (IOException | URISyntaxException e) {
                log.error("Erro ao tentar abrir o navegador para o Swagger UI: {}", e.getMessage());
            }
        } else {
            log.warn("Abertura automÃ¡tica do navegador nÃ£o Ã© suportada neste ambiente. Acesse manualmente: {}", url);
        }
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\controller\BoxController.java   |   package br.com.fiap.mottu.controller   |   class BoxController
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.box.BoxRequestDto;
import br.com.fiap.mottu.dto.box.BoxResponseDto;
import br.com.fiap.mottu.filter.BoxFilter;
import br.com.fiap.mottu.service.BoxService;
import br.com.fiap.mottu.mapper.BoxMapper;
import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/boxes")
@Tag(name = "Boxes", description = "Gerenciamento de Boxes")
public class BoxController {

    private static final Logger log = LoggerFactory.getLogger(BoxController.class);
    private final BoxService boxService;
    private final BoxMapper boxMapper;

    @Autowired
    public BoxController(BoxService boxService, BoxMapper boxMapper) {
        this.boxService = boxService;
        this.boxMapper = boxMapper;
    }

    @Operation(
            summary = "Listar todos os boxes",
            description = "Retorna uma lista de todos os boxes cadastrados.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de boxes retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = BoxResponseDto.class)))
            }
    )
    @GetMapping
    public ResponseEntity<List<BoxResponseDto>> listarTodosBoxes() {
        log.info("Buscando todos os boxes.");
        List<BoxResponseDto> boxes = boxService.listarTodosBoxes().stream()
                .map(boxMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} boxes.", boxes.size());
        return ResponseEntity.ok(boxes);
    }

    @Operation(
            summary = "Buscar box por ID",
            description = "Retorna um box especÃ­fico com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Box encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = BoxResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Box nÃ£o encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"Box com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/boxes/1\"}")))
            }
    )
    @GetMapping("/{id}")
    public ResponseEntity<BoxResponseDto> buscarBoxPorId(@PathVariable Long id) {
        log.info("Buscando box com ID: {}", id);
        try {
            BoxResponseDto box = boxMapper.toResponseDto(boxService.buscarBoxPorId(id));
            log.info("Box com ID {} encontrado com sucesso.", id);
            return ResponseEntity.ok(box);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar box com ID {}: {}", id, e.getMessage());
            throw e; // O GlobalExceptionHandler cuidarÃ¡ da resposta HTTP
        }
    }

    @Operation(
            summary = "Buscar boxes por filtro",
            description = "Retorna uma lista de boxes que correspondem aos critÃ©rios de filtro fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de boxes filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = BoxResponseDto.class)))
            }
    )
    @GetMapping("/search")
    public ResponseEntity<List<BoxResponseDto>> buscarBoxesPorFiltro(BoxFilter filter) {
        log.info("Buscando boxes com filtro: {}", filter);
        List<BoxResponseDto> boxes = boxService.buscarBoxesPorFiltro(filter).stream()
                .map(boxMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} boxes filtrados.", boxes.size());
        return ResponseEntity.ok(boxes);
    }

    @Operation(
            summary = "Criar novo box",
            description = "Cria um novo box com os dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Box criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = BoxResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada invÃ¡lidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"RequisiÃ§Ã£o InvÃ¡lida\",\"message\":\"Mensagem de validaÃ§Ã£o ou erro de input.\",\"path\":\"/api/boxes\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (nome duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Box com nome 'Nome Duplicado' jÃ¡ existe.\",\"path\":\"/api/boxes\"}")))
            }
    )
    @PostMapping
    public ResponseEntity<BoxResponseDto> criarBox(@Valid @RequestBody BoxRequestDto boxRequestDto) {
        log.info("Recebida requisiÃ§Ã£o para criar box: {}", boxRequestDto);
        try {
            BoxResponseDto novoBox = boxMapper.toResponseDto(boxService.criarBox(boxRequestDto));
            log.info("Box criado com sucesso com ID: {}", novoBox.getIdBox());
            return ResponseEntity.status(HttpStatus.CREATED).body(novoBox);
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao criar box - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao criar box: {}", e.getMessage(), e);
            throw e; // O GlobalExceptionHandler pode pegar outras exceÃ§Ãµes inesperadas
        }
    }

    @Operation(
            summary = "Atualizar box existente",
            description = "Atualiza um box existente com base no ID e nos dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Box atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = BoxResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada invÃ¡lidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"RequisiÃ§Ã£o InvÃ¡lida\",\"message\":\"Mensagem de validaÃ§Ã£o ou erro de input.\",\"path\":\"/api/boxes/1\"}"))),
                    @ApiResponse(responseCode = "404", description = "Box nÃ£o encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"Box com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/boxes/1\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (nome duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Box com nome 'Nome Duplicado' jÃ¡ existe.\",\"path\":\"/api/boxes/1\"}")))
            }
    )
    @PutMapping("/{id}")
    public ResponseEntity<BoxResponseDto> atualizarBox(@PathVariable Long id, @Valid @RequestBody BoxRequestDto boxRequestDto) {
        log.info("Recebida requisiÃ§Ã£o para atualizar box com ID {}: {}", id, boxRequestDto);
        try {
            BoxResponseDto boxAtualizado = boxMapper.toResponseDto(boxService.atualizarBox(id, boxRequestDto));
            log.info("Box com ID {} atualizado com sucesso.", id);
            return ResponseEntity.ok(boxAtualizado);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao atualizar box - NÃ£o encontrado: {}", e.getMessage());
            throw e;
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao atualizar box - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao atualizar box com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Deletar box",
            description = "Exclui um box com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Box deletado com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Box nÃ£o encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"Box com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/boxes/1\"}")))
            }
    )
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarBox(@PathVariable Long id) {
        log.info("Recebida requisiÃ§Ã£o para deletar box com ID: {}", id);
        try {
            boxService.deletarBox(id);
            log.info("Box com ID {} deletado com sucesso.", id);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao deletar box - NÃ£o encontrado: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao deletar box com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\controller\ClienteController.java   |   package br.com.fiap.mottu.controller   |   class ClienteController
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.cliente.ClienteRequestDto;
import br.com.fiap.mottu.dto.cliente.ClienteResponseDto;
import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.mottu.filter.ClienteFilter;
import br.com.fiap.mottu.service.ClienteService;
import br.com.fiap.mottu.mapper.ClienteMapper;
import br.com.fiap.mottu.mapper.VeiculoMapper; // Adicione o VeiculoMapper
import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;
import br.com.fiap.mottu.exception.InvalidInputException;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;
import reactor.core.publisher.Mono; // Importe Mono

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/clientes")
@Tag(name = "Clientes", description = "Gerenciamento de Clientes")
public class ClienteController {

    private static final Logger log = LoggerFactory.getLogger(ClienteController.class);
    private final ClienteService clienteService;
    private final ClienteMapper clienteMapper;
    private final VeiculoMapper veiculoMapper; // Injetar VeiculoMapper

    @Autowired
    public ClienteController(ClienteService clienteService, ClienteMapper clienteMapper, VeiculoMapper veiculoMapper) {
        this.clienteService = clienteService;
        this.clienteMapper = clienteMapper;
        this.veiculoMapper = veiculoMapper;
    }

    @Operation(
            summary = "Listar todos os clientes",
            description = "Retorna uma lista de todos os clientes cadastrados.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de clientes retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ClienteResponseDto.class)))
            }
    )
    @GetMapping
    public ResponseEntity<List<ClienteResponseDto>> listarTodosClientes() {
        log.info("Buscando todos os clientes.");
        List<ClienteResponseDto> clientes = clienteService.listarTodosClientes().stream()
                .map(clienteMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} clientes.", clientes.size());
        return ResponseEntity.ok(clientes);
    }

    @Operation(
            summary = "Buscar cliente por ID",
            description = "Retorna um cliente especÃ­fico com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Cliente encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ClienteResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Cliente nÃ£o encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"Cliente com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/clientes/1\"}")))
            }
    )
    @GetMapping("/{id}")
    public ResponseEntity<ClienteResponseDto> buscarClientePorId(@PathVariable Long id) {
        log.info("Buscando cliente com ID: {}", id);
        try {
            ClienteResponseDto cliente = clienteMapper.toResponseDto(clienteService.buscarClientePorId(id));
            log.info("Cliente com ID {} encontrado com sucesso.", id);
            return ResponseEntity.ok(cliente);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar cliente com ID {}: {}", id, e.getMessage());
            throw e;
        }
    }

    @Operation(
            summary = "Buscar clientes por filtro",
            description = "Retorna uma lista de clientes que correspondem aos critÃ©rios de filtro fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de clientes filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ClienteResponseDto.class)))
            }
    )
    @GetMapping("/search")
    public ResponseEntity<List<ClienteResponseDto>> buscarClientesPorFiltro(ClienteFilter filter) {
        log.info("Buscando clientes com filtro: {}", filter);
        List<ClienteResponseDto> clientes = clienteService.buscarClientesPorFiltro(filter).stream()
                .map(clienteMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} clientes filtrados.", clientes.size());
        return ResponseEntity.ok(clientes);
    }

    @Operation(
            summary = "Criar novo cliente",
            description = "Cria um novo cliente com os dados fornecidos, incluindo endereÃ§o e contato. Pode criar novos ou associar existentes.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Cliente criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ClienteResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada invÃ¡lidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"RequisiÃ§Ã£o InvÃ¡lida\",\"message\":\"Mensagem de validaÃ§Ã£o ou erro de input.\",\"path\":\"/api/clientes\"}"))),
                    @ApiResponse(responseCode = "404", description = "Recurso aninhado nÃ£o encontrado (Ex: EndereÃ§o/Contato com ID fornecido nÃ£o existe)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"EndereÃ§o com ID 100 nÃ£o encontrado(a).\",\"path\":\"/api/clientes\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (CPF duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Cliente com CPF '12345678901' jÃ¡ existe.\",\"path\":\"/api/clientes\"}")))
            }
    )
    @PostMapping
    public Mono<ResponseEntity<ClienteResponseDto>> criarCliente(@Valid @RequestBody ClienteRequestDto clienteRequestDto) {
        log.info("Recebida requisiÃ§Ã£o para criar cliente: {}", clienteRequestDto);
        return clienteService.criarCliente(clienteRequestDto)
                .map(clienteCriado -> {
                    log.info("Cliente criado com sucesso com ID: {}", clienteCriado.getIdCliente());
                    return ResponseEntity.status(HttpStatus.CREATED).body(clienteMapper.toResponseDto(clienteCriado));
                })
                .onErrorResume(ResourceNotFoundException.class, e -> {
                    log.error("Erro ao criar cliente - Recurso aninhado nÃ£o encontrado: {}", e.getMessage());
                    return Mono.error(e);
                })
                .onErrorResume(DuplicatedResourceException.class, e -> {
                    log.error("Erro ao criar cliente - Conflito: {}", e.getMessage());
                    return Mono.error(e);
                })
                .onErrorResume(InvalidInputException.class, e -> {
                    log.error("Erro ao criar cliente - RequisiÃ§Ã£o invÃ¡lida: {}", e.getMessage());
                    return Mono.error(e);
                })
                .onErrorResume(e -> {
                    log.error("Erro inesperado ao criar cliente: {}", e.getMessage(), e);
                    return Mono.error(e);
                });
    }

    @Operation(
            summary = "Atualizar cliente existente",
            description = "Atualiza um cliente existente com base no ID e nos dados fornecidos. Permite atualizar endereÃ§o e contato.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Cliente atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ClienteResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada invÃ¡lidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"RequisiÃ§Ã£o InvÃ¡lida\",\"message\":\"Mensagem de validaÃ§Ã£o ou erro de input.\",\"path\":\"/api/clientes/1\"}"))),
                    @ApiResponse(responseCode = "404", description = "Cliente ou recurso aninhado nÃ£o encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"Cliente com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/clientes/1\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (CPF duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Cliente com CPF '12345678901' jÃ¡ existe.\",\"path\":\"/api/clientes/1\"}")))
            }
    )
    @PutMapping("/{id}")
    public Mono<ResponseEntity<ClienteResponseDto>> atualizarCliente(@PathVariable Long id, @Valid @RequestBody ClienteRequestDto clienteRequestDto) {
        log.info("Recebida requisiÃ§Ã£o para atualizar cliente com ID {}: {}", id, clienteRequestDto);
        return clienteService.atualizarCliente(id, clienteRequestDto)
                .map(clienteAtualizado -> {
                    log.info("Cliente com ID {} atualizado com sucesso.", id);
                    return ResponseEntity.ok(clienteMapper.toResponseDto(clienteAtualizado));
                })
                .onErrorResume(ResourceNotFoundException.class, e -> {
                    log.error("Erro ao atualizar cliente - NÃ£o encontrado: {}", e.getMessage());
                    return Mono.error(e);
                })
                .onErrorResume(DuplicatedResourceException.class, e -> {
                    log.error("Erro ao atualizar cliente - Conflito: {}", e.getMessage());
                    return Mono.error(e);
                })
                .onErrorResume(InvalidInputException.class, e -> {
                    log.error("Erro ao atualizar cliente - RequisiÃ§Ã£o invÃ¡lida: {}", e.getMessage());
                    return Mono.error(e);
                })
                .onErrorResume(e -> {
                    log.error("Erro inesperado ao atualizar cliente com ID {}: {}", id, e.getMessage(), e);
                    return Mono.error(e);
                });
    }

    @Operation(
            summary = "Deletar cliente",
            description = "Exclui um cliente com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Cliente deletado com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Cliente nÃ£o encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"Cliente com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/clientes/1\"}")))
            }
    )
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarCliente(@PathVariable Long id) {
        log.info("Recebida requisiÃ§Ã£o para deletar cliente com ID: {}", id);
        try {
            clienteService.deletarCliente(id);
            log.info("Cliente com ID {} deletado com sucesso.", id);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao deletar cliente - NÃ£o encontrado: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao deletar cliente com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Associar veÃ­culo a um cliente",
            description = "Associa um veÃ­culo existente a um cliente existente.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "AssociaÃ§Ã£o criada com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Cliente ou VeÃ­culo nÃ£o encontrado"),
                    @ApiResponse(responseCode = "409", description = "AssociaÃ§Ã£o jÃ¡ existe")
            }
    )
    @PostMapping("/{clienteId}/enderecos/{enderecoId}/contatos/{contatoId}/veiculos/{veiculoId}/associar")
    public ResponseEntity<String> associarClienteVeiculo(
            @PathVariable Long clienteId,
            @PathVariable Long enderecoId,
            @PathVariable Long contatoId,
            @PathVariable Long veiculoId) {
        log.info("Associando veÃ­culo ID {} ao cliente ID {} (Endereco: {}, Contato: {}).", veiculoId, clienteId, enderecoId, contatoId);
        try {
            clienteService.associarClienteVeiculo(clienteId, enderecoId, contatoId, veiculoId);
            log.info("AssociaÃ§Ã£o entre Cliente {} e VeÃ­culo {} (End: {}, Cont: {}) criada com sucesso.", clienteId, veiculoId, enderecoId, contatoId);
            return ResponseEntity.status(HttpStatus.CREATED).body("AssociaÃ§Ã£o criada com sucesso.");
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao associar - Recurso nÃ£o encontrado: {}", e.getMessage());
            throw e;
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao associar - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao associar Cliente {} e VeÃ­culo {}: {}", clienteId, veiculoId, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Desassociar veÃ­culo de um cliente",
            description = "Remove a associaÃ§Ã£o entre um veÃ­culo e um cliente.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "AssociaÃ§Ã£o removida com sucesso"),
                    @ApiResponse(responseCode = "404", description = "AssociaÃ§Ã£o nÃ£o encontrada")
            }
    )
    @DeleteMapping("/{clienteId}/enderecos/{enderecoId}/contatos/{contatoId}/veiculos/{veiculoId}/desassociar")
    public ResponseEntity<Void> desassociarClienteVeiculo(
            @PathVariable Long clienteId,
            @PathVariable Long enderecoId,
            @PathVariable Long contatoId,
            @PathVariable Long veiculoId) {
        log.info("Desassociando veÃ­culo ID {} do cliente ID {} (Endereco: {}, Contato: {}).", veiculoId, clienteId, enderecoId, contatoId);
        try {
            clienteService.desassociarClienteVeiculo(clienteId, enderecoId, contatoId, veiculoId);
            log.info("AssociaÃ§Ã£o entre Cliente {} e VeÃ­culo {} (End: {}, Cont: {}) removida com sucesso.", clienteId, veiculoId, enderecoId, contatoId);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao desassociar - AssociaÃ§Ã£o nÃ£o encontrada: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao desassociar Cliente {} e VeÃ­culo {}: {}", clienteId, veiculoId, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Listar veÃ­culos de um cliente",
            description = "Retorna todos os veÃ­culos associados a um cliente especÃ­fico.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "VeÃ­culos do cliente retornados com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Cliente nÃ£o encontrado")
            }
    )
    @GetMapping("/{clienteId}/veiculos")
    public ResponseEntity<Set<VeiculoResponseDto>> getVeiculosByClienteId(@PathVariable Long clienteId) {
        log.info("Buscando veÃ­culos associados ao cliente com ID: {}", clienteId);
        try {
            Set<VeiculoResponseDto> veiculos = clienteService.getVeiculosByClienteId(clienteId).stream()
                    .map(veiculoMapper::toResponseDto)
                    .collect(Collectors.toSet());
            log.info("Retornando {} veÃ­culos para o cliente com ID {}.", veiculos.size(), clienteId);
            return ResponseEntity.ok(veiculos);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar veÃ­culos do cliente com ID {}: {}", clienteId, e.getMessage());
            throw e;
        }
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\controller\ContatoController.java   |   package br.com.fiap.mottu.controller   |   class ContatoController
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.contato.ContatoRequestDto;
import br.com.fiap.mottu.dto.contato.ContatoResponseDto;
import br.com.fiap.mottu.filter.ContatoFilter;
import br.com.fiap.mottu.service.ContatoService;
import br.com.fiap.mottu.mapper.ContatoMapper;
import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/contatos")
@Tag(name = "Contatos", description = "Gerenciamento de Contatos")
public class ContatoController {

    private static final Logger log = LoggerFactory.getLogger(ContatoController.class);
    private final ContatoService contatoService;
    private final ContatoMapper contatoMapper;

    @Autowired
    public ContatoController(ContatoService contatoService, ContatoMapper contatoMapper) {
        this.contatoService = contatoService;
        this.contatoMapper = contatoMapper;
    }

    @Operation(
            summary = "Listar todos os contatos",
            description = "Retorna uma lista de todos os contatos cadastrados.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de contatos retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ContatoResponseDto.class)))
            }
    )
    @GetMapping
    public ResponseEntity<List<ContatoResponseDto>> listarTodosContatos() {
        log.info("Buscando todos os contatos.");
        List<ContatoResponseDto> contatos = contatoService.listarTodosContatos().stream()
                .map(contatoMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} contatos.", contatos.size());
        return ResponseEntity.ok(contatos);
    }

    @Operation(
            summary = "Buscar contato por ID",
            description = "Retorna um contato especÃ­fico com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Contato encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ContatoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Contato nÃ£o encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"Contato com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/contatos/1\"}")))
            }
    )
    @GetMapping("/{id}")
    public ResponseEntity<ContatoResponseDto> buscarContatoPorId(@PathVariable Long id) {
        log.info("Buscando contato com ID: {}", id);
        try {
            ContatoResponseDto contato = contatoMapper.toResponseDto(contatoService.buscarContatoPorId(id));
            log.info("Contato com ID {} encontrado com sucesso.", id);
            return ResponseEntity.ok(contato);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar contato com ID {}: {}", id, e.getMessage());
            throw e;
        }
    }

    @Operation(
            summary = "Buscar contatos por filtro",
            description = "Retorna uma lista de contatos que correspondem aos critÃ©rios de filtro fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de contatos filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ContatoResponseDto.class)))
            }
    )
    @GetMapping("/search")
    public ResponseEntity<List<ContatoResponseDto>> buscarContatosPorFiltro(ContatoFilter filter) {
        log.info("Buscando contatos com filtro: {}", filter);
        List<ContatoResponseDto> contatos = contatoService.buscarContatosPorFiltro(filter).stream()
                .map(contatoMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} contatos filtrados.", contatos.size());
        return ResponseEntity.ok(contatos);
    }

    @Operation(
            summary = "Criar novo contato",
            description = "Cria um novo contato com os dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Contato criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ContatoResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada invÃ¡lidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"RequisiÃ§Ã£o InvÃ¡lida\",\"message\":\"Mensagem de validaÃ§Ã£o ou erro de input.\",\"path\":\"/api/contatos\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (email duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Contato com email 'email@duplicado.com' jÃ¡ existe.\",\"path\":\"/api/contatos\"}")))
            }
    )
    @PostMapping
    public ResponseEntity<ContatoResponseDto> criarContato(@Valid @RequestBody ContatoRequestDto contatoRequestDto) {
        log.info("Recebida requisiÃ§Ã£o para criar contato: {}", contatoRequestDto);
        try {
            ContatoResponseDto novoContato = contatoMapper.toResponseDto(contatoService.criarContato(contatoRequestDto));
            log.info("Contato criado com sucesso com ID: {}", novoContato.getIdContato());
            return ResponseEntity.status(HttpStatus.CREATED).body(novoContato);
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao criar contato - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao criar contato: {}", e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Atualizar contato existente",
            description = "Atualiza um contato existente com base no ID e nos dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Contato atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ContatoResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada invÃ¡lidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"RequisiÃ§Ã£o InvÃ¡lida\",\"message\":\"Mensagem de validaÃ§Ã£o ou erro de input.\",\"path\":\"/api/contatos/1\"}"))),
                    @ApiResponse(responseCode = "404", description = "Contato nÃ£o encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"Contato com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/contatos/1\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (email duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Contato com email 'email@duplicado.com' jÃ¡ existe.\",\"path\":\"/api/contatos/1\"}")))
            }
    )
    @PutMapping("/{id}")
    public ResponseEntity<ContatoResponseDto> atualizarContato(@PathVariable Long id, @Valid @RequestBody ContatoRequestDto contatoRequestDto) {
        log.info("Recebida requisiÃ§Ã£o para atualizar contato com ID {}: {}", id, contatoRequestDto);
        try {
            ContatoResponseDto contatoAtualizado = contatoMapper.toResponseDto(contatoService.atualizarContato(id, contatoRequestDto));
            log.info("Contato com ID {} atualizado com sucesso.", id);
            return ResponseEntity.ok(contatoAtualizado);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao atualizar contato - NÃ£o encontrado: {}", e.getMessage());
            throw e;
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao atualizar contato - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao atualizar contato com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Deletar contato",
            description = "Exclui um contato com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Contato deletado com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Contato nÃ£o encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"Contato com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/contatos/1\"}")))
            }
    )
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarContato(@PathVariable Long id) {
        log.info("Recebida requisiÃ§Ã£o para deletar contato com ID: {}", id);
        try {
            contatoService.deletarContato(id);
            log.info("Contato com ID {} deletado com sucesso.", id);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao deletar contato - NÃ£o encontrado: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao deletar contato com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\controller\EnderecoController.java   |   package br.com.fiap.mottu.controller   |   class EnderecoController
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.endereco.EnderecoRequestDto;
import br.com.fiap.mottu.dto.endereco.EnderecoResponseDto;
import br.com.fiap.mottu.filter.EnderecoFilter;
import br.com.fiap.mottu.service.EnderecoService;
import br.com.fiap.mottu.mapper.EnderecoMapper;
import br.com.fiap.mottu.exception.ResourceNotFoundException;
import br.com.fiap.mottu.exception.InvalidInputException;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;
import reactor.core.publisher.Mono; // Importe Mono

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/enderecos")
@Tag(name = "Enderecos", description = "Gerenciamento de EndereÃ§os")
public class EnderecoController {

    private static final Logger log = LoggerFactory.getLogger(EnderecoController.class);
    private final EnderecoService enderecoService;
    private final EnderecoMapper enderecoMapper;

    @Autowired
    public EnderecoController(EnderecoService enderecoService, EnderecoMapper enderecoMapper) {
        this.enderecoService = enderecoService;
        this.enderecoMapper = enderecoMapper;
    }

    @Operation(
            summary = "Listar todos os endereÃ§os",
            description = "Retorna uma lista de todos os endereÃ§os cadastrados.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de endereÃ§os retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = EnderecoResponseDto.class)))
            }
    )
    @GetMapping
    public ResponseEntity<List<EnderecoResponseDto>> listarTodosEnderecos() {
        log.info("Buscando todos os endereÃ§os.");
        List<EnderecoResponseDto> enderecos = enderecoService.listarTodosEnderecos().stream()
                .map(enderecoMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} endereÃ§os.", enderecos.size());
        return ResponseEntity.ok(enderecos);
    }

    @Operation(
            summary = "Buscar endereÃ§o por ID",
            description = "Retorna um endereÃ§o especÃ­fico com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "EndereÃ§o encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = EnderecoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "EndereÃ§o nÃ£o encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"EndereÃ§o com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/enderecos/1\"}")))
            }
    )
    @GetMapping("/{id}")
    public ResponseEntity<EnderecoResponseDto> buscarEnderecoPorId(@PathVariable Long id) {
        log.info("Buscando endereÃ§o com ID: {}", id);
        try {
            EnderecoResponseDto endereco = enderecoMapper.toResponseDto(enderecoService.buscarEnderecoPorId(id));
            log.info("EndereÃ§o com ID {} encontrado com sucesso.", id);
            return ResponseEntity.ok(endereco);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar endereÃ§o com ID {}: {}", id, e.getMessage());
            throw e;
        }
    }

    @Operation(
            summary = "Buscar endereÃ§os por filtro",
            description = "Retorna uma lista de endereÃ§os que correspondem aos critÃ©rios de filtro fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de endereÃ§os filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = EnderecoResponseDto.class)))
            }
    )
    @GetMapping("/search")
    public ResponseEntity<List<EnderecoResponseDto>> buscarEnderecosPorFiltro(EnderecoFilter filter) {
        log.info("Buscando endereÃ§os com filtro: {}", filter);
        List<EnderecoResponseDto> enderecos = enderecoService.listarTodosEnderecos().stream() // EnderecoService nÃ£o tem buscarEnderecosPorFiltro
                .map(enderecoMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} endereÃ§os filtrados.", enderecos.size());
        return ResponseEntity.ok(enderecos);
    }

    @Operation(
            summary = "Criar novo endereÃ§o",
            description = "Cria um novo endereÃ§o com os dados fornecidos, buscando informaÃ§Ãµes de CEP na ViaCEP.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "EndereÃ§o criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = EnderecoResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada invÃ¡lidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"RequisiÃ§Ã£o InvÃ¡lida\",\"message\":\"Mensagem de validaÃ§Ã£o ou erro de input.\",\"path\":\"/api/enderecos\"}"))),
                    @ApiResponse(responseCode = "404", description = "CEP nÃ£o encontrado na ViaCEP",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"CEP com cep '12345-678' nÃ£o encontrado(a).\",\"path\":\"/api/enderecos\"}")))
            }
    )
    @PostMapping
    public Mono<ResponseEntity<EnderecoResponseDto>> criarEndereco(@Valid @RequestBody EnderecoRequestDto enderecoRequestDto) {
        log.info("Recebida requisiÃ§Ã£o para criar endereÃ§o: {}", enderecoRequestDto);
        return enderecoService.criarEndereco(enderecoRequestDto)
                .map(enderecoCriado -> {
                    log.info("EndereÃ§o criado com sucesso com ID: {}", enderecoCriado.getIdEndereco());
                    return ResponseEntity.status(HttpStatus.CREATED).body(enderecoMapper.toResponseDto(enderecoCriado));
                })
                .onErrorResume(ResourceNotFoundException.class, e -> {
                    log.error("Erro ao criar endereÃ§o - CEP nÃ£o encontrado: {}", e.getMessage());
                    return Mono.error(e);
                })
                .onErrorResume(InvalidInputException.class, e -> {
                    log.error("Erro ao criar endereÃ§o - RequisiÃ§Ã£o invÃ¡lida: {}", e.getMessage());
                    return Mono.error(e);
                })
                .onErrorResume(e -> {
                    log.error("Erro inesperado ao criar endereÃ§o: {}", e.getMessage(), e);
                    return Mono.error(e);
                });
    }

    @Operation(
            summary = "Atualizar endereÃ§o existente",
            description = "Atualiza um endereÃ§o existente com base no ID e nos dados fornecidos. Pode buscar informaÃ§Ãµes de CEP na ViaCEP se o CEP for alterado.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "EndereÃ§o atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = EnderecoResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada invÃ¡lidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"RequisiÃ§Ã£o InvÃ¡lida\",\"message\":\"Mensagem de validaÃ§Ã£o ou erro de input.\",\"path\":\"/api/enderecos/1\"}"))),
                    @ApiResponse(responseCode = "404", description = "EndereÃ§o nÃ£o encontrado ou CEP de atualizaÃ§Ã£o nÃ£o encontrado na ViaCEP",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"EndereÃ§o com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/enderecos/1\"}")))
            }
    )
    @PutMapping("/{id}")
    public Mono<ResponseEntity<EnderecoResponseDto>> atualizarEndereco(@PathVariable Long id, @Valid @RequestBody EnderecoRequestDto enderecoRequestDto) {
        log.info("Recebida requisiÃ§Ã£o para atualizar endereÃ§o com ID {}: {}", id, enderecoRequestDto);
        return enderecoService.atualizarEndereco(id, enderecoRequestDto)
                .map(enderecoAtualizado -> {
                    log.info("EndereÃ§o com ID {} atualizado com sucesso.", id);
                    return ResponseEntity.ok(enderecoMapper.toResponseDto(enderecoAtualizado));
                })
                .onErrorResume(ResourceNotFoundException.class, e -> {
                    log.error("Erro ao atualizar endereÃ§o - NÃ£o encontrado: {}", e.getMessage());
                    return Mono.error(e);
                })
                .onErrorResume(InvalidInputException.class, e -> {
                    log.error("Erro ao atualizar endereÃ§o - RequisiÃ§Ã£o invÃ¡lida: {}", e.getMessage());
                    return Mono.error(e);
                })
                .onErrorResume(e -> {
                    log.error("Erro inesperado ao atualizar endereÃ§o com ID {}: {}", id, e.getMessage(), e);
                    return Mono.error(e);
                });
    }

    @Operation(
            summary = "Deletar endereÃ§o",
            description = "Exclui um endereÃ§o com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "EndereÃ§o deletado com sucesso"),
                    @ApiResponse(responseCode = "404", description = "EndereÃ§o nÃ£o encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"EndereÃ§o com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/enderecos/1\"}")))
            }
    )
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarEndereco(@PathVariable Long id) {
        log.info("Recebida requisiÃ§Ã£o para deletar endereÃ§o com ID: {}", id);
        try {
            enderecoService.deletarEndereco(id);
            log.info("EndereÃ§o com ID {} deletado com sucesso.", id);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao deletar endereÃ§o - NÃ£o encontrado: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao deletar endereÃ§o com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\controller\PatioController.java   |   package br.com.fiap.mottu.controller   |   class PatioController
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.patio.PatioRequestDto;
import br.com.fiap.mottu.dto.patio.PatioResponseDto;
import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto; // Para listar veÃ­culos associados
import br.com.fiap.mottu.dto.zona.ZonaResponseDto;       // Para listar zonas associadas
import br.com.fiap.mottu.dto.box.BoxResponseDto;    // NOVO: Para listar boxes associados
import br.com.fiap.mottu.dto.contato.ContatoResponseDto; // Para listar contatos associados
import br.com.fiap.mottu.dto.endereco.EnderecoResponseDto; // Para listar endereÃ§os associados

import br.com.fiap.mottu.filter.PatioFilter;
import br.com.fiap.mottu.service.PatioService;
import br.com.fiap.mottu.mapper.PatioMapper;
import br.com.fiap.mottu.mapper.VeiculoMapper; // Injetar para mapear Veiculo
import br.com.fiap.mottu.mapper.ZonaMapper;    // Injetar para mapear Zona
import br.com.fiap.mottu.mapper.BoxMapper;           // NOVO: Injetar para mapear Box
import br.com.fiap.mottu.mapper.ContatoMapper;  // Injetar para mapear Contato
import br.com.fiap.mottu.mapper.EnderecoMapper; // Injetar para mapear Endereco

import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/patios")
@Tag(name = "Patios", description = "Gerenciamento de PÃ¡tios e Suas AssociaÃ§Ãµes")
public class PatioController {

    private static final Logger log = LoggerFactory.getLogger(PatioController.class);
    private final PatioService patioService;
    private final PatioMapper patioMapper;
    private final VeiculoMapper veiculoMapper;
    private final ZonaMapper zonaMapper;
    private final BoxMapper boxMapper;           // NOVO
    private final ContatoMapper contatoMapper;
    private final EnderecoMapper enderecoMapper;

    @Autowired
    public PatioController(PatioService patioService, PatioMapper patioMapper,
                           VeiculoMapper veiculoMapper, ZonaMapper zonaMapper,
                           ContatoMapper contatoMapper, EnderecoMapper enderecoMapper,
                           BoxMapper boxMapper) { // NOVO: Adicione BoxMapper aqui
        this.patioService = patioService;
        this.patioMapper = patioMapper;
        this.veiculoMapper = veiculoMapper;
        this.zonaMapper = zonaMapper;
        this.contatoMapper = contatoMapper;
        this.enderecoMapper = enderecoMapper;
        this.boxMapper = boxMapper;
    }

    @Operation(
            summary = "Listar todos os pÃ¡tios",
            description = "Retorna uma lista de todos os pÃ¡tios cadastrados.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de pÃ¡tios retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = PatioResponseDto.class)))
            }
    )
    @GetMapping
    public ResponseEntity<List<PatioResponseDto>> listarTodosPatios() {
        log.info("Buscando todos os pÃ¡tios.");
        List<PatioResponseDto> patios = patioService.listarTodosPatios().stream()
                .map(patioMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} pÃ¡tios.", patios.size());
        return ResponseEntity.ok(patios);
    }

    @Operation(
            summary = "Buscar pÃ¡tio por ID",
            description = "Retorna um pÃ¡tio especÃ­fico com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "PÃ¡tio encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = PatioResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "PÃ¡tio nÃ£o encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"PÃ¡tio com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/patios/1\"}")))
            }
    )
    @GetMapping("/{id}")
    public ResponseEntity<PatioResponseDto> buscarPatioPorId(@PathVariable Long id) {
        log.info("Buscando pÃ¡tio com ID: {}", id);
        try {
            PatioResponseDto patio = patioMapper.toResponseDto(patioService.buscarPatioPorId(id));
            log.info("PÃ¡tio com ID {} encontrado com sucesso.", id);
            return ResponseEntity.ok(patio);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar pÃ¡tio com ID {}: {}", id, e.getMessage());
            throw e;
        }
    }

    @Operation(
            summary = "Buscar pÃ¡tios por filtro",
            description = "Retorna uma lista de pÃ¡tios que correspondem aos critÃ©rios de filtro fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de pÃ¡tios filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = PatioResponseDto.class)))
            }
    )
    @GetMapping("/search")
    public ResponseEntity<List<PatioResponseDto>> buscarPatiosPorFiltro(PatioFilter filter) {
        log.info("Buscando pÃ¡tios com filtro: {}", filter);
        List<PatioResponseDto> patios = patioService.buscarPatiosPorFiltro(filter).stream()
                .map(patioMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} pÃ¡tios filtrados.", patios.size());
        return ResponseEntity.ok(patios);
    }

    @Operation(
            summary = "Criar novo pÃ¡tio",
            description = "Cria um novo pÃ¡tio com os dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "PÃ¡tio criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = PatioResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada invÃ¡lidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"RequisiÃ§Ã£o InvÃ¡lida\",\"message\":\"Mensagem de validaÃ§Ã£o ou erro de input.\",\"path\":\"/api/patios\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (nome duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"PÃ¡tio com nome 'Nome Duplicado' jÃ¡ existe.\",\"path\":\"/api/patios\"}")))
            }
    )
    @PostMapping
    public ResponseEntity<PatioResponseDto> criarPatio(@Valid @RequestBody PatioRequestDto patioRequestDto) {
        log.info("Recebida requisiÃ§Ã£o para criar pÃ¡tio: {}", patioRequestDto);
        try {
            PatioResponseDto novoPatio = patioMapper.toResponseDto(patioService.criarPatio(patioRequestDto));
            log.info("PÃ¡tio criado com sucesso com ID: {}", novoPatio.getIdPatio());
            return ResponseEntity.status(HttpStatus.CREATED).body(novoPatio);
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao criar pÃ¡tio - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao criar pÃ¡tio: {}", e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Atualizar pÃ¡tio existente",
            description = "Atualiza um pÃ¡tio existente com base no ID e nos dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "PÃ¡tio atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = PatioResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada invÃ¡lidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"RequisiÃ§Ã£o InvÃ¡lida\",\"message\":\"Mensagem de validaÃ§Ã£o ou erro de input.\",\"path\":\"/api/patios/1\"}"))),
                    @ApiResponse(responseCode = "404", description = "PÃ¡tio nÃ£o encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"PÃ¡tio com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/patios/1\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (nome duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"PÃ¡tio com nome 'Nome Duplicado' jÃ¡ existe.\",\"path\":\"/api/patios/1\"}")))
            }
    )
    @PutMapping("/{id}")
    public ResponseEntity<PatioResponseDto> atualizarPatio(@PathVariable Long id, @Valid @RequestBody PatioRequestDto patioRequestDto) {
        log.info("Recebida requisiÃ§Ã£o para atualizar pÃ¡tio com ID {}: {}", id, patioRequestDto);
        try {
            PatioResponseDto patioAtualizado = patioMapper.toResponseDto(patioService.atualizarPatio(id, patioRequestDto));
            log.info("PÃ¡tio com ID {} atualizado com sucesso.", id);
            return ResponseEntity.ok(patioAtualizado);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao atualizar pÃ¡tio - NÃ£o encontrado: {}", e.getMessage());
            throw e;
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao atualizar pÃ¡tio - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao atualizar pÃ¡tio com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Deletar pÃ¡tio",
            description = "Exclui um pÃ¡tio com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "PÃ¡tio deletado com sucesso"),
                    @ApiResponse(responseCode = "404", description = "PÃ¡tio nÃ£o encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"PÃ¡tio com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/patios/1\"}")))
            }
    )
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarPatio(@PathVariable Long id) {
        log.info("Recebida requisiÃ§Ã£o para deletar pÃ¡tio com ID: {}", id);
        try {
            patioService.deletarPatio(id);
            log.info("PÃ¡tio com ID {} deletado com sucesso.", id);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao deletar pÃ¡tio - NÃ£o encontrado: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao deletar pÃ¡tio com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }

    // --- Endpoints de AssociaÃ§Ã£o de VeÃ­culos com PÃ¡tio ---
    @Operation(
            summary = "Associar veÃ­culo a um pÃ¡tio",
            description = "Associa um veÃ­culo existente a um pÃ¡tio existente.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "AssociaÃ§Ã£o criada com sucesso"),
                    @ApiResponse(responseCode = "404", description = "PÃ¡tio ou VeÃ­culo nÃ£o encontrado"),
                    @ApiResponse(responseCode = "409", description = "AssociaÃ§Ã£o jÃ¡ existe")
            }
    )
    @PostMapping("/{patioId}/veiculos/{veiculoId}/associar")
    public ResponseEntity<String> associarPatioVeiculo(
            @PathVariable Long patioId,
            @PathVariable Long veiculoId) {
        log.info("Associando veÃ­culo ID {} ao pÃ¡tio ID {}.", veiculoId, patioId);
        try {
            patioService.associarPatioVeiculo(patioId, veiculoId);
            log.info("AssociaÃ§Ã£o entre PÃ¡tio {} e VeÃ­culo {} criada com sucesso.", patioId, veiculoId);
            return ResponseEntity.status(HttpStatus.CREATED).body("AssociaÃ§Ã£o criada com sucesso.");
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao associar - Recurso nÃ£o encontrado: {}", e.getMessage());
            throw e;
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao associar - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao associar PÃ¡tio {} e VeÃ­culo {}: {}", patioId, veiculoId, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Desassociar veÃ­culo de um pÃ¡tio",
            description = "Remove a associaÃ§Ã£o entre um veÃ­culo e um pÃ¡tio.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "AssociaÃ§Ã£o removida com sucesso"),
                    @ApiResponse(responseCode = "404", description = "AssociaÃ§Ã£o nÃ£o encontrada")
            }
    )
    @DeleteMapping("/{patioId}/veiculos/{veiculoId}/desassociar")
    public ResponseEntity<Void> desassociarPatioVeiculo(
            @PathVariable Long patioId,
            @PathVariable Long veiculoId) {
        log.info("Desassociando veÃ­culo ID {} do pÃ¡tio ID {}.", veiculoId, patioId);
        try {
            patioService.desassociarPatioVeiculo(patioId, veiculoId);
            log.info("AssociaÃ§Ã£o entre PÃ¡tio {} e VeÃ­culo {} removida com sucesso.", patioId, veiculoId);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao desassociar - AssociaÃ§Ã£o nÃ£o encontrada: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao desassociar PÃ¡tio {} e VeÃ­culo {}: {}", patioId, veiculoId, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Listar veÃ­culos de um pÃ¡tio",
            description = "Retorna todos os veÃ­culos associados a um pÃ¡tio especÃ­fico.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "VeÃ­culos do pÃ¡tio retornados com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "PÃ¡tio nÃ£o encontrado")
            }
    )
    @GetMapping("/{patioId}/veiculos")
    public ResponseEntity<Set<VeiculoResponseDto>> getVeiculosByPatioId(@PathVariable Long patioId) {
        log.info("Buscando veÃ­culos associados ao pÃ¡tio com ID: {}", patioId);
        try {
            Set<VeiculoResponseDto> veiculos = patioService.getVeiculosByPatioId(patioId).stream()
                    .map(veiculoMapper::toResponseDto)
                    .collect(Collectors.toSet());
            log.info("Retornando {} veÃ­culos para o pÃ¡tio com ID {}.", veiculos.size(), patioId);
            return ResponseEntity.ok(veiculos);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar veÃ­culos do pÃ¡tio com ID {}: {}", patioId, e.getMessage());
            throw e;
        }
    }


    // --- Endpoints de AssociaÃ§Ã£o de Zonas com PÃ¡tio ---
    @Operation(
            summary = "Associar zona a um pÃ¡tio",
            description = "Associa uma zona existente a um pÃ¡tio existente.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "AssociaÃ§Ã£o criada com sucesso"),
                    @ApiResponse(responseCode = "404", description = "PÃ¡tio ou Zona nÃ£o encontrada"),
                    @ApiResponse(responseCode = "409", description = "AssociaÃ§Ã£o jÃ¡ existe")
            }
    )
    @PostMapping("/{patioId}/zonas/{zonaId}/associar")
    public ResponseEntity<String> associarPatioZona(
            @PathVariable Long patioId,
            @PathVariable Long zonaId) {
        log.info("Associando zona ID {} ao pÃ¡tio ID {}.", zonaId, patioId);
        try {
            patioService.associarPatioZona(patioId, zonaId);
            log.info("AssociaÃ§Ã£o entre PÃ¡tio {} e Zona {} criada com sucesso.", patioId, zonaId);
            return ResponseEntity.status(HttpStatus.CREATED).body("AssociaÃ§Ã£o criada com sucesso.");
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao associar - Recurso nÃ£o encontrado: {}", e.getMessage());
            throw e;
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao associar - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao associar PÃ¡tio {} e Zona {}: {}", patioId, zonaId, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Desassociar zona de um pÃ¡tio",
            description = "Remove a associaÃ§Ã£o entre uma zona e um pÃ¡tio.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "AssociaÃ§Ã£o removida com sucesso"),
                    @ApiResponse(responseCode = "404", description = "AssociaÃ§Ã£o nÃ£o encontrada")
            }
    )
    @DeleteMapping("/{patioId}/zonas/{zonaId}/desassociar")
    public ResponseEntity<Void> desassociarPatioZona(
            @PathVariable Long patioId,
            @PathVariable Long zonaId) {
        log.info("Desassociando zona ID {} do pÃ¡tio ID {}.", zonaId, patioId);
        try {
            patioService.desassociarPatioZona(patioId, zonaId);
            log.info("AssociaÃ§Ã£o entre PÃ¡tio {} e Zona {} removida com sucesso.", patioId, zonaId);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao desassociar - AssociaÃ§Ã£o nÃ£o encontrada: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao desassociar PÃ¡tio {} e Zona {}: {}", patioId, zonaId, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Listar zonas de um pÃ¡tio",
            description = "Retorna todas as zonas associadas a um pÃ¡tio especÃ­fico.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Zonas do pÃ¡tio retornadas com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ZonaResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "PÃ¡tio nÃ£o encontrado")
            }
    )
    @GetMapping("/{patioId}/zonas")
    public ResponseEntity<Set<ZonaResponseDto>> getZonasByPatioId(@PathVariable Long patioId) {
        log.info("Buscando zonas associadas ao pÃ¡tio com ID: {}", patioId);
        try {
            Set<ZonaResponseDto> zonas = patioService.getZonasByPatioId(patioId).stream()
                    .map(zonaMapper::toResponseDto)
                    .collect(Collectors.toSet());
            log.info("Retornando {} zonas para o pÃ¡tio com ID {}.", zonas.size(), patioId);
            return ResponseEntity.ok(zonas);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar zonas do pÃ¡tio com ID {}: {}", patioId, e.getMessage());
            throw e;
        }
    }

    // --- Endpoints de AssociaÃ§Ã£o de Contatos com PÃ¡tio ---
    @Operation(
            summary = "Associar contato a um pÃ¡tio",
            description = "Associa um contato existente a um pÃ¡tio existente.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "AssociaÃ§Ã£o criada com sucesso"),
                    @ApiResponse(responseCode = "404", description = "PÃ¡tio ou Contato nÃ£o encontrado"),
                    @ApiResponse(responseCode = "409", description = "AssociaÃ§Ã£o jÃ¡ existe")
            }
    )
    @PostMapping("/{patioId}/contatos/{contatoId}/associar")
    public ResponseEntity<String> associarPatioContato(
            @PathVariable Long patioId,
            @PathVariable Long contatoId) {
        log.info("Associando contato ID {} ao pÃ¡tio ID {}.", contatoId, patioId);
        try {
            patioService.associarPatioContato(patioId, contatoId);
            log.info("AssociaÃ§Ã£o entre PÃ¡tio {} e Contato {} criada com sucesso.", patioId, contatoId);
            return ResponseEntity.status(HttpStatus.CREATED).body("AssociaÃ§Ã£o criada com sucesso.");
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao associar - Recurso nÃ£o encontrado: {}", e.getMessage());
            throw e;
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao associar - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao associar PÃ¡tio {} e Contato {}: {}", patioId, contatoId, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Desassociar contato de um pÃ¡tio",
            description = "Remove a associaÃ§Ã£o entre um contato e um pÃ¡tio.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "AssociaÃ§Ã£o removida com sucesso"),
                    @ApiResponse(responseCode = "404", description = "AssociaÃ§Ã£o nÃ£o encontrada")
            }
    )
    @DeleteMapping("/{patioId}/contatos/{contatoId}/desassociar")
    public ResponseEntity<Void> desassociarPatioContato(
            @PathVariable Long patioId,
            @PathVariable Long contatoId) {
        log.info("Desassociando contato ID {} do pÃ¡tio ID {}.", contatoId, patioId);
        try {
            patioService.desassociarPatioContato(patioId, contatoId);
            log.info("AssociaÃ§Ã£o entre PÃ¡tio {} e Contato {} removida com sucesso.", patioId, contatoId);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao desassociar - AssociaÃ§Ã£o nÃ£o encontrada: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao desassociar PÃ¡tio {} e Contato {}: {}", patioId, contatoId, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Listar contatos de um pÃ¡tio",
            description = "Retorna todos os contatos associados a um pÃ¡tio especÃ­fico.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Contatos do pÃ¡tio retornados com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ContatoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "PÃ¡tio nÃ£o encontrado")
            }
    )
    @GetMapping("/{patioId}/contatos")
    public ResponseEntity<Set<ContatoResponseDto>> getContatosByPatioId(@PathVariable Long patioId) {
        log.info("Buscando contatos associados ao pÃ¡tio com ID: {}", patioId);
        try {
            Set<ContatoResponseDto> contatos = patioService.getContatosByPatioId(patioId).stream()
                    .map(contatoMapper::toResponseDto)
                    .collect(Collectors.toSet());
            log.info("Retornando {} contatos para o pÃ¡tio com ID {}.", contatos.size(), patioId);
            return ResponseEntity.ok(contatos);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar contatos do pÃ¡tio com ID {}: {}", patioId, e.getMessage());
            throw e;
        }
    }

    // --- Endpoints de AssociaÃ§Ã£o de EndereÃ§os com PÃ¡tio ---
    @Operation(
            summary = "Associar endereÃ§o a um pÃ¡tio",
            description = "Associa um endereÃ§o existente a um pÃ¡tio existente.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "AssociaÃ§Ã£o criada com sucesso"),
                    @ApiResponse(responseCode = "404", description = "PÃ¡tio ou EndereÃ§o nÃ£o encontrado"),
                    @ApiResponse(responseCode = "409", description = "AssociaÃ§Ã£o jÃ¡ existe")
            }
    )
    @PostMapping("/{patioId}/enderecos/{enderecoId}/associar")
    public ResponseEntity<String> associarPatioEndereco(
            @PathVariable Long patioId,
            @PathVariable Long enderecoId) {
        log.info("Associando endereÃ§o ID {} ao pÃ¡tio ID {}.", enderecoId, patioId);
        try {
            patioService.associarPatioEndereco(patioId, enderecoId);
            log.info("AssociaÃ§Ã£o entre PÃ¡tio {} e EndereÃ§o {} criada com sucesso.", patioId, enderecoId);
            return ResponseEntity.status(HttpStatus.CREATED).body("AssociaÃ§Ã£o criada com sucesso.");
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao associar - Recurso nÃ£o encontrado: {}", e.getMessage());
            throw e;
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao associar - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao associar PÃ¡tio {} e EndereÃ§o {}: {}", patioId, enderecoId, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Desassociar endereÃ§o de um pÃ¡tio",
            description = "Remove a associaÃ§Ã£o entre um endereÃ§o e um pÃ¡tio.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "AssociaÃ§Ã£o removida com sucesso"),
                    @ApiResponse(responseCode = "404", description = "AssociaÃ§Ã£o nÃ£o encontrada")
            }
    )
    @DeleteMapping("/{patioId}/enderecos/{enderecoId}/desassociar")
    public ResponseEntity<Void> desassociarPatioEndereco(
            @PathVariable Long patioId,
            @PathVariable Long enderecoId) {
        log.info("Desassociando endereÃ§o ID {} do pÃ¡tio ID {}.", enderecoId, patioId);
        try {
            patioService.desassociarPatioEndereco(patioId, enderecoId);
            log.info("AssociaÃ§Ã£o entre PÃ¡tio {} e EndereÃ§o {} removida com sucesso.", patioId, enderecoId);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao desassociar - AssociaÃ§Ã£o nÃ£o encontrada: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao desassociar PÃ¡tio {} e EndereÃ§o {}: {}", patioId, enderecoId, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Listar endereÃ§os de um pÃ¡tio",
            description = "Retorna todos os endereÃ§os associados a um pÃ¡tio especÃ­fico.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "EndereÃ§os do pÃ¡tio retornados com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = EnderecoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "PÃ¡tio nÃ£o encontrado")
            }
    )
    @GetMapping("/{patioId}/enderecos")
    public ResponseEntity<Set<EnderecoResponseDto>> getEnderecosByPatioId(@PathVariable Long patioId) {
        log.info("Buscando endereÃ§os associados ao pÃ¡tio com ID: {}", patioId);
        try {
            Set<EnderecoResponseDto> enderecos = patioService.getEnderecosByPatioId(patioId).stream()
                    .map(enderecoMapper::toResponseDto)
                    .collect(Collectors.toSet());
            log.info("Retornando {} endereÃ§os para o pÃ¡tio com ID {}.", enderecos.size(), patioId);
            return ResponseEntity.ok(enderecos);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar endereÃ§os do pÃ¡tio com ID {}: {}", patioId, e.getMessage());
            throw e;
        }
    }

    // --- Endpoints de AssociaÃ§Ã£o de Boxes com PÃ¡tio (NOVO) ---
    @Operation(
            summary = "Associar box a um pÃ¡tio",
            description = "Associa um box existente a um pÃ¡tio existente.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "AssociaÃ§Ã£o criada com sucesso"),
                    @ApiResponse(responseCode = "404", description = "PÃ¡tio ou Box nÃ£o encontrado"),
                    @ApiResponse(responseCode = "409", description = "AssociaÃ§Ã£o jÃ¡ existe")
            }
    )
    @PostMapping("/{patioId}/boxes/{boxId}/associar")
    public ResponseEntity<String> associarPatioBox(
            @PathVariable Long patioId,
            @PathVariable Long boxId) {
        log.info("Associando box ID {} ao pÃ¡tio ID {}.", boxId, patioId);
        try {
            patioService.associarPatioBox(patioId, boxId);
            log.info("AssociaÃ§Ã£o entre PÃ¡tio {} e Box {} criada com sucesso.", patioId, boxId);
            return ResponseEntity.status(HttpStatus.CREATED).body("AssociaÃ§Ã£o criada com sucesso.");
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao associar - Recurso nÃ£o encontrado: {}", e.getMessage());
            throw e;
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao associar - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao associar PÃ¡tio {} e Box {}: {}", patioId, boxId, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Desassociar box de um pÃ¡tio",
            description = "Remove a associaÃ§Ã£o entre um box e um pÃ¡tio.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "AssociaÃ§Ã£o removida com sucesso"),
                    @ApiResponse(responseCode = "404", description = "AssociaÃ§Ã£o nÃ£o encontrada")
            }
    )
    @DeleteMapping("/{patioId}/boxes/{boxId}/desassociar")
    public ResponseEntity<Void> desassociarPatioBox(
            @PathVariable Long patioId,
            @PathVariable Long boxId) {
        log.info("Desassociando box ID {} do pÃ¡tio ID {}.", boxId, patioId);
        try {
            patioService.desassociarPatioBox(patioId, boxId);
            log.info("AssociaÃ§Ã£o entre PÃ¡tio {} e Box {} removida com sucesso.", patioId, boxId);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao desassociar - AssociaÃ§Ã£o nÃ£o encontrada: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao desassociar PÃ¡tio {} e Box {}: {}", patioId, boxId, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Listar boxes de um pÃ¡tio",
            description = "Retorna todos os boxes associados a um pÃ¡tio especÃ­fico.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Boxes do pÃ¡tio retornados com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = BoxResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "PÃ¡tio nÃ£o encontrado")
            }
    )
    @GetMapping("/{patioId}/boxes")
    public ResponseEntity<Set<BoxResponseDto>> getBoxesByPatioId(@PathVariable Long patioId) {
        log.info("Buscando boxes associados ao pÃ¡tio com ID: {}", patioId);
        try {
            Set<BoxResponseDto> boxes = patioService.getBoxesByPatioId(patioId).stream()
                    .map(boxMapper::toResponseDto)
                    .collect(Collectors.toSet());
            log.info("Retornando {} boxes para o pÃ¡tio com ID {}.", boxes.size(), patioId);
            return ResponseEntity.ok(boxes);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar boxes do pÃ¡tio com ID {}: {}", patioId, e.getMessage());
            throw e;
        }
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\controller\RastreamentoController.java   |   package br.com.fiap.mottu.controller   |   class RastreamentoController
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.rastreamento.RastreamentoRequestDto;
import br.com.fiap.mottu.dto.rastreamento.RastreamentoResponseDto;
import br.com.fiap.mottu.filter.RastreamentoFilter;
import br.com.fiap.mottu.service.RastreamentoService;
import br.com.fiap.mottu.mapper.RastreamentoMapper;
import br.com.fiap.mottu.exception.ResourceNotFoundException;
import br.com.fiap.mottu.exception.InvalidInputException;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/rastreamentos")
@Tag(name = "Rastreamentos", description = "Gerenciamento de Rastreamentos")
public class RastreamentoController {

    private static final Logger log = LoggerFactory.getLogger(RastreamentoController.class);
    private final RastreamentoService rastreamentoService;
    private final RastreamentoMapper rastreamentoMapper;

    @Autowired
    public RastreamentoController(RastreamentoService rastreamentoService, RastreamentoMapper rastreamentoMapper) {
        this.rastreamentoService = rastreamentoService;
        this.rastreamentoMapper = rastreamentoMapper;
    }

    @Operation(
            summary = "Listar todos os rastreamentos",
            description = "Retorna uma lista de todos os rastreamentos cadastrados.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de rastreamentos retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = RastreamentoResponseDto.class)))
            }
    )
    @GetMapping
    public ResponseEntity<List<RastreamentoResponseDto>> listarTodosRastreamentos() {
        log.info("Buscando todos os rastreamentos.");
        List<RastreamentoResponseDto> rastreamentos = rastreamentoService.listarTodosRastreamentos().stream()
                .map(rastreamentoMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} rastreamentos.", rastreamentos.size());
        return ResponseEntity.ok(rastreamentos);
    }

    @Operation(
            summary = "Buscar rastreamento por ID",
            description = "Retorna um rastreamento especÃ­fico com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Rastreamento encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = RastreamentoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Rastreamento nÃ£o encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"Rastreamento com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/rastreamentos/1\"}")))
            }
    )
    @GetMapping("/{id}")
    public ResponseEntity<RastreamentoResponseDto> buscarRastreamentoPorId(@PathVariable Long id) {
        log.info("Buscando rastreamento com ID: {}", id);
        try {
            RastreamentoResponseDto rastreamento = rastreamentoMapper.toResponseDto(rastreamentoService.buscarRastreamentoPorId(id));
            log.info("Rastreamento com ID {} encontrado com sucesso.", id);
            return ResponseEntity.ok(rastreamento);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar rastreamento com ID {}: {}", id, e.getMessage());
            throw e;
        }
    }

    @Operation(
            summary = "Buscar rastreamentos por filtro",
            description = "Retorna uma lista de rastreamentos que correspondem aos critÃ©rios de filtro fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de rastreamentos filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = RastreamentoResponseDto.class)))
            }
    )
    @GetMapping("/search")
    public ResponseEntity<List<RastreamentoResponseDto>> buscarRastreamentosPorFiltro(RastreamentoFilter filter) {
        log.info("Buscando rastreamentos com filtro: {}", filter);
        List<RastreamentoResponseDto> rastreamentos = rastreamentoService.buscarRastreamentosPorFiltro(filter).stream()
                .map(rastreamentoMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} rastreamentos filtrados.", rastreamentos.size());
        return ResponseEntity.ok(rastreamentos);
    }

    @Operation(
            summary = "Criar novo rastreamento",
            description = "Cria um novo rastreamento com os dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Rastreamento criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = RastreamentoResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada invÃ¡lidos (coordenadas ausentes)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"RequisiÃ§Ã£o InvÃ¡lida\",\"message\":\"Todas as coordenadas sÃ£o obrigatÃ³rias.\",\"path\":\"/api/rastreamentos\"}")))
            }
    )
    @PostMapping
    public ResponseEntity<RastreamentoResponseDto> criarRastreamento(@Valid @RequestBody RastreamentoRequestDto rastreamentoRequestDto) {
        log.info("Recebida requisiÃ§Ã£o para criar rastreamento: {}", rastreamentoRequestDto);
        try {
            RastreamentoResponseDto novoRastreamento = rastreamentoMapper.toResponseDto(rastreamentoService.criarRastreamento(rastreamentoRequestDto));
            log.info("Rastreamento criado com sucesso com ID: {}", novoRastreamento.getIdRastreamento());
            return ResponseEntity.status(HttpStatus.CREATED).body(novoRastreamento);
        } catch (InvalidInputException e) {
            log.error("Erro ao criar rastreamento - RequisiÃ§Ã£o invÃ¡lida: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao criar rastreamento: {}", e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Atualizar rastreamento existente",
            description = "Atualiza um rastreamento existente com base no ID e nos dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Rastreamento atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = RastreamentoResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada invÃ¡lidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"RequisiÃ§Ã£o InvÃ¡lida\",\"message\":\"Mensagem de validaÃ§Ã£o ou erro de input.\",\"path\":\"/api/rastreamentos/1\"}"))),
                    @ApiResponse(responseCode = "404", description = "Rastreamento nÃ£o encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"Rastreamento com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/rastreamentos/1\"}")))
            }
    )
    @PutMapping("/{id}")
    public ResponseEntity<RastreamentoResponseDto> atualizarRastreamento(@PathVariable Long id, @Valid @RequestBody RastreamentoRequestDto rastreamentoRequestDto) {
        log.info("Recebida requisiÃ§Ã£o para atualizar rastreamento com ID {}: {}", id, rastreamentoRequestDto);
        try {
            RastreamentoResponseDto rastreamentoAtualizado = rastreamentoMapper.toResponseDto(rastreamentoService.atualizarRastreamento(id, rastreamentoRequestDto));
            log.info("Rastreamento com ID {} atualizado com sucesso.", id);
            return ResponseEntity.ok(rastreamentoAtualizado);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao atualizar rastreamento - NÃ£o encontrado: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao atualizar rastreamento com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Deletar rastreamento",
            description = "Exclui um rastreamento com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Rastreamento deletado com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Rastreamento nÃ£o encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"Rastreamento com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/rastreamentos/1\"}")))
            }
    )
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarRastreamento(@PathVariable Long id) {
        log.info("Recebida requisiÃ§Ã£o para deletar rastreamento com ID: {}", id);
        try {
            rastreamentoService.deletarRastreamento(id);
            log.info("Rastreamento com ID {} deletado com sucesso.", id);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao deletar rastreamento - NÃ£o encontrado: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao deletar rastreamento com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\controller\VeiculoController.java   |   package br.com.fiap.mottu.controller   |   class VeiculoController
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.veiculo.VeiculoRequestDto;
import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.mottu.dto.veiculo.VeiculoLocalizacaoResponseDto; // NOVO: Importar

import br.com.fiap.mottu.filter.VeiculoFilter;
import br.com.fiap.mottu.service.VeiculoService;
import br.com.fiap.mottu.mapper.VeiculoMapper;
import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/veiculos")
@Tag(name = "Veiculos", description = "Gerenciamento de VeÃ­culos e Rastreamento") // Altere o Tag para refletir o rastreamento
public class VeiculoController {

    private static final Logger log = LoggerFactory.getLogger(VeiculoController.class);
    private final VeiculoService veiculoService;
    private final VeiculoMapper veiculoMapper;

    @Autowired
    public VeiculoController(VeiculoService veiculoService,
                             VeiculoMapper veiculoMapper) {
        this.veiculoService = veiculoService;
        this.veiculoMapper = veiculoMapper;
    }

    @Operation(
            summary = "Listar todos os veÃ­culos",
            description = "Retorna uma lista de todos os veÃ­culos cadastrados.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de veÃ­culos retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoResponseDto.class)))
            }
    )
    @GetMapping
    public ResponseEntity<List<VeiculoResponseDto>> listarTodosVeiculos() {
        log.info("Buscando todos os veÃ­culos.");
        List<VeiculoResponseDto> veiculos = veiculoService.listarTodosVeiculos().stream()
                .map(veiculoMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} veÃ­culos.", veiculos.size());
        return ResponseEntity.ok(veiculos);
    }

    @Operation(
            summary = "Buscar veÃ­culo por ID",
            description = "Retorna um veÃ­culo especÃ­fico com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "VeÃ­culo encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "VeÃ­culo nÃ£o encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"VeÃ­culo com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/veiculos/1\"}")))
            }
    )
    @GetMapping("/{id}")
    public ResponseEntity<VeiculoResponseDto> buscarVeiculoPorId(@PathVariable Long id) {
        log.info("Buscando veÃ­culo com ID: {}", id);
        try {
            VeiculoResponseDto veiculo = veiculoMapper.toResponseDto(veiculoService.buscarVeiculoPorId(id));
            log.info("VeÃ­culo com ID {} encontrado com sucesso.", id);
            return ResponseEntity.ok(veiculo);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar veÃ­culo com ID {}: {}", id, e.getMessage());
            throw e;
        }
    }

    @Operation(
            summary = "Buscar veÃ­culos por filtro",
            description = "Retorna uma lista de veÃ­culos que correspondem aos critÃ©rios de filtro fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de veÃ­culos filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoResponseDto.class)))
            }
    )
    @GetMapping("/search")
    public ResponseEntity<List<VeiculoResponseDto>> buscarVeiculosPorFiltro(VeiculoFilter filter) {
        log.info("Buscando veÃ­culos com filtro: {}", filter);
        List<VeiculoResponseDto> veiculos = veiculoService.buscarVeiculosPorFiltro(filter).stream()
                .map(veiculoMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} veÃ­culos filtrados.", veiculos.size());
        return ResponseEntity.ok(veiculos);
    }

    @Operation(
            summary = "Criar novo veÃ­culo",
            description = "Cria um novo veÃ­culo com os dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "VeÃ­culo criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada invÃ¡lidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"RequisiÃ§Ã£o InvÃ¡lida\",\"message\":\"Mensagem de validaÃ§Ã£o ou erro de input.\",\"path\":\"/api/veiculos\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (placa, RENAVAM ou chassi duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"VeÃ­culo com placa 'ABC1234' jÃ¡ existe.\",\"path\":\"/api/veiculos\"}")))
            }
    )
    @PostMapping
    public ResponseEntity<VeiculoResponseDto> criarVeiculo(@Valid @RequestBody VeiculoRequestDto veiculoRequestDto) {
        log.info("Recebida requisiÃ§Ã£o para criar veÃ­culo: {}", veiculoRequestDto);
        try {
            VeiculoResponseDto novoVeiculo = veiculoMapper.toResponseDto(veiculoService.criarVeiculo(veiculoRequestDto));
            log.info("VeÃ­culo criado com sucesso com ID: {}", novoVeiculo.getIdVeiculo());
            return ResponseEntity.status(HttpStatus.CREATED).body(novoVeiculo);
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao criar veÃ­culo - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao criar veÃ­culo: {}", e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Atualizar veÃ­culo existente",
            description = "Atualiza um veÃ­culo existente com base no ID e nos dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "VeÃ­culo atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada invÃ¡lidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"RequisiÃ§Ã£o InvÃ¡lida\",\"message\":\"Mensagem de validaÃ§Ã£o ou erro de input.\",\"path\":\"/api/veiculos/1\"}"))),
                    @ApiResponse(responseCode = "404", description = "VeÃ­culo nÃ£o encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"VeÃ­culo com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/veiculos/1\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (placa, RENAVAM ou chassi duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"VeÃ­culo com placa 'ABC1234' jÃ¡ existe.\",\"path\":\"/api/veiculos/1\"}")))
            }
    )
    @PutMapping("/{id}")
    public ResponseEntity<VeiculoResponseDto> atualizarVeiculo(@PathVariable Long id, @Valid @RequestBody VeiculoRequestDto veiculoRequestDto) {
        log.info("Recebida requisiÃ§Ã£o para atualizar veÃ­culo com ID {}: {}", id, veiculoRequestDto);
        try {
            VeiculoResponseDto veiculoAtualizado = veiculoMapper.toResponseDto(veiculoService.atualizarVeiculo(id, veiculoRequestDto));
            log.info("VeÃ­culo com ID {} atualizado com sucesso.", id);
            return ResponseEntity.ok(veiculoAtualizado);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao atualizar veÃ­culo - NÃ£o encontrado: {}", e.getMessage());
            throw e;
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao atualizar veÃ­culo - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao atualizar veÃ­culo com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Deletar veÃ­culo",
            description = "Exclui um veÃ­culo com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "VeÃ­culo deletado com sucesso"),
                    @ApiResponse(responseCode = "404", description = "VeÃ­culo nÃ£o encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"VeÃ­culo com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/veiculos/1\"}")))
            }
    )
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarVeiculo(@PathVariable Long id) {
        log.info("Recebida requisiÃ§Ã£o para deletar veÃ­culo com ID: {}", id);
        try {
            veiculoService.deletarVeiculo(id);
            log.info("VeÃ­culo com ID {} deletado com sucesso.", id);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao deletar veÃ­culo - NÃ£o encontrado: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao deletar veÃ­culo com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }

    /**
     * Endpoint para obter a localizaÃ§Ã£o de um veÃ­culo.
     * Retorna o Ãºltimo ponto de rastreamento do veÃ­culo e suas associaÃ§Ãµes atuais com PÃ¡tio, Zona e Box.
     *
     * @param id O ID do veÃ­culo a ser localizado.
     * @return ResponseEntity contendo o DTO de localizaÃ§Ã£o do veÃ­culo ou um erro.
     */
    @Operation(
            summary = "Obter localizaÃ§Ã£o de um veÃ­culo",
            description = "Retorna o Ãºltimo ponto de rastreamento de um veÃ­culo e suas associaÃ§Ãµes atuais com PÃ¡tio, Zona e Box.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "LocalizaÃ§Ã£o do veÃ­culo retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoLocalizacaoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "VeÃ­culo nÃ£o encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"VeÃ­culo com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/veiculos/1/localizacao\"}")))
            }
    )
    @GetMapping("/{id}/localizacao")
    public ResponseEntity<VeiculoLocalizacaoResponseDto> getLocalizacaoVeiculo(@PathVariable Long id) {
        log.info("Buscando localizaÃ§Ã£o para o veÃ­culo com ID: {}", id);
        try {
            VeiculoLocalizacaoResponseDto localizacao = veiculoService.getLocalizacaoVeiculo(id);
            log.info("LocalizaÃ§Ã£o do veÃ­culo com ID {} encontrada com sucesso.", id);
            return ResponseEntity.ok(localizacao);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar localizaÃ§Ã£o para o veÃ­culo com ID {}: {}", id, e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao buscar localizaÃ§Ã£o para o veÃ­culo com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\controller\ZonaController.java   |   package br.com.fiap.mottu.controller   |   class ZonaController
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.zona.ZonaRequestDto;
import br.com.fiap.mottu.dto.zona.ZonaResponseDto;
import br.com.fiap.mottu.filter.ZonaFilter;
import br.com.fiap.mottu.service.ZonaService;
import br.com.fiap.mottu.mapper.ZonaMapper;
import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/zonas")
@Tag(name = "Zonas", description = "Gerenciamento de Zonas")
public class ZonaController {

    private static final Logger log = LoggerFactory.getLogger(ZonaController.class);
    private final ZonaService zonaService;
    private final ZonaMapper zonaMapper;

    @Autowired
    public ZonaController(ZonaService zonaService, ZonaMapper zonaMapper) {
        this.zonaService = zonaService;
        this.zonaMapper = zonaMapper;
    }

    @Operation(
            summary = "Listar todas as zonas",
            description = "Retorna uma lista de todas as zonas cadastradas.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de zonas retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ZonaResponseDto.class)))
            }
    )
    @GetMapping
    public ResponseEntity<List<ZonaResponseDto>> listarTodasZonas() {
        log.info("Buscando todas as zonas.");
        List<ZonaResponseDto> zonas = zonaService.listarTodasZonas().stream()
                .map(zonaMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} zonas.", zonas.size());
        return ResponseEntity.ok(zonas);
    }

    @Operation(
            summary = "Buscar zona por ID",
            description = "Retorna uma zona especÃ­fica com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Zona encontrada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ZonaResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Zona nÃ£o encontrada",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"Zona com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/zonas/1\"}")))
            }
    )
    @GetMapping("/{id}")
    public ResponseEntity<ZonaResponseDto> buscarZonaPorId(@PathVariable Long id) {
        log.info("Buscando zona com ID: {}", id);
        try {
            ZonaResponseDto zona = zonaMapper.toResponseDto(zonaService.buscarZonaPorId(id));
            log.info("Zona com ID {} encontrado com sucesso.", id);
            return ResponseEntity.ok(zona);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar zona com ID {}: {}", id, e.getMessage());
            throw e;
        }
    }

    @Operation(
            summary = "Buscar zonas por filtro",
            description = "Retorna uma lista de zonas que correspondem aos critÃ©rios de filtro fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de zonas filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ZonaResponseDto.class)))
            }
    )
    @GetMapping("/search")
    public ResponseEntity<List<ZonaResponseDto>> buscarZonasPorFiltro(ZonaFilter filter) {
        log.info("Buscando zonas com filtro: {}", filter);
        List<ZonaResponseDto> zonas = zonaService.buscarZonasPorFiltro(filter).stream()
                .map(zonaMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} zonas filtradas.", zonas.size());
        return ResponseEntity.ok(zonas);
    }

    @Operation(
            summary = "Criar nova zona",
            description = "Cria uma nova zona com os dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Zona criada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ZonaResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada invÃ¡lidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"RequisiÃ§Ã£o InvÃ¡lida\",\"message\":\"Mensagem de validaÃ§Ã£o ou erro de input.\",\"path\":\"/api/zonas\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (nome duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Zona com nome 'Nome Duplicado' jÃ¡ existe.\",\"path\":\"/api/zonas\"}")))
            }
    )
    @PostMapping
    public ResponseEntity<ZonaResponseDto> criarZona(@Valid @RequestBody ZonaRequestDto zonaRequestDto) {
        log.info("Recebida requisiÃ§Ã£o para criar zona: {}", zonaRequestDto);
        try {
            ZonaResponseDto novaZona = zonaMapper.toResponseDto(zonaService.criarZona(zonaRequestDto));
            log.info("Zona criada com sucesso com ID: {}", novaZona.getIdZona());
            return ResponseEntity.status(HttpStatus.CREATED).body(novaZona);
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao criar zona - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao criar zona: {}", e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Atualizar zona existente",
            description = "Atualiza uma zona existente com base no ID e nos dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Zona atualizada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ZonaResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada invÃ¡lidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"RequisiÃ§Ã£o InvÃ¡lida\",\"message\":\"Mensagem de validaÃ§Ã£o ou erro de input.\",\"path\":\"/api/zonas/1\"}"))),
                    @ApiResponse(responseCode = "404", description = "Zona nÃ£o encontrada",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"Zona com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/zonas/1\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (nome duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Zona com nome 'Nome Duplicado' jÃ¡ existe.\",\"path\":\"/api/zonas/1\"}")))
            }
    )
    @PutMapping("/{id}")
    public ResponseEntity<ZonaResponseDto> atualizarZona(@PathVariable Long id, @Valid @RequestBody ZonaRequestDto zonaRequestDto) {
        log.info("Recebida requisiÃ§Ã£o para atualizar zona com ID {}: {}", id, zonaRequestDto);
        try {
            ZonaResponseDto zonaAtualizada = zonaMapper.toResponseDto(zonaService.atualizarZona(id, zonaRequestDto));
            log.info("Zona com ID {} atualizada com sucesso.", id);
            return ResponseEntity.ok(zonaAtualizada);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao atualizar zona - NÃ£o encontrado: {}", e.getMessage());
            throw e;
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao atualizar zona - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao atualizar zona com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Deletar zona",
            description = "Exclui uma zona com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Zona deletada com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Zona nÃ£o encontrada",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"NÃ£o Encontrado\",\"message\":\"Zona com ID 1 nÃ£o encontrado(a).\",\"path\":\"/api/zonas/1\"}")))
            }
    )
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarZona(@PathVariable Long id) {
        log.info("Recebida requisiÃ§Ã£o para deletar zona com ID: {}", id);
        try {
            zonaService.deletarZona(id);
            log.info("Zona com ID {} deletada com sucesso.", id);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao deletar zona - NÃ£o encontrado: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao deletar zona com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\dto\box\BoxRequestDto.java   |   package br.com.fiap.mottu.dto.box   |   class BoxRequestDto
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\dto\box\BoxRequestDto.java
package br.com.fiap.mottu.dto.box;

import lombok.Value;
import java.io.Serializable;
import java.time.LocalDate;
import jakarta.validation.constraints.*;

/**
 * DTO for {@link br.com.fiap.mottu.model.Box}
 */
@Value
public class BoxRequestDto implements Serializable {
    @NotBlank(message = "O nome nÃ£o pode estar em branco.")
    @Size(max = 50, message = "O nome deve ter no mÃ¡ximo 50 caracteres.")
    String nome;

    @NotBlank(message = "O status nÃ£o pode estar em branco.")
    @Size(max = 1, message = "O status deve ter 1 caracter.")
    @Pattern(regexp = "[LO]", message = "O status deve ser 'L' (Livre) ou 'O' (Ocupado).")
    String status;

    @NotNull(message = "A data de entrada nÃ£o pode ser nula.")
    LocalDate dataEntrada;

    @NotNull(message = "A data de saÃ­da nÃ£o pode ser nula.")
    LocalDate dataSaida;

    @Size(max = 100, message = "A observaÃ§Ã£o deve ter no mÃ¡ximo 100 caracteres.")
    String observacao;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\dto\box\BoxResponseDto.java   |   package br.com.fiap.mottu.dto.box   |   class BoxResponseDto
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\dto\box\BoxResponseDto.java
package br.com.fiap.mottu.dto.box;

import lombok.Value;
import java.io.Serializable;
import java.time.LocalDate;

/**
 * DTO for {@link br.com.fiap.mottu.model.Box}
 */
@Value
public class BoxResponseDto implements Serializable {
    Long idBox;
    String nome;
    String status;
    LocalDate dataEntrada;
    LocalDate dataSaida;
    String observacao;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\dto\cliente\ClienteRequestDto.java   |   package br.com.fiap.mottu.dto.cliente   |   class ClienteRequestDto
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\dto\cliente\ClienteRequestDto.java
package br.com.fiap.mottu.dto.cliente;

import br.com.fiap.mottu.dto.contato.ContatoRequestDto;
import br.com.fiap.mottu.dto.endereco.EnderecoRequestDto;
import lombok.Value;

import jakarta.validation.Valid;
import jakarta.validation.constraints.*;
import java.io.Serializable;
import java.time.LocalDate;

/**
 * DTO for {@link br.com.fiap.mottu.model.Cliente}
 */
@Value
public class ClienteRequestDto implements Serializable {
    @NotBlank(message = "O sexo nÃ£o pode estar em branco.")
    @Size(min = 1, max = 2, message = "O sexo deve ter 1 ou 2 caracteres.")
    @Pattern(regexp = "^[MH]$", message = "O sexo deve ser 'M' (Masculino) ou 'H' (Feminino).")
    String sexo;

    @NotBlank(message = "O nome nÃ£o pode estar em branco.")
    @Size(max = 100, message = "O nome deve ter no mÃ¡ximo 100 caracteres.")
    String nome;

    @NotBlank(message = "O sobrenome nÃ£o pode estar em branco.")
    @Size(max = 100, message = "O sobrenome deve ter no mÃ¡ximo 100 caracteres.")
    String sobrenome;

    @NotNull(message = "A data de nascimento nÃ£o pode ser nula.")
    @Past(message = "A data de nascimento deve ser no passado.")
    LocalDate dataNascimento;

    @NotBlank(message = "O CPF nÃ£o pode estar em branco.")
    @Size(min = 11, max = 11, message = "O CPF deve ter 11 caracteres.")
    @Pattern(regexp = "^\\d{11}$", message = "O CPF deve conter apenas dÃ­gitos.")
    String cpf;

    @NotBlank(message = "A profissÃ£o nÃ£o pode estar em branco.")
    @Size(max = 50, message = "A profissÃ£o deve ter no mÃ¡ximo 50 caracteres.")
    String profissao;

    @NotBlank(message = "O estado civil nÃ£o pode estar em branco.")
    @Size(max = 50, message = "O estado civil deve ter no mÃ¡ximo 50 caracteres.")
    @Pattern(regexp = "^(Solteiro|Casado|Divorciado|ViÃºvo|Separado|UniÃ£o EstÃ¡vel)$", message = "Estado civil invÃ¡lido.")
    String estadoCivil;

    @NotNull(message = "O endereÃ§o nÃ£o pode ser nulo.")
    @Valid
    EnderecoRequestDto enderecoRequestDto;

    @NotNull(message = "O contato nÃ£o pode ser nulo.")
    @Valid
    ContatoRequestDto contatoRequestDto;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\dto\cliente\ClienteResponseDto.java   |   package br.com.fiap.mottu.dto.cliente   |   class ClienteResponseDto
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\dto\cliente\ClienteResponseDto.java
package br.com.fiap.mottu.dto.cliente;

import br.com.fiap.mottu.dto.contato.ContatoResponseDto;
import br.com.fiap.mottu.dto.endereco.EnderecoResponseDto;
import lombok.Value;

import java.io.Serializable;
import java.time.LocalDate;
import java.util.Set;
import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto;

/**
 * DTO for {@link br.com.fiap.mottu.model.Cliente}
 */
@Value
public class ClienteResponseDto implements Serializable {
    Long idCliente;
    LocalDate dataCadastro;
    String sexo;
    String nome;
    String sobrenome;
    LocalDate dataNascimento;
    String cpf;
    String profissao;
    String estadoCivil;
    EnderecoResponseDto enderecoResponseDto;
    ContatoResponseDto contatoResponseDto;

    // Set<VeiculoResponseDto> veiculos; // Necessita de mapeamento customizado no ClienteMapper
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\dto\contato\ContatoRequestDto.java   |   package br.com.fiap.mottu.dto.contato   |   class ContatoRequestDto
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// br/com/fiap/mottu/dto/contato/ContatoRequestDto.java
package br.com.fiap.mottu.dto.contato;

import lombok.Value;
import jakarta.validation.constraints.*;
import java.io.Serializable;

@Value
public class ContatoRequestDto implements Serializable {
    /** ID para identificar um contato existente em operaÃ§Ãµes de atualizaÃ§Ã£o */
    Long idContato;

    @NotBlank(message = "O email nÃ£o pode estar em branco.")
    @Email(message = "Formato de email invÃ¡lido.")
    String email;

    @Min(value = 0, message = "DDD invÃ¡lido.")
    Integer ddd;

    @Min(value = 0, message = "DDI invÃ¡lido.")
    Integer ddi;

    @Size(max = 20, message = "O telefone 1 deve ter no mÃ¡ximo 20 caracteres.")
    String telefone1;

    @Size(max = 20, message = "O telefone 2 deve ter no mÃ¡ximo 20 caracteres.")
    String telefone2;

    @Size(max = 20, message = "O telefone 3 deve ter no mÃ¡ximo 20 caracteres.")
    String telefone3;

    @NotBlank(message = "O celular nÃ£o pode estar em branco.")
    @Size(max = 20, message = "O celular deve ter no mÃ¡ximo 20 caracteres.")
    String celular;

    @Size(max = 100, message = "Outras informaÃ§Ãµes de contato devem ter no mÃ¡ximo 100 caracteres.")
    String outro;

    @Size(max = 200, message = "A observaÃ§Ã£o deve ter no mÃ¡ximo 200 caracteres.")
    String observacao;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\dto\contato\ContatoResponseDto.java   |   package br.com.fiap.mottu.dto.contato   |   class ContatoResponseDto
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\dto\contato\ContatoResponseDto.java
package br.com.fiap.mottu.dto.contato;

import lombok.Value;

import java.io.Serializable;

/**
 * DTO for {@link br.com.fiap.mottu.model.Contato}
 */
@Value
public class ContatoResponseDto implements Serializable {
    Long idContato;
    String email;
    Integer ddd;
    Integer ddi;
    String telefone1;
    String telefone2;
    String telefone3;
    String celular;
    String outro;
    String observacao;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\dto\endereco\EnderecoRequestDto.java   |   package br.com.fiap.mottu.dto.endereco   |   class EnderecoRequestDto
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\dto\endereco\EnderecoRequestDto.java
package br.com.fiap.mottu.dto.endereco;

import lombok.Value;

import jakarta.validation.constraints.*;
import java.io.Serializable;

/**
 * DTO for {@link br.com.fiap.mottu.model.Endereco}
 */
@Value
public class EnderecoRequestDto implements Serializable {
    // Apenas CEP, numero, complemento e observacao virÃ£o na requisiÃ§Ã£o
    // Outros campos serÃ£o preenchidos pela ViaCEP
    @NotBlank(message = "O CEP nÃ£o pode estar em branco.")
    @Size(min = 8, max = 9, message = "O CEP deve ter 8 ou 9 caracteres (formato 'XXXXXXXX' ou 'XXXXX-XXX').")
    @Pattern(regexp = "^\\d{8}$|^\\d{5}-\\d{3}$", message = "Formato de CEP invÃ¡lido (esperado XXXXXXXX ou XXXXX-XXX).")
    String cep;

    @NotNull(message = "O nÃºmero do endereÃ§o nÃ£o pode ser nulo.")
    @Positive(message = "O nÃºmero do endereÃ§o deve ser positivo.")
    @Max(value = 9999999, message = "O nÃºmero do endereÃ§o deve ter no mÃ¡ximo 7 dÃ­gitos.")
    Integer numero;

    @Size(max = 60, message = "O complemento deve ter no mÃ¡ximo 60 caracteres.")
    String complemento;

    @Size(max = 200, message = "A observaÃ§Ã£o deve ter no mÃ¡ximo 200 caracteres.")
    String observacao;

    // ID para identificar um endereÃ§o existente em operaÃ§Ãµes de atualizaÃ§Ã£o
    Long idEndereco; // Adicionado para permitir a atualizaÃ§Ã£o de endereÃ§os existentes via ClienteRequestDto
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\dto\endereco\EnderecoResponseDto.java   |   package br.com.fiap.mottu.dto.endereco   |   class EnderecoResponseDto
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\dto\endereco\EnderecoResponseDto.java
package br.com.fiap.mottu.dto.endereco;

import lombok.Value;

import java.io.Serializable;

/**
 * DTO for {@link br.com.fiap.mottu.model.Endereco}
 */
@Value
public class EnderecoResponseDto implements Serializable {
    Long idEndereco;
    String cep;
    Integer numero;
    String logradouro;
    String bairro;
    String cidade;
    String estado;
    String pais;
    String complemento;
    String observacao;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\dto\patio\PatioRequestDto.java   |   package br.com.fiap.mottu.dto.patio   |   class PatioRequestDto
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\dto\patio\PatioRequestDto.java
package br.com.fiap.mottu.dto.patio;

import lombok.Value;
import java.io.Serializable;
import java.time.LocalDate;
import jakarta.validation.constraints.*;

/**
 * DTO for {@link br.com.fiap.mottu.model.Patio}
 */
@Value
public class PatioRequestDto implements Serializable {
    @NotBlank(message = "O nome do pÃ¡tio nÃ£o pode estar em branco.")
    @Size(max = 50, message = "O nome do pÃ¡tio deve ter no mÃ¡ximo 50 caracteres.")
    String nomePatio;

    @NotNull(message = "A data de entrada nÃ£o pode ser nula.")
    LocalDate dataEntrada;

    @NotNull(message = "A data de saÃ­da nÃ£o pode ser nula.")
    LocalDate dataSaida;

    @Size(max = 100, message = "A observaÃ§Ã£o deve ter no mÃ¡ximo 100 caracteres.")
    String observacao;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\dto\patio\PatioResponseDto.java   |   package br.com.fiap.mottu.dto.patio   |   class PatioResponseDto
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\dto\patio\PatioResponseDto.java
package br.com.fiap.mottu.dto.patio;

import lombok.Value;
import java.io.Serializable;
import java.time.LocalDate;

/**
 * DTO for {@link br.com.fiap.mottu.model.Patio}
 */
@Value
public class PatioResponseDto implements Serializable {
    Long idPatio;
    String nomePatio;
    LocalDate dataEntrada;
    LocalDate dataSaida;
    String observacao;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\dto\rastreamento\RastreamentoRequestDto.java   |   package br.com.fiap.mottu.dto.rastreamento   |   class RastreamentoRequestDto
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.dto.rastreamento;

import lombok.Value;
import jakarta.validation.constraints.*;
import java.io.Serializable;
import java.math.BigDecimal; // Importe BigDecimal!

/**
 * DTO for {@link br.com.fiap.mottu.model.Rastreamento}
 */
@Value
public class RastreamentoRequestDto implements Serializable {

    @NotNull(message = "A coordenada IPS X nÃ£o pode ser nula.")
    private BigDecimal ipsX;

    @NotNull(message = "A coordenada IPS Y nÃ£o pode ser nula.")
    private BigDecimal ipsY;

    @NotNull(message = "A coordenada IPS Z nÃ£o pode ser nula.")
    private BigDecimal ipsZ;

    @NotNull(message = "A Latitude GPRS nÃ£o pode ser nula.")
    private BigDecimal gprsLatitude;

    @NotNull(message = "A Longitude GPRS nÃ£o pode ser nula.")
    private BigDecimal gprsLongitude;

    @NotNull(message = "A Altitude GPRS nÃ£o pode ser nula.")
    private BigDecimal gprsAltitude;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\dto\rastreamento\RastreamentoResponseDto.java   |   package br.com.fiap.mottu.dto.rastreamento   |   class RastreamentoResponseDto
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.dto.rastreamento;

import lombok.Value;
import java.io.Serializable;
import java.math.BigDecimal; // Importe BigDecimal!

/**
 * DTO for {@link br.com.fiap.mottu.model.Rastreamento}
 */
@Value
public class RastreamentoResponseDto implements Serializable {
    Long idRastreamento;

    private BigDecimal ipsX;
    private BigDecimal ipsY;
    private BigDecimal ipsZ;

    private BigDecimal gprsLatitude;
    private BigDecimal gprsLongitude;
    private BigDecimal gprsAltitude;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\dto\veiculo\VeiculoLocalizacaoResponseDto.java   |   package br.com.fiap.mottu.dto.veiculo   |   class VeiculoLocalizacaoResponseDto
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.dto.veiculo;

import br.com.fiap.mottu.dto.rastreamento.RastreamentoResponseDto;
import br.com.fiap.mottu.dto.patio.PatioResponseDto;
import br.com.fiap.mottu.dto.zona.ZonaResponseDto;
import br.com.fiap.mottu.dto.box.BoxResponseDto;
import lombok.Value;

import java.io.Serializable;
import java.time.LocalDateTime; // Para o timestamp do Ãºltimo rastreamento

@Value
public class VeiculoLocalizacaoResponseDto implements Serializable {
    Long idVeiculo;
    String placa;
    String modelo;
    String fabricante;

    RastreamentoResponseDto ultimoRastreamento; // O Ãºltimo ponto de rastreamento

    PatioResponseDto patioAssociado; // O pÃ¡tio ao qual o veÃ­culo estÃ¡ atualmente associado (se houver)
    ZonaResponseDto zonaAssociada;   // A zona ao qual o veÃ­culo estÃ¡ atualmente associado (se houver)
    BoxResponseDto boxAssociado;     // O box ao qual o veÃ­culo estÃ¡ atualmente associado (se houver)

    LocalDateTime dataConsulta; // Timestamp da consulta
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\dto\veiculo\VeiculoRequestDto.java   |   package br.com.fiap.mottu.dto.veiculo   |   class VeiculoRequestDto
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\dto\veiculo\VeiculoRequestDto.java
package br.com.fiap.mottu.dto.veiculo;

import lombok.Value;
import jakarta.validation.constraints.*;
import java.io.Serializable;

/**
 * DTO for {@link br.com.fiap.mottu.model.Veiculo}
 */
@Value
public class VeiculoRequestDto implements Serializable {
    @NotBlank(message = "A placa nÃ£o pode estar em branco.")
    @Size(max = 10, message = "A placa deve ter no mÃ¡ximo 10 caracteres.")
    String placa;

    @NotBlank(message = "O RENAVAM nÃ£o pode estar em branco.")
    @Size(min = 11, max = 11, message = "O RENAVAM deve ter 11 caracteres.")
    @Pattern(regexp = "^\\d{11}$", message = "O RENAVAM deve conter apenas dÃ­gitos.")
    String renavam;

    @NotBlank(message = "O chassi nÃ£o pode estar em branco.")
    @Size(min = 17, max = 17, message = "O chassi deve ter 17 caracteres.")
    String chassi;

    @NotBlank(message = "O fabricante nÃ£o pode estar em branco.")
    @Size(max = 50, message = "O fabricante deve ter no mÃ¡ximo 50 caracteres.")
    String fabricante;

    @NotBlank(message = "O modelo nÃ£o pode estar em branco.")
    @Size(max = 60, message = "O modelo deve ter no mÃ¡ximo 60 caracteres.")
    String modelo;

    @Size(max = 30, message = "O motor deve ter no mÃ¡ximo 30 caracteres.")
    String motor;

    @NotNull(message = "O ano nÃ£o pode ser nulo.")
    @Min(value = 1900, message = "O ano deve ser a partir de 1900.")
    @Max(value = 2100, message = "O ano deve ser no mÃ¡ximo 2100.")
    Integer ano;

    @NotBlank(message = "O combustÃ­vel nÃ£o pode estar em branco.")
    @Size(max = 20, message = "O combustÃ­vel deve ter no mÃ¡ximo 20 caracteres.")
    String combustivel;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\dto\veiculo\VeiculoResponseDto.java   |   package br.com.fiap.mottu.dto.veiculo   |   class VeiculoResponseDto
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\dto\veiculo\VeiculoResponseDto.java
package br.com.fiap.mottu.dto.veiculo;

import lombok.Value;
import java.io.Serializable;

/**
 * DTO for {@link br.com.fiap.mottu.model.Veiculo}
 */
@Value
public class VeiculoResponseDto implements Serializable {
    Long idVeiculo;
    String placa;
    String renavam;
    String chassi;
    String fabricante;
    String modelo;
    String motor;
    Integer ano;
    String combustivel;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\dto\zona\ZonaRequestDto.java   |   package br.com.fiap.mottu.dto.zona   |   class ZonaRequestDto
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\dto\zona\ZonaRequestDto.java
package br.com.fiap.mottu.dto.zona;

import lombok.Value;
import java.io.Serializable;
import java.time.LocalDate;
import jakarta.validation.constraints.*;

/**
 * DTO for {@link br.com.fiap.mottu.model.Zona}
 */
@Value
public class ZonaRequestDto implements Serializable {
    @NotBlank(message = "O nome nÃ£o pode estar em branco.")
    @Size(max = 50, message = "O nome deve ter no mÃ¡ximo 50 caracteres.")
    String nome;

    @NotNull(message = "A data de entrada nÃ£o pode ser nula.")
    LocalDate dataEntrada;

    @NotNull(message = "A data de saÃ­da nÃ£o pode ser nula.")
    LocalDate dataSaida;

    @Size(max = 100, message = "A observaÃ§Ã£o deve ter no mÃ¡ximo 100 caracteres.")
    String observacao;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\dto\zona\ZonaResponseDto.java   |   package br.com.fiap.mottu.dto.zona   |   class ZonaResponseDto
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\dto\zona\ZonaResponseDto.java
package br.com.fiap.mottu.dto.zona;

import lombok.Value;
import java.io.Serializable;
import java.time.LocalDate;

/**
 * DTO for {@link br.com.fiap.mottu.model.Zona}
 */
@Value
public class ZonaResponseDto implements Serializable {
    Long idZona;
    String nome;
    LocalDate dataEntrada;
    LocalDate dataSaida;
    String observacao;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\exception\DuplicatedResourceException.java   |   package br.com.fiap.mottu.exception   |   class DuplicatedResourceException
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\exception\DuplicatedResourceException.java
package br.com.fiap.mottu.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

// AnotaÃ§Ã£o para que o Spring mude o status HTTP automaticamente
@ResponseStatus(HttpStatus.CONFLICT) // 409 Conflict
public class DuplicatedResourceException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    public DuplicatedResourceException(String message) {
        super(message);
    }

    public DuplicatedResourceException(String resourceName, String identifierName, String identifierValue) {
        super(String.format("%s com %s '%s' jÃ¡ existe.", resourceName, identifierName, identifierValue));
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\exception\InvalidInputException.java   |   package br.com.fiap.mottu.exception   |   class InvalidInputException
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\exception\InvalidInputException.java
package br.com.fiap.mottu.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

// AnotaÃ§Ã£o para que o Spring mude o status HTTP automaticamente
@ResponseStatus(HttpStatus.BAD_REQUEST) // 400 Bad Request
public class InvalidInputException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    public InvalidInputException(String message) {
        super(message);
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\exception\ResourceNotFoundException.java   |   package br.com.fiap.mottu.exception   |   class ResourceNotFoundException
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\exception\ResourceNotFoundException.java
package br.com.fiap.mottu.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

// AnotaÃ§Ã£o para que o Spring mude o status HTTP automaticamente
@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    public ResourceNotFoundException(String message) {
        super(message);
    }

    public ResourceNotFoundException(String resourceName, Long id) {
        super(String.format("%s com ID %d nÃ£o encontrado(a).", resourceName, id));
    }

    public ResourceNotFoundException(String resourceName, String identifierName, String identifierValue) {
        super(String.format("%s com %s '%s' nÃ£o encontrado(a).", resourceName, identifierName, identifierValue));
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\exception\handler\GlobalExceptionHandler.java   |   package br.com.fiap.mottu.exception.handler   |   class GlobalExceptionHandler
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\exception\handler\GlobalExceptionHandler.java
package br.com.fiap.mottu.exception.handler;

import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.InvalidInputException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

import java.time.LocalDateTime;
import java.util.LinkedHashMap;
import java.util.Map;

@ControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Object> handleResourceNotFoundException(ResourceNotFoundException ex, WebRequest request) {
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.NOT_FOUND.value());
        body.put("error", "NÃ£o Encontrado");
        body.put("message", ex.getMessage());
        body.put("path", request.getDescription(false));
        return new ResponseEntity<>(body, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(DuplicatedResourceException.class)
    public ResponseEntity<Object> handleDuplicatedResourceException(DuplicatedResourceException ex, WebRequest request) {
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.CONFLICT.value());
        body.put("error", "Conflito de Dados");
        body.put("message", ex.getMessage());
        body.put("path", request.getDescription(false));
        return new ResponseEntity<>(body, HttpStatus.CONFLICT);
    }

    @ExceptionHandler(InvalidInputException.class)
    public ResponseEntity<Object> handleInvalidInputException(InvalidInputException ex, WebRequest request) {
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.BAD_REQUEST.value());
        body.put("error", "RequisiÃ§Ã£o InvÃ¡lida");
        body.put("message", ex.getMessage());
        body.put("path", request.getDescription(false));
        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
    }

    // VocÃª pode adicionar mais handlers para outras exceÃ§Ãµes que possam surgir,
    // como DataIntegrityViolationException do JPA/Hibernate.
    // Exemplo:
    // @ExceptionHandler(DataIntegrityViolationException.class)
    // public ResponseEntity<Object> handleDataIntegrityViolationException(DataIntegrityViolationException ex, WebRequest request) {
    //    // ... lÃ³gica similar, retornando 409 Conflict ou 400 Bad Request dependendo do caso
    // }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\external\viacep\ViaCepResponse.java   |   package br.com.fiap.mottu.external.viacep   |   class ViaCepResponse
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\external\viacep\ViaCepResponse.java
package br.com.fiap.mottu.external.viacep; // Pacote atualizado

import com.fasterxml.jackson.annotation.JsonAlias;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ViaCepResponse {
    private String cep;
    private String logradouro;
    private String complemento;
    private String bairro;
    private String localidade; // Corresponde Ã  cidade
    private String uf;         // Corresponde ao estado
    private String ibge;
    private String gia;
    private String ddd;
    private String siafi;

    @JsonAlias("erro")
    private Boolean erro;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\external\viacep\ViaCepService.java   |   package br.com.fiap.mottu.external.viacep   |   class ViaCepService
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\external\viacep\ViaCepService.java
package br.com.fiap.mottu.external.viacep; // Pacote atualizado

import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono; // Para trabalhar com WebClient (assÃ­ncrono)

@Service
public class ViaCepService {

    private final WebClient webClient;

    public ViaCepService(WebClient.Builder webClientBuilder) {
        this.webClient = webClientBuilder.baseUrl("https://viacep.com.br/ws/").build();
    }

    public Mono<ViaCepResponse> buscarEnderecoPorCep(String cep) {
        String cleanCep = cep.replaceAll("[^0-9]", "");

        if (cleanCep.length() != 8) {
            return Mono.error(new IllegalArgumentException("CEP invÃ¡lido. Deve conter 8 dÃ­gitos."));
        }

        return webClient.get()
                .uri("/{cep}/json/", cleanCep)
                .retrieve()
                .bodyToMono(ViaCepResponse.class)
                .flatMap(response -> {
                    if (response.getErro() != null && response.getErro()) {
                        return Mono.empty();
                    }
                    return Mono.just(response);
                });
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\filter\BoxFilter.java   |   package br.com.fiap.mottu.filter   |   class BoxFilter
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\filter\BoxFilter.java
package br.com.fiap.mottu.filter;

import java.time.LocalDate;

public record BoxFilter(
        String nome,
        String status,
        LocalDate dataEntradaInicio,
        LocalDate dataEntradaFim,
        LocalDate dataSaidaInicio,
        LocalDate dataSaidaFim,
        String observacao
) {}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\filter\ClienteFilter.java   |   package br.com.fiap.mottu.filter   |   class ClienteFilter
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\filter\ClienteFilter.java
package br.com.fiap.mottu.filter;

import java.time.LocalDate;

public record ClienteFilter(
        String nome,
        String sobrenome,
        String cpf,
        String sexo,
        String profissao,
        String estadoCivil,
        LocalDate dataCadastroInicio,
        LocalDate dataCadastroFim,
        LocalDate dataNascimentoInicio,
        LocalDate dataNascimentoFim,
        String enderecoCidade,
        String enderecoEstado,
        String contatoEmail,
        String contatoCelular,
        String veiculoPlaca,
        String veiculoModelo
) {}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\filter\ContatoFilter.java   |   package br.com.fiap.mottu.filter   |   class ContatoFilter
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\filter\ContatoFilter.java
package br.com.fiap.mottu.filter;

public record ContatoFilter(
        String email,
        Integer ddd,
        Integer ddi,
        String telefone1,
        String celular,
        String observacao,
        String clienteNome // Filtro por cliente associado
) {}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\filter\EnderecoFilter.java   |   package br.com.fiap.mottu.filter   |   class EnderecoFilter
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\filter\EnderecoFilter.java
package br.com.fiap.mottu.filter;

public record EnderecoFilter(
        String cep,
        Integer numero,
        String logradouro,
        String bairro,
        String cidade,
        String estado,
        String pais,
        String observacao,
        String clienteNome // Filtro por cliente associado
) {}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\filter\PatioFilter.java   |   package br.com.fiap.mottu.filter   |   class PatioFilter
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\filter\PatioFilter.java
package br.com.fiap.mottu.filter;

import java.time.LocalDate;

public record PatioFilter(
        String nomePatio,
        LocalDate dataEntradaInicio,
        LocalDate dataEntradaFim,
        LocalDate dataSaidaInicio,
        LocalDate dataSaidaFim,
        String observacao,
        String veiculoPlaca, // Filtro por veÃ­culo associado (via junÃ§Ã£o)
        String enderecoCidade, // Filtro por endereÃ§o associado (via junÃ§Ã£o)
        String contatoEmail, // Filtro por contato associado (via junÃ§Ã£o)
        String zonaNome // Filtro por zona associada (via junÃ§Ã£o)
) {}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\filter\RastreamentoFilter.java   |   package br.com.fiap.mottu.filter   |   class RastreamentoFilter
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.filter;

import java.math.BigDecimal; // Importe BigDecimal!

public record RastreamentoFilter(
        BigDecimal ipsX,
        BigDecimal ipsY,
        BigDecimal ipsZ,

        BigDecimal gprsLatitude,
        BigDecimal gprsLongitude,
        BigDecimal gprsAltitude,

        String veiculoPlaca // Filtro por veÃ­culo associado
) {}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\filter\VeiculoFilter.java   |   package br.com.fiap.mottu.filter   |   class VeiculoFilter
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\filter\VeiculoFilter.java
package br.com.fiap.mottu.filter;

public record VeiculoFilter(
        String placa,
        String renavam,
        String chassi,
        String fabricante,
        String modelo,
        String motor,
        Integer ano,
        String combustivel,
        String clienteCpf, // Filtro por cliente associado (via junÃ§Ã£o)
        String boxNome, // Filtro por box associado (via junÃ§Ã£o)
        String patioNome, // Filtro por patio associado (via junÃ§Ã£o)
        String zonaNome // Filtro por zona associada (via junÃ§Ã£o)
) {}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\filter\ZonaFilter.java   |   package br.com.fiap.mottu.filter   |   class ZonaFilter
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\filter\ZonaFilter.java
package br.com.fiap.mottu.filter;

import java.time.LocalDate;

public record ZonaFilter(
        String nome,
        LocalDate dataEntradaInicio,
        LocalDate dataEntradaFim,
        LocalDate dataSaidaInicio,
        LocalDate dataSaidaFim,
        String observacao,
        String boxNome, // Filtro por box associado (via junÃ§Ã£o)
        String veiculoPlaca, // Filtro por veÃ­culo associado (via junÃ§Ã£o)
        String patioNome // Filtro por patio associado (via junÃ§Ã£o)
) {}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\mapper\BoxMapper.java   |   package br.com.fiap.mottu.mapper   |   class BoxMapper
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.box.BoxRequestDto;
import br.com.fiap.mottu.dto.box.BoxResponseDto;
import br.com.fiap.mottu.model.Box;

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING,
        uses = {PatioMapper.class} // NOVO: Adicionar PatioMapper aqui, se necessÃ¡rio para o DTO (nÃ£o estritamente necessÃ¡rio para esta feature, mas boa prÃ¡tica para o grÃ¡fico de dependÃªncias)
)
public interface BoxMapper {

    // MÃ©todo 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    @Mapping(target = "idBox", ignore = true) // ID Ã© gerado pelo BD
    @Mapping(target = "veiculoBoxes", ignore = true) // Relacionamento inverso nÃ£o Ã© mapeado na criaÃ§Ã£o
    @Mapping(target = "zonaBoxes", ignore = true) // Relacionamento inverso nÃ£o Ã© mapeado na criaÃ§Ã£o
    @Mapping(target = "patioBoxes", ignore = true) // NOVO: Ignorar coleÃ§Ã£o de relacionamento muitos-para-muitos
    Box toEntity(BoxRequestDto boxRequestDto);

    // MÃ©todo 2: AtualizaÃ§Ã£o de uma Entidade existente a partir de um Request DTO
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idBox", ignore = true) // ID nÃ£o Ã© atualizado
    @Mapping(target = "veiculoBoxes", ignore = true) // Relacionamento inverso nÃ£o Ã© atualizado
    @Mapping(target = "zonaBoxes", ignore = true) // Relacionamento inverso nÃ£o Ã© atualizado
    @Mapping(target = "patioBoxes", ignore = true) // NOVO: Ignorar coleÃ§Ã£o de relacionamento muitos-para-muitos
    Box partialUpdate(BoxRequestDto boxRequestDto, @MappingTarget Box box);

    // MÃ©todo 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    BoxResponseDto toResponseDto(Box box);
    // --- MÃ©todos para mapear coleÃ§Ãµes (opcional) ---
    // List<BoxResponseDto> toResponseDtoList(List<Box> boxes);
    // Set<BoxResponseDto> toResponseDtoSet(Set<Box> boxes);
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\mapper\ClienteMapper.java   |   package br.com.fiap.mottu.mapper   |   class ClienteMapper
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\mapper\ClienteMapper.java
package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.cliente.ClienteRequestDto;
import br.com.fiap.mottu.dto.cliente.ClienteResponseDto;
import br.com.fiap.mottu.model.Cliente;

// Importe os mappers para os DTOs aninhados
import br.com.fiap.mottu.mapper.EnderecoMapper;
import br.com.fiap.mottu.mapper.ContatoMapper;
// Importar mapper para VeiculoResponseDto se ClienteResponseDto for incluÃ­-lo
// import br.com.fiap.mottu.mapper.relacionamento.ClienteVeiculoMapper;
// import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto; // Para mapear para VeiculoResponseDto

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

import java.util.Set; // NecessÃ¡rio para mapear coleÃ§Ãµes
import java.util.stream.Collectors; // NecessÃ¡rio para stream() e collect()

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING,
        // Adiciona os mappers para os DTOs aninhados (Endereco e Contato)
        uses = { EnderecoMapper.class, ContatoMapper.class }
        // Se for mapear Set<ClienteVeiculo> para Set<VeiculoResponseDto>, precisarÃ¡ de um Mapper que faÃ§a isso.
        // Ex: uses = { EnderecoMapper.class, ContatoMapper.class, ClienteVeiculoMapper.class }
)
public interface ClienteMapper {

    // MÃ©todo 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    // Mapeia ClienteRequestDto -> Cliente
    @Mapping(target = "idCliente", ignore = true) // ID Ã© gerado pelo BD, ignore ao mapear Request para Entidade
    @Mapping(target = "dataCadastro", ignore = true) // dataCadastro Ã© gerada pelo BD (DEFAULT SYSDATE), ignore ao mapear Request para Entidade
    @Mapping(target = "endereco", source = "enderecoRequestDto") // Mapeia o DTO de Endereco aninhado para a Entidade Endereco
    @Mapping(target = "contato", source = "contatoRequestDto") // Mapeia o DTO de Contato aninhado para a Entidade Contato
    @Mapping(target = "clienteVeiculos", ignore = true) // RelaÃ§Ã£o Many-to-Many nÃ£o Ã© criada diretamente aqui
    Cliente toEntity(ClienteRequestDto clienteRequestDto);

    // MÃ©todo 2: AtualizaÃ§Ã£o de uma Entidade existente a partir de um Request DTO
    // Mapeia ClienteRequestDto -> Cliente (existente)
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idCliente", ignore = true) // ID nÃ£o Ã© atualizado pelo DTO
    @Mapping(target = "dataCadastro", ignore = true) // Data de cadastro nÃ£o Ã© atualizada pelo DTO
    @Mapping(target = "endereco", source = "enderecoRequestDto") // Mapeia o DTO de Endereco aninhado para a Entidade Endereco existente no Cliente
    @Mapping(target = "contato", source = "contatoRequestDto") // Mapeia o DTO de Contato aninhado para a Entidade Contato existente no Cliente
    @Mapping(target = "clienteVeiculos", ignore = true) // RelaÃ§Ã£o Many-to-Many nÃ£o Ã© atualizada diretamente aqui
    Cliente partialUpdate(ClienteRequestDto clienteRequestDto, @MappingTarget Cliente cliente);

    // MÃ©todo 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    // Mapeia Cliente -> ClienteResponseDto
    @Mapping(target = "enderecoResponseDto", source = "endereco") // Mapeia a Entidade Endereco para o DTO de Endereco aninhado no Response
    @Mapping(target = "contatoResponseDto", source = "contato") // Mapeia a Entidade Contato para o DTO de Contato aninhado no Response
    // Se ClienteResponseDto tiver campos de coleÃ§Ãµes (ex: Set<VeiculoResponseDto> veiculos)
    // VocÃª precisaria de um mÃ©todo @Named para fazer essa conversÃ£o se ClienteVeiculoMapper nÃ£o for suficiente,
    // ou um mÃ©todo diretamente no mapper se a lÃ³gica for simples.
    // Exemplo: @Mapping(target = "veiculos", expression = "java(mapClienteVeiculosToVeiculoResponseDtos(cliente.getClienteVeiculos()))")
    ClienteResponseDto toResponseDto(Cliente cliente);

    // Exemplo de mÃ©todo para mapear Set<ClienteVeiculo> para Set<VeiculoResponseDto>
    // Este mÃ©todo pode ser um @Named ou um mÃ©todo privado na interface se for Java 8 default methods
    /*
    default Set<VeiculoResponseDto> mapClienteVeiculosToVeiculoResponseDtos(Set<br.com.fiap.mottu.model.relacionamento.ClienteVeiculo> clienteVeiculos) {
        if (clienteVeiculos == null) {
            return null;
        }
        // Assume que vocÃª tem um VeiculoMapper injetÃ¡vel para converter Veiculo para VeiculoResponseDto
        // Ou que o ClienteVeiculoMapper tem um mÃ©todo para mapear para VeiculoResponseDto
        return clienteVeiculos.stream()
                .map(ClienteVeiculo::getVeiculo) // Pega a entidade Veiculo da associaÃ§Ã£o
                .map(veiculo -> SpringApplicationContext.getBean(VeiculoMapper.class).toResponseDto(veiculo)) // Necessita de um mecanismo para obter o bean do mapper
                .collect(Collectors.toSet());
    }
    */

    // --- MÃ©todos para mapear coleÃ§Ãµes (opcional) ---
    // List<ClienteResponseDto> toResponseDtoList(List<Cliente> clientes);
    // Set<ClienteResponseDto> toResponseDtoSet(Set<Cliente> clientes);
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\mapper\ContatoMapper.java   |   package br.com.fiap.mottu.mapper   |   class ContatoMapper
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\mapper\ContatoMapper.java
package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.contato.ContatoRequestDto;
import br.com.fiap.mottu.dto.contato.ContatoResponseDto;
import br.com.fiap.mottu.model.Contato;

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

// Importe os mappers das entidades relacionadas se ContatoResponseDto tiver DTOs aninhados ou coleÃ§Ãµes de DTOs delas
// import br.com.fiap.mottu.mapper.ClienteMapper; // Exemplo se ContatoResponseDto incluir Cliente associado
// import br.com.fiap.mottu.mapper.relacionamento.ContatoPatioMapper; // Exemplo se ContatoResponseDto incluir Patio associado

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING
        // Adicione aqui o 'uses' se ContatoResponseDto incluir DTOs aninhados ou coleÃ§Ãµes
        // uses = { ClienteMapper.class, ContatoPatioMapper.class }
)
public interface ContatoMapper {

    // MÃ©todo 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    @Mapping(target = "idContato", ignore = true) // ID Ã© gerado pelo BD
    @Mapping(target = "clienteContatos", ignore = true) // Relacionamento inverso nÃ£o Ã© mapeado na criaÃ§Ã£o
    @Mapping(target = "contatoPatios", ignore = true) // Relacionamento inverso nÃ£o Ã© mapeado na criaÃ§Ã£o
    Contato toEntity(ContatoRequestDto contatoRequestDto);

    // MÃ©todo 2: AtualizaÃ§Ã£o de uma Entidade existente a partir de Request DTO
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idContato", ignore = true) // ID nÃ£o Ã© atualizado
    @Mapping(target = "clienteContatos", ignore = true) // Relacionamento inverso nÃ£o Ã© atualizado
    @Mapping(target = "contatoPatios", ignore = true) // Relacionamento inverso nÃ£o Ã© atualizado
    Contato partialUpdate(ContatoRequestDto contatoRequestDto, @MappingTarget Contato contato);

    // MÃ©todo 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    ContatoResponseDto toResponseDto(Contato contato);

    // --- MÃ©todos para mapear coleÃ§Ãµes (opcional) ---
    // List<ContatoResponseDto> toResponseDtoList(List<Contato> contatos);
    // Set<ContatoResponseDto> toResponseDtoSet(Set<Contato> contatos);
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\mapper\EnderecoMapper.java   |   package br.com.fiap.mottu.mapper   |   class EnderecoMapper
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\mapper\EnderecoMapper.java
package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.endereco.EnderecoRequestDto;
import br.com.fiap.mottu.dto.endereco.EnderecoResponseDto;
import br.com.fiap.mottu.model.Endereco;

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

// Importe os mappers das entidades relacionadas se EnderecoResponseDto tiver DTOs aninhados ou coleÃ§Ãµes de DTOs delas
// import br.com.fiap.mottu.mapper.ClienteMapper; // Exemplo se EnderecoResponseDto incluir Cliente associado
// import br.com.fiap.mottu.mapper.relacionamento.EnderecoPatioMapper; // Exemplo se EnderecoResponseDto incluir Patio associado

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING
        // Adicione aqui o 'uses' se EnderecoResponseDto incluir DTOs aninhados ou coleÃ§Ãµes
        // uses = { ClienteMapper.class, EnderecoPatioMapper.class }
)
public interface EnderecoMapper {

    // MÃ©todo 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    @Mapping(target = "idEndereco", ignore = true) // ID Ã© gerado pelo BD
    @Mapping(target = "clienteEnderecos", ignore = true) // Relacionamento inverso nÃ£o Ã© mapeado na criaÃ§Ã£o
    @Mapping(target = "enderecoPatios", ignore = true) // Relacionamento inverso nÃ£o Ã© mapeado na criaÃ§Ã£o
    Endereco toEntity(EnderecoRequestDto enderecoRequestDto);

    // MÃ©todo 2: AtualizaÃ§Ã£o de uma Entidade existente a partir de Request DTO
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idEndereco", ignore = true) // ID nÃ£o Ã© atualizado
    @Mapping(target = "clienteEnderecos", ignore = true) // Relacionamento inverso nÃ£o Ã© atualizado
    @Mapping(target = "enderecoPatios", ignore = true) // Relacionamento inverso nÃ£o Ã© atualizado
    Endereco partialUpdate(EnderecoRequestDto enderecoRequestDto, @MappingTarget Endereco endereco);

    // MÃ©todo 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    EnderecoResponseDto toResponseDto(Endereco endereco);

    // --- MÃ©todos para mapear coleÃ§Ãµes (opcional) ---
    // List<EnderecoResponseDto> toResponseDtoList(List<Endereco> enderecos);
    // Set<EnderecoResponseDto> toResponseDtoSet(Set<Endereco> enderecos);
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\mapper\PatioMapper.java   |   package br.com.fiap.mottu.mapper   |   class PatioMapper
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.patio.PatioRequestDto;
import br.com.fiap.mottu.dto.patio.PatioResponseDto;
import br.com.fiap.mottu.model.Patio;

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING,
        uses = {BoxMapper.class} // NOVO: Adicionar BoxMapper aqui
)
public interface PatioMapper {

    // MÃ©todo 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    @Mapping(target = "idPatio", ignore = true) // ID Ã© gerado pelo BD
    @Mapping(target = "contatoPatios", ignore = true) // Relacionamento inverso nÃ£o Ã© mapeado na criaÃ§Ã£o
    @Mapping(target = "enderecoPatios", ignore = true) // Relacionamento inverso nÃ£o Ã© mapeado na criaÃ§Ã£o
    @Mapping(target = "veiculoPatios", ignore = true) // Relacionamento inverso nÃ£o Ã© mapeado na criaÃ§Ã£o
    @Mapping(target = "zonaPatios", ignore = true) // Relacionamento inverso nÃ£o Ã© mapeado na criaÃ§Ã£o
    @Mapping(target = "patioBoxes", ignore = true) // NOVO: Ignorar coleÃ§Ã£o de relacionamento muitos-para-muitos
    Patio toEntity(PatioRequestDto patioRequestDto);

    // MÃ©todo 2: AtualizaÃ§Ã£o de uma Entidade existente a partir de Request DTO
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idPatio", ignore = true) // ID nÃ£o Ã© atualizado
    @Mapping(target = "contatoPatios", ignore = true) // Relacionamento inverso nÃ£o Ã© atualizado
    @Mapping(target = "enderecoPatios", ignore = true) // Relacionamento inverso nÃ£o Ã© atualizado
    @Mapping(target = "veiculoPatios", ignore = true) // Relacionamento inverso nÃ£o Ã© atualizado
    @Mapping(target = "zonaPatios", ignore = true) // Relacionamento inverso nÃ£o Ã© atualizado
    @Mapping(target = "patioBoxes", ignore = true) // NOVO: Ignorar coleÃ§Ã£o de relacionamento muitos-para-muitos
    Patio partialUpdate(PatioRequestDto patioRequestDto, @MappingTarget Patio patio);

    // MÃ©todo 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    PatioResponseDto toResponseDto(Patio patio);
    // List<PatioResponseDto> toResponseDtoList(List<Patio> patios);
    // Set<PatioResponseDto> toResponseDtoSet(Set<Patio> patios);
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\mapper\RastreamentoMapper.java   |   package br.com.fiap.mottu.mapper   |   class RastreamentoMapper
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.rastreamento.RastreamentoRequestDto;
import br.com.fiap.mottu.dto.rastreamento.RastreamentoResponseDto;
import br.com.fiap.mottu.model.Rastreamento;
import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

import java.math.BigDecimal; // Importe BigDecimal!

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING
)
public interface RastreamentoMapper {

    @Mapping(target = "idRastreamento", ignore = true)
    @Mapping(target = "veiculoRastreamentos", ignore = true)
    @Mapping(target = "ipsX", source = "ipsX")
    @Mapping(target = "ipsY", source = "ipsY")
    @Mapping(target = "ipsZ", source = "ipsZ")
    @Mapping(target = "gprsLatitude", source = "gprsLatitude")
    @Mapping(target = "gprsLongitude", source = "gprsLongitude")
    @Mapping(target = "gprsAltitude", source = "gprsAltitude")
    Rastreamento toEntity(RastreamentoRequestDto rastreamentoRequestDto);

    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idRastreamento", ignore = true)
    @Mapping(target = "veiculoRastreamentos", ignore = true)
    @Mapping(target = "ipsX", source = "ipsX")
    @Mapping(target = "ipsY", source = "ipsY")
    @Mapping(target = "ipsZ", source = "ipsZ")
    @Mapping(target = "gprsLatitude", source = "gprsLatitude")
    @Mapping(target = "gprsLongitude", source = "gprsLongitude")
    @Mapping(target = "gprsAltitude", source = "gprsAltitude")
    Rastreamento partialUpdate(RastreamentoRequestDto dto, @MappingTarget Rastreamento rastreamento);

    @Mapping(target = "ipsX", source = "ipsX")
    @Mapping(target = "ipsY", source = "ipsY")
    @Mapping(target = "ipsZ", source = "ipsZ")
    @Mapping(target = "gprsLatitude", source = "gprsLatitude")
    @Mapping(target = "gprsLongitude", source = "gprsLongitude")
    @Mapping(target = "gprsAltitude", source = "gprsAltitude")
    RastreamentoResponseDto toResponseDto(Rastreamento rastreamento);
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\mapper\VeiculoMapper.java   |   package br.com.fiap.mottu.mapper   |   class VeiculoMapper
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\mapper\VeiculoMapper.java
package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.veiculo.VeiculoRequestDto;
import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.mottu.model.Veiculo;

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

// Importe os mappers das entidades relacionadas se VeiculoRequestDto ou VeiculoResponseDto tiverem DTOs aninhados ou coleÃ§Ãµes de DTOs delas
// import br.com.fiap.mottu.mapper.relacionamento.ClienteVeiculoMapper;
// import br.com.fiap.mottu.mapper.relacionamento.VeiculoBoxMapper;
// import br.com.fiap.mottu.mapper.relacionamento.VeiculoPatioMapper;
// import br.com.fiap.mottu.mapper.relacionamento.VeiculoRastreamentoMapper;
// import br.com.fiap.mottu.mapper.relacionamento.VeiculoZonaMapper;

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING
        // Adicione aqui o 'uses' se VeiculoRequestDto ou VeiculoResponseDto incluirem DTOs aninhados ou coleÃ§Ãµes
        // uses = { ClienteVeiculoMapper.class, VeiculoBoxMapper.class, VeiculoPatioMapper.class, VeiculoRastreamentoMapper.class, VeiculoZonaMapper.class }
)
public interface VeiculoMapper {

    // MÃ©todo 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    @Mapping(target = "idVeiculo", ignore = true) // ID Ã© gerado pelo BD
    @Mapping(target = "clienteVeiculos", ignore = true) // Relacionamento inverso nÃ£o Ã© mapeado na criaÃ§Ã£o
    @Mapping(target = "veiculoBoxes", ignore = true) // Relacionamento inverso nÃ£o Ã© mapeado na criaÃ§Ã£o
    @Mapping(target = "veiculoPatios", ignore = true) // Relacionamento inverso nÃ£o Ã© mapeado na criaÃ§Ã£o
    @Mapping(target = "veiculoRastreamentos", ignore = true) // Relacionamento inverso nÃ£o Ã© mapeado na criaÃ§Ã£o
    @Mapping(target = "veiculoZonas", ignore = true) // Relacionamento inverso nÃ£o Ã© mapeado na criaÃ§Ã£o
    Veiculo toEntity(VeiculoRequestDto veiculoRequestDto);

    // MÃ©todo 2: AtualizaÃ§Ã£o de uma Entidade existente a partir de Request DTO
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idVeiculo", ignore = true) // ID nÃ£o Ã© atualizado
    @Mapping(target = "clienteVeiculos", ignore = true) // Relacionamento inverso nÃ£o Ã© atualizado
    @Mapping(target = "veiculoBoxes", ignore = true) // Relacionamento inverso nÃ£o Ã© atualizado
    @Mapping(target = "veiculoPatios", ignore = true) // Relacionamento inverso nÃ£o Ã© atualizado
    @Mapping(target = "veiculoRastreamentos", ignore = true) // Relacionamento inverso nÃ£o Ã© atualizado
    @Mapping(target = "veiculoZonas", ignore = true) // Relacionamento inverso nÃ£o Ã© atualizado
    Veiculo partialUpdate(VeiculoRequestDto veiculoRequestDto, @MappingTarget Veiculo veiculo);

    // MÃ©todo 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    VeiculoResponseDto toResponseDto(Veiculo veiculo);

    // --- MÃ©todos para mapear coleÃ§Ãµes (opcional) ---
    // List<VeiculoResponseDto> toResponseDtoList(List<Veiculo> veiculos);
    // Set<VeiculoResponseDto> toResponseDtoSet(Set<Veiculo> veiculos);
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\mapper\ZonaMapper.java   |   package br.com.fiap.mottu.mapper   |   class ZonaMapper
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\mapper\ZonaMapper.java
package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.zona.ZonaRequestDto;
import br.com.fiap.mottu.dto.zona.ZonaResponseDto;
import br.com.fiap.mottu.model.Zona;

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

// Importe os mappers das entidades relacionadas se ZonaRequestDto ou ZonaResponseDto tiverem DTOs aninhados ou coleÃ§Ãµes de DTOs delas
// import br.com.fiap.mottu.mapper.relacionamento.VeiculoZonaMapper;
// import br.com.fiap.mottu.mapper.relacionamento.ZonaBoxMapper;
// import br.com.fiap.mottu.mapper.relacionamento.ZonaPatioMapper;

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING
        // Adicione aqui o 'uses' se ZonaRequestDto ou ZonaResponseDto incluirem DTOs aninhados ou coleÃ§Ãµes
        // uses = { VeiculoZonaMapper.class, ZonaBoxMapper.class, ZonaPatioMapper.class }
)
public interface ZonaMapper {

    // MÃ©todo 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    @Mapping(target = "idZona", ignore = true) // ID Ã© gerado pelo BD
    @Mapping(target = "veiculoZonas", ignore = true) // Relacionamento inverso nÃ£o Ã© mapeado na criaÃ§Ã£o
    @Mapping(target = "zonaBoxes", ignore = true) // Relacionamento inverso nÃ£o Ã© mapeado na criaÃ§Ã£o
    @Mapping(target = "zonaPatios", ignore = true) // Relacionamento inverso nÃ£o Ã© mapeado na criaÃ§Ã£o
    Zona toEntity(ZonaRequestDto zonaRequestDto);

    // MÃ©todo 2: AtualizaÃ§Ã£o de uma Entidade existente a partir de Request DTO
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idZona", ignore = true) // ID nÃ£o Ã© atualizado
    @Mapping(target = "veiculoZonas", ignore = true) // Relacionamento inverso nÃ£o Ã© atualizado
    @Mapping(target = "zonaBoxes", ignore = true) // Relacionamento inverso nÃ£o Ã© atualizado
    @Mapping(target = "zonaPatios", ignore = true) // Relacionamento inverso nÃ£o Ã© atualizado
    Zona partialUpdate(ZonaRequestDto zonaRequestDto, @MappingTarget Zona zona);

    // MÃ©todo 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    ZonaResponseDto toResponseDto(Zona zona);

    // --- MÃ©todos para mapear coleÃ§Ãµes (opcional) ---
    // List<ZonaResponseDto> toResponseDtoList(List<Zona> zonas);
    // Set<ZonaResponseDto> toResponseDtoSet(Set<Zona> zonas);
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\Box.java   |   package br.com.fiap.mottu.model   |   class Box
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "TB_BOX", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido 'exclude = {...}'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Box {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_BOX")
    @EqualsAndHashCode.Include
    private Long idBox;

    @Column(name = "NOME", nullable = false, length = 50)
    private String nome;

    @Column(name = "STATUS", nullable = false, length = 1)
    private String status;

    @Column(name = "DATA_ENTRADA", nullable = false)
    private LocalDate dataEntrada;

    @Column(name = "DATA_SAIDA", nullable = false)
    private LocalDate dataSaida;

    @Column(name = "OBSERVACAO", length = 100)
    private String observacao;

    // Relacionamentos inversos para tabelas de junÃ§Ã£o
    @OneToMany(mappedBy = "box", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotaÃ§Ã£o jÃ¡ exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoBox> veiculoBoxes = new HashSet<>();

    @OneToMany(mappedBy = "box", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotaÃ§Ã£o jÃ¡ exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ZonaBox> zonaBoxes = new HashSet<>();

    // Relacionamento inverso para PatioBox
    @OneToMany(mappedBy = "box", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotaÃ§Ã£o jÃ¡ exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.PatioBox> patioBoxes = new HashSet<>();
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\Cliente.java   |   package br.com.fiap.mottu.model   |   class Cliente
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// main\java\br\com\fiap\mottu\model\Cliente.java
package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "TB_CLIENTE", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Cliente {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_CLIENTE")
    @EqualsAndHashCode.Include
    private Long idCliente;
    @Column(name = "DATA_CADASTRO", nullable = false, updatable = false)
    private LocalDate dataCadastro;

    @Column(name = "SEXO", nullable = false, length = 2) // Linha a ser restaurada para este estado
    private String sexo;
    @Column(name = "NOME", nullable = false, length = 100)
    private String nome;
    @Column(name = "SOBRENOME", nullable = false, length = 100)
    private String sobrenome;
    @Column(name = "DATA_NASCIMENTO", nullable = false)
    private LocalDate dataNascimento;
    @Column(name = "CPF", nullable = false, unique = true, length = 11) // Linha a ser restaurada para este estado
    private String cpf;
    @Column(name = "PROFISSAO", nullable = false, length = 50)
    private String profissao;
    @Column(name = "ESTADO_CIVIL", nullable = false, length = 50)
    private String estadoCivil;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "TB_ENDERECO_ID_ENDERECO", nullable = false)
    @ToString.Exclude
    private Endereco endereco;
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "TB_CONTATO_ID_CONTATO", nullable = false)
    @ToString.Exclude
    private Contato contato;
    @OneToMany(mappedBy = "cliente", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ClienteVeiculo> clienteVeiculos = new HashSet<>();
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\Contato.java   |   package br.com.fiap.mottu.model   |   class Contato
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// main\java\br\com\fiap\mottu\model\Contato.java
package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.util.HashSet;
import java.util.Set;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "TB_CONTATO", schema = "CHALLENGE")
@ToString // CORRIGIDO: Removido o parÃ¢metro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Contato {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_CONTATO")
    @EqualsAndHashCode.Include
    private Long idContato;
    @Column(name = "EMAIL", nullable = false, length = 100)
    private String email;
    @Column(name = "DDD", nullable = false, precision = 4, scale = 0)
    private Integer ddd;
    @Column(name = "DDI", nullable = false, precision = 4, scale = 0)
    private Integer ddi;
    @Column(name = "TELEFONE1", nullable = false, length = 20)
    private String telefone1;
    @Column(name = "TELEFONE2", length = 20)
    private String telefone2;
    @Column(name = "TELEFONE3", length = 20)
    private String telefone3;
    @Column(name = "CELULAR", nullable = false, length = 20)
    private String celular;
    @Column(name = "OUTRO", length = 100)
    private String outro;
    @Column(name = "OBSERVACAO", length = 200)
    private String observacao;

    @OneToMany(mappedBy = "contato", cascade = CascadeType.ALL)
    @ToString.Exclude // MANTER esta anotaÃ§Ã£o no campo
    @Builder.Default
    private Set<Cliente> clienteContatos = new HashSet<>();
    @OneToMany(mappedBy = "contato", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // MANTER esta anotaÃ§Ã£o no campo
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ContatoPatio> contatoPatios = new HashSet<>();
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\Endereco.java   |   package br.com.fiap.mottu.model   |   class Endereco
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// main\java\br\com\fiap\mottu\model\Endereco.java
package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.util.HashSet;
import java.util.Set;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "TB_ENDERECO", schema = "CHALLENGE")
@ToString
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Endereco {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_ENDERECO")
    @EqualsAndHashCode.Include
    private Long idEndereco;
    @Column(name = "CEP", nullable = false, length = 9) // Linha a ser restaurada para este estado
    private String cep;
    @Column(name = "NUMERO", nullable = false, precision = 7, scale = 0)
    private Integer numero;
    @Column(name = "LOGRADOURO", nullable = false, length = 50)
    private String logradouro;
    @Column(name = "BAIRRO", nullable = false, length = 50)
    private String bairro;
    @Column(name = "CIDADE", nullable = false, length = 50)
    private String cidade;
    @Column(name = "ESTADO", nullable = false, length = 2) // Linha a ser restaurada para este estado
    private String estado;
    @Column(name = "PAIS", nullable = false, length = 50)
    private String pais;
    @Column(name = "COMPLEMENTO", length = 60)
    private String complemento;
    @Column(name = "OBSERVACAO", length = 200)
    private String observacao;
    // Relacionamentos inversos
    @OneToMany(mappedBy = "endereco", cascade = CascadeType.ALL)
    @ToString.Exclude
    @Builder.Default
    private Set<Cliente> clienteEnderecos = new HashSet<>();
    @OneToMany(mappedBy = "endereco", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.EnderecoPatio> enderecoPatios = new HashSet<>();
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\Patio.java   |   package br.com.fiap.mottu.model   |   class Patio
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "TB_PATIO", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido 'exclude = {...}'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Patio {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_PATIO")
    @EqualsAndHashCode.Include
    private Long idPatio;

    @Column(name = "NOME_PATIO", nullable = false, length = 50)
    private String nomePatio;

    @Column(name = "DATA_ENTRADA", nullable = false)
    private LocalDate dataEntrada;

    @Column(name = "DATA_SAIDA", nullable = false)
    private LocalDate dataSaida;

    @Column(name = "OBSERVACAO", length = 100)
    private String observacao;

    @OneToMany(mappedBy = "patio", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotaÃ§Ã£o jÃ¡ exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ContatoPatio> contatoPatios = new HashSet<>();

    @OneToMany(mappedBy = "patio", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotaÃ§Ã£o jÃ¡ exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.EnderecoPatio> enderecoPatios = new HashSet<>();

    @OneToMany(mappedBy = "patio", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotaÃ§Ã£o jÃ¡ exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoPatio> veiculoPatios = new HashSet<>();

    @OneToMany(mappedBy = "patio", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotaÃ§Ã£o jÃ¡ exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ZonaPatio> zonaPatios = new HashSet<>();

    // Relacionamento inverso para PatioBox
    @OneToMany(mappedBy = "patio", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotaÃ§Ã£o jÃ¡ exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.PatioBox> patioBoxes = new HashSet<>();
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\Rastreamento.java   |   package br.com.fiap.mottu.model   |   class Rastreamento
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal; // Importe BigDecimal!
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "TB_RASTREAMENTO", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Rastreamento {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_RASTREAMENTO")
    @EqualsAndHashCode.Include
    private Long idRastreamento;

    // Campos para IPS com BigDecimal e precisÃ£o 7,3
    @Column(name = "IPS_X", nullable = false, precision = 7, scale = 3)
    private BigDecimal ipsX;

    @Column(name = "IPS_Y", nullable = false, precision = 7, scale = 3)
    private BigDecimal ipsY;

    @Column(name = "IPS_Z", nullable = false, precision = 7, scale = 3)
    private BigDecimal ipsZ;

    // Campos para GPRS com BigDecimal e precisÃ£o 11,6 (Latitude/Longitude) e 7,2 (Altitude)
    @Column(name = "GPRS_LATITUDE", nullable = false, precision = 11, scale = 6)
    private BigDecimal gprsLatitude;

    @Column(name = "GPRS_LONGITUDE", nullable = false, precision = 11, scale = 6)
    private BigDecimal gprsLongitude;

    @Column(name = "GPRS_ALTITUDE", nullable = false, precision = 7, scale = 2)
    private BigDecimal gprsAltitude;

    @OneToMany(mappedBy = "rastreamento", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoRastreamento> veiculoRastreamentos = new HashSet<>();
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\Veiculo.java   |   package br.com.fiap.mottu.model   |   class Veiculo
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// main\java\br\com\fiap\mottu\model\Veiculo.java
package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "TB_VEICULO", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Veiculo {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_VEICULO")
    @EqualsAndHashCode.Include
    private Long idVeiculo;
    @Column(name = "PLACA", nullable = false, unique = true, length = 10)
    private String placa;
    @Column(name = "RENAVAM", nullable = false, unique = true, length = 11) // Linha a ser restaurada para este estado
    private String renavam;
    @Column(name = "CHASSI", nullable = false, unique = true, length = 17) // Linha a ser restaurada para este estado
    private String chassi;
    @Column(name = "FABRICANTE", nullable = false, length = 50)
    private String fabricante;
    @Column(name = "MODELO", nullable = false, length = 60)
    private String modelo;
    @Column(name = "MOTOR", length = 30)
    private String motor;
    @Column(name = "ANO", nullable = false)
    private Integer ano;
    @Column(name = "COMBUSTIVEL", nullable = false, length = 20)
    private String combustivel;
    // Relacionamentos inversos
    @OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ClienteVeiculo> clienteVeiculos = new HashSet<>();
    @OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoBox> veiculoBoxes = new HashSet<>();
    @OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoPatio> veiculoPatios = new HashSet<>();
    @OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoRastreamento> veiculoRastreamentos = new HashSet<>();
    @OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoZona> veiculoZonas = new HashSet<>();
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\Zona.java   |   package br.com.fiap.mottu.model   |   class Zona
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// main\java\br\com\fiap\mottu\model\Zona.java
package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "TB_ZONA", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parÃ¢metro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Zona {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_ZONA")
    @EqualsAndHashCode.Include
    private Long idZona;
    @Column(name = "NOME", nullable = false, length = 50)
    private String nome;
    @Column(name = "DATA_ENTRADA", nullable = false)
    private LocalDate dataEntrada;
    @Column(name = "DATA_SAIDA", nullable = false)
    private LocalDate dataSaida;
    @Column(name = "OBSERVACAO", length = 100)
    private String observacao;

    @OneToMany(mappedBy = "zona", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // MANTER esta anotaÃ§Ã£o no campo
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoZona> veiculoZonas = new HashSet<>();
    @OneToMany(mappedBy = "zona", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // MANTER esta anotaÃ§Ã£o no campo
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ZonaBox> zonaBoxes = new HashSet<>();
    @OneToMany(mappedBy = "zona", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // MANTER esta anotaÃ§Ã£o no campo
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ZonaPatio> zonaPatios = new HashSet<>();
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\relacionamento\ClienteVeiculo.java   |   package br.com.fiap.mottu.model.relacionamento   |   class ClienteVeiculo
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// main\java\br\com\fiap\mottu\model\relacionamento\ClienteVeiculo.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Cliente;
import br.com.fiap.mottu.model.Veiculo;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_CLIENTEVEICULO", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parÃ¢metro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class ClienteVeiculo {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private ClienteVeiculoId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("clienteId")
    @JoinColumn(name = "TB_CLIENTE_ID_CLIENTE", referencedColumnName = "ID_CLIENTE", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotaÃ§Ã£o no campo
    private Cliente cliente;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("veiculoId")
    @JoinColumn(name = "TB_VEICULO_ID_VEICULO", referencedColumnName = "ID_VEICULO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotaÃ§Ã£o no campo
    private Veiculo veiculo;

    public ClienteVeiculo(Cliente cliente, Veiculo veiculo) {
        this.cliente = cliente;
        this.veiculo = veiculo;
        this.id = new ClienteVeiculoId(
                cliente.getIdCliente(),
                cliente.getEndereco() != null ? cliente.getEndereco().getIdEndereco() : null,
                cliente.getContato() != null ? cliente.getContato().getIdContato() : null,
                veiculo.getIdVeiculo()
        );
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\relacionamento\ClienteVeiculoId.java   |   package br.com.fiap.mottu.model.relacionamento   |   class ClienteVeiculoId
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\ClienteVeiculoId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode // Essencial para PKs compostas
public class ClienteVeiculoId implements Serializable {

    @Column(name = "TB_CLIENTE_ID_CLIENTE", nullable = false)
    private Long clienteId;

    @Column(name = "TB_CLIENTE_TB_ENDERECO_ID_ENDERECO", nullable = false)
    private Long clienteEnderecoId;

    @Column(name = "TB_CLIENTE_TB_CONTATO_ID_CONTATO", nullable = false)
    private Long clienteContatoId;

    @Column(name = "TB_VEICULO_ID_VEICULO", nullable = false)
    private Long veiculoId;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\relacionamento\ContatoPatio.java   |   package br.com.fiap.mottu.model.relacionamento   |   class ContatoPatio
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// main\java\br\com\fiap\mottu\model\relacionamento\ContatoPatio.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Contato;
import br.com.fiap.mottu.model.Patio;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_CONTATOPATIO", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parÃ¢metro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class ContatoPatio {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private ContatoPatioId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("patioId")
    @JoinColumn(name = "TB_PATIO_ID_PATIO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotaÃ§Ã£o no campo
    private Patio patio;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("contatoId")
    @JoinColumn(name = "TB_CONTATO_ID_CONTATO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotaÃ§Ã£o no campo
    private Contato contato;

    public ContatoPatio(Patio patio, Contato contato) {
        this.patio = patio;
        this.contato = contato;
        this.id = new ContatoPatioId(patio.getIdPatio(), contato.getIdContato());
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\relacionamento\ContatoPatioId.java   |   package br.com.fiap.mottu.model.relacionamento   |   class ContatoPatioId
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\ContatoPatioId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class ContatoPatioId implements Serializable {

    @Column(name = "TB_PATIO_ID_PATIO", nullable = false)
    private Long patioId;

    @Column(name = "TB_CONTATO_ID_CONTATO", nullable = false)
    private Long contatoId;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\relacionamento\EnderecoPatio.java   |   package br.com.fiap.mottu.model.relacionamento   |   class EnderecoPatio
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// main\java\br\com\fiap\mottu\model\relacionamento\EnderecoPatio.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Endereco;
import br.com.fiap.mottu.model.Patio;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_ENDERECIOPATIO", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parÃ¢metro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class EnderecoPatio {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private EnderecoPatioId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("enderecoId")
    @JoinColumn(name = "TB_ENDERECO_ID_ENDERECO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotaÃ§Ã£o no campo
    private Endereco endereco;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("patioId")
    @JoinColumn(name = "TB_PATIO_ID_PATIO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotaÃ§Ã£o no campo
    private Patio patio;

    public EnderecoPatio(Endereco endereco, Patio patio) {
        this.endereco = endereco;
        this.patio = patio;
        this.id = new EnderecoPatioId(endereco.getIdEndereco(), patio.getIdPatio());
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\relacionamento\EnderecoPatioId.java   |   package br.com.fiap.mottu.model.relacionamento   |   class EnderecoPatioId
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\EnderecoPatioId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class EnderecoPatioId implements Serializable {

    @Column(name = "TB_ENDERECO_ID_ENDERECO", nullable = false)
    private Long enderecoId;

    @Column(name = "TB_PATIO_ID_PATIO", nullable = false)
    private Long patioId;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\relacionamento\PatioBox.java   |   package br.com.fiap.mottu.model.relacionamento   |   class PatioBox
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Patio;
import br.com.fiap.mottu.model.Box;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_PATIOBOX", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor // NOVO: Adicione esta anotaÃ§Ã£o para que Lombok gere um construtor com todos os campos.
@Builder
@ToString
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class PatioBox {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private PatioBoxId id;

    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("patioId") // Mapeia o campo 'patioId' da chave composta
    @JoinColumn(name = "TB_PATIO_ID_PATIO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude
    private Patio patio;

    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("boxId") // Mapeia o campo 'boxId' da chave composta
    @JoinColumn(name = "TB_BOX_ID_BOX", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude
    private Box box;

    // Construtor para facilitar a criaÃ§Ã£o da associaÃ§Ã£o (este construtor Ã© mantido, Lombok gerarÃ¡ o @AllArgsConstructor tambÃ©m)
    public PatioBox(Patio patio, Box box) {
        this.patio = patio;
        this.box = box;
        // Garanta que getIdBox() existe na sua classe Box ou use o nome correto do getter do ID do Box
        this.id = new PatioBoxId(patio.getIdPatio(), box.getIdBox());
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\relacionamento\PatioBoxId.java   |   package br.com.fiap.mottu.model.relacionamento   |   class PatioBoxId
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode // Essencial para PKs compostas
public class PatioBoxId implements Serializable {

    @Column(name = "TB_PATIO_ID_PATIO", nullable = false)
    private Long patioId;

    @Column(name = "TB_BOX_ID_BOX", nullable = false)
    private Long boxId;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoBox.java   |   package br.com.fiap.mottu.model.relacionamento   |   class VeiculoBox
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoBox.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Box;
import br.com.fiap.mottu.model.Veiculo;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_VEICULOBOX", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parÃ¢metro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class VeiculoBox {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private VeiculoBoxId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("veiculoId")
    @JoinColumn(name = "TB_VEICULO_ID_VEICULO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotaÃ§Ã£o no campo
    private Veiculo veiculo;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("boxId")
    @JoinColumn(name = "TB_BOX_ID_BOX", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotaÃ§Ã£o no campo
    private Box box;

    public VeiculoBox(Veiculo veiculo, Box box) {
        this.veiculo = veiculo;
        this.box = box;
        this.id = new VeiculoBoxId(veiculo.getIdVeiculo(), box.getIdBox());
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoBoxId.java   |   package br.com.fiap.mottu.model.relacionamento   |   class VeiculoBoxId
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\VeiculoBoxId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class VeiculoBoxId implements Serializable {

    @Column(name = "TB_VEICULO_ID_VEICULO", nullable = false)
    private Long veiculoId;

    @Column(name = "TB_BOX_ID_BOX", nullable = false)
    private Long boxId;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoPatio.java   |   package br.com.fiap.mottu.model.relacionamento   |   class VeiculoPatio
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoPatio.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Patio;
import br.com.fiap.mottu.model.Veiculo;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_VEICULOPATIO", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parÃ¢metro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class VeiculoPatio {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private VeiculoPatioId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("veiculoId")
    @JoinColumn(name = "TB_VEICULO_ID_VEICULO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotaÃ§Ã£o no campo
    private Veiculo veiculo;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("patioId")
    @JoinColumn(name = "TB_PATIO_ID_PATIO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotaÃ§Ã£o no campo
    private Patio patio;

    public VeiculoPatio(Veiculo veiculo, Patio patio) {
        this.veiculo = veiculo;
        this.patio = patio;
        this.id = new VeiculoPatioId(veiculo.getIdVeiculo(), patio.getIdPatio());
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoPatioId.java   |   package br.com.fiap.mottu.model.relacionamento   |   class VeiculoPatioId
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\VeiculoPatioId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class VeiculoPatioId implements Serializable {

    @Column(name = "TB_VEICULO_ID_VEICULO", nullable = false)
    private Long veiculoId;

    @Column(name = "TB_PATIO_ID_PATIO", nullable = false)
    private Long patioId;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoRastreamento.java   |   package br.com.fiap.mottu.model.relacionamento   |   class VeiculoRastreamento
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoRastreamento.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Rastreamento;
import br.com.fiap.mottu.model.Veiculo;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_VEICULORASTREAMENTO", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parÃ¢metro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class VeiculoRastreamento {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private VeiculoRastreamentoId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("veiculoId")
    @JoinColumn(name = "TB_VEICULO_ID_VEICULO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotaÃ§Ã£o no campo
    private Veiculo veiculo;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("rastreamentoId")
    @JoinColumn(name = "TB_RASTREAMENTO_ID_RASTREAMENTO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotaÃ§Ã£o no campo
    private Rastreamento rastreamento;

    public VeiculoRastreamento(Veiculo veiculo, Rastreamento rastreamento) {
        this.veiculo = veiculo;
        this.rastreamento = rastreamento;
        this.id = new VeiculoRastreamentoId(veiculo.getIdVeiculo(), rastreamento.getIdRastreamento());
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoRastreamentoId.java   |   package br.com.fiap.mottu.model.relacionamento   |   class VeiculoRastreamentoId
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\VeiculoRastreamentoId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class VeiculoRastreamentoId implements Serializable {

    @Column(name = "TB_VEICULO_ID_VEICULO", nullable = false)
    private Long veiculoId;

    @Column(name = "TB_RASTREAMENTO_ID_RASTREAMENTO", nullable = false)
    private Long rastreamentoId;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoZona.java   |   package br.com.fiap.mottu.model.relacionamento   |   class VeiculoZona
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoZona.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Veiculo;
import br.com.fiap.mottu.model.Zona;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_VEICULOZONA", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parÃ¢metro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class VeiculoZona {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private VeiculoZonaId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("veiculoId")
    @JoinColumn(name = "TB_VEICULO_ID_VEICULO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotaÃ§Ã£o no campo
    private Veiculo veiculo;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("zonaId")
    @JoinColumn(name = "TB_ZONA_ID_ZONA", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotaÃ§Ã£o no campo
    private Zona zona;

    public VeiculoZona(Veiculo veiculo, Zona zona) {
        this.veiculo = veiculo;
        this.zona = zona;
        this.id = new VeiculoZonaId(veiculo.getIdVeiculo(), zona.getIdZona());
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoZonaId.java   |   package br.com.fiap.mottu.model.relacionamento   |   class VeiculoZonaId
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\VeiculoZonaId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class VeiculoZonaId implements Serializable {

    @Column(name = "TB_VEICULO_ID_VEICULO", nullable = false)
    private Long veiculoId;

    @Column(name = "TB_ZONA_ID_ZONA", nullable = false)
    private Long zonaId;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\relacionamento\ZonaBox.java   |   package br.com.fiap.mottu.model.relacionamento   |   class ZonaBox
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// main\java\br\com\fiap\mottu\model\relacionamento\ZonaBox.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Box;
import br.com.fiap.mottu.model.Zona;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_ZONABOX", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parÃ¢metro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class ZonaBox {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private ZonaBoxId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("zonaId")
    @JoinColumn(name = "TB_ZONA_ID_ZONA", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotaÃ§Ã£o no campo
    private Zona zona;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("boxId")
    @JoinColumn(name = "TB_BOX_ID_BOX", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotaÃ§Ã£o no campo
    private Box box;

    public ZonaBox(Zona zona, Box box) {
        this.zona = zona;
        this.box = box;
        this.id = new ZonaBoxId(zona.getIdZona(), box.getIdBox());
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\relacionamento\ZonaBoxId.java   |   package br.com.fiap.mottu.model.relacionamento   |   class ZonaBoxId
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\ZonaBoxId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class ZonaBoxId implements Serializable {

    @Column(name = "TB_ZONA_ID_ZONA", nullable = false)
    private Long zonaId;

    @Column(name = "TB_BOX_ID_BOX", nullable = false)
    private Long boxId;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\relacionamento\ZonaPatio.java   |   package br.com.fiap.mottu.model.relacionamento   |   class ZonaPatio
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// main\java\br\com\fiap\mottu\model\relacionamento\ZonaPatio.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Patio;
import br.com.fiap.mottu.model.Zona;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_ZONAPATIO", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parÃ¢metro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class ZonaPatio {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private ZonaPatioId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("patioId")
    @JoinColumn(name = "TB_PATIO_ID_PATIO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotaÃ§Ã£o no campo
    private Patio patio;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("zonaId")
    @JoinColumn(name = "TB_ZONA_ID_ZONA", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotaÃ§Ã£o no campo
    private Zona zona;

    public ZonaPatio(Patio patio, Zona zona) {
        this.patio = patio;
        this.zona = zona;
        this.id = new ZonaPatioId(patio.getIdPatio(), zona.getIdZona());
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\model\relacionamento\ZonaPatioId.java   |   package br.com.fiap.mottu.model.relacionamento   |   class ZonaPatioId
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\ZonaPatioId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class ZonaPatioId implements Serializable {

    @Column(name = "TB_PATIO_ID_PATIO", nullable = false)
    private Long patioId;

    @Column(name = "TB_ZONA_ID_ZONA", nullable = false)
    private Long zonaId;
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\repository\BoxRepository.java   |   package br.com.fiap.mottu.repository   |   class BoxRepository
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\repository\BoxRepository.java
package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Box;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface BoxRepository extends JpaRepository<Box, Long>, JpaSpecificationExecutor<Box> {
    Optional<Box> findById(Long idBox); // JÃ¡ disponÃ­vel, mas explicitando
    List<Box> findByNomeContainingIgnoreCase(String nome); // Mantido para buscas parciais se necessÃ¡rio
    Optional<Box> findByNomeIgnoreCase(String nome); // ADICIONADO para checagem de duplicidade exata
    boolean existsByNomeIgnoreCase(String nome); // ADICIONADO como alternativa para checagem de duplicidade
    List<Box> findByDataEntradaBetween(LocalDate startDate, LocalDate endDate);
    List<Box> findByDataSaidaBetween(LocalDate startDate, LocalDate endDate);
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\repository\ClienteRepository.java   |   package br.com.fiap.mottu.repository   |   class ClienteRepository
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\repository\ClienteRepository.java
package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Cliente;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface ClienteRepository extends JpaRepository<Cliente, Long>, JpaSpecificationExecutor<Cliente> {
    // MÃ©todos de pesquisa avanÃ§ada (derivados):
    // Cliente: cpf, id, nome, data de cadastro
    Optional<Cliente> findByCpf(String cpf);
    Optional<Cliente> findById(Long idCliente); // JÃ¡ disponÃ­vel, mas explicitando
    List<Cliente> findByNomeContainingIgnoreCase(String nome);
    List<Cliente> findByDataCadastroBetween(LocalDate startDate, LocalDate endDate);
    // VocÃª tambÃ©m pode combinar:
    // Optional<Cliente> findByCpfAndNomeContainingIgnoreCase(String cpf, String nome);
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\repository\ContatoRepository.java   |   package br.com.fiap.mottu.repository   |   class ContatoRepository
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\repository\ContatoRepository.java
package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Contato;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.List;

@Repository
public interface ContatoRepository extends JpaRepository<Contato, Long>, JpaSpecificationExecutor<Contato> {
    // VocÃª pode adicionar mÃ©todos de busca por email, telefone, etc.
    Optional<Contato> findByEmail(String email);
    List<Contato> findByCelularContaining(String celular); // Exemplo de busca parcial por celular
    List<Contato> findByDddAndTelefone1(Integer ddd, String telefone1); // Exemplo de combinaÃ§Ã£o
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\repository\EnderecoRepository.java   |   package br.com.fiap.mottu.repository   |   class EnderecoRepository
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\repository\EnderecoRepository.java
package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Endereco;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.List;

@Repository
public interface EnderecoRepository extends JpaRepository<Endereco, Long>, JpaSpecificationExecutor<Endereco> {
    // MÃ©todos de pesquisa avanÃ§ada (derivados):
    Optional<Endereco> findByCep(String cep);
    List<Endereco> findByCidadeContainingIgnoreCase(String cidade);
    List<Endereco> findByEstado(String estado);
    List<Endereco> findByLogradouroContainingIgnoreCase(String logradouro);
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\repository\PatioRepository.java   |   package br.com.fiap.mottu.repository   |   class PatioRepository
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\repository\PatioRepository.java
package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Patio;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface PatioRepository extends JpaRepository<Patio, Long>, JpaSpecificationExecutor<Patio> {
    Optional<Patio> findById(Long idPatio); // JÃ¡ disponÃ­vel, mas explicitando
    List<Patio> findByNomePatioContainingIgnoreCase(String nomePatio); // Mantido para buscas parciais
    Optional<Patio> findByNomePatioIgnoreCase(String nomePatio); // ADICIONADO para checagem de duplicidade exata
    boolean existsByNomePatioIgnoreCase(String nomePatio); // ADICIONADO como alternativa
    List<Patio> findByDataEntradaBetween(LocalDate startDate, LocalDate endDate);
    List<Patio> findByDataSaidaBetween(LocalDate startDate, LocalDate endDate);
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\repository\RastreamentoRepository.java   |   package br.com.fiap.mottu.repository   |   class RastreamentoRepository
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Rastreamento;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;
import java.util.Optional;
import java.util.List;

@Repository
public interface RastreamentoRepository extends JpaRepository<Rastreamento, Long>, JpaSpecificationExecutor<Rastreamento> {
    Optional<Rastreamento> findById(Long idRastreamento);
    // JÃ¡ disponÃ­vel

    // Remova os mÃ©todos abaixo:
    // List<Rastreamento> findByIpsContainingIgnoreCase(String ips);
    // List<Rastreamento> findByGprsContainingIgnoreCase(String gprs);
    // Optional<Rastreamento> findByIpsIgnoreCase(String ips);
    // Optional<Rastreamento> findByGprsIgnoreCase(String gprs);
    // boolean existsByIpsIgnoreCase(String ips);
    // boolean existsByGprsIgnoreCase(String gprs);

    // VocÃª pode adicionar mÃ©todos de busca por coordenadas especÃ­ficas, se precisar
    // Por exemplo:
    // Optional<Rastreamento> findByIpsXAndIpsYAndIpsZ(Double ipsX, Double ipsY, Double ipsZ);
    // List<Rastreamento> findByGprsLatitudeBetweenAndGprsLongitudeBetween(Double minLat, Double maxLat, Double minLong, Double maxLong);
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\repository\VeiculoRepository.java   |   package br.com.fiap.mottu.repository   |   class VeiculoRepository
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\repository\VeiculoRepository.java
package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Veiculo;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.List;

@Repository
public interface VeiculoRepository extends JpaRepository<Veiculo, Long>, JpaSpecificationExecutor<Veiculo> {
    // MÃ©todos de pesquisa avanÃ§ada (derivados):
    // Veiculo: placa, id, renavam, chassi, modelo, fabricante, ano, combustivel
    Optional<Veiculo> findByPlaca(String placa);
    Optional<Veiculo> findById(Long idVeiculo); // JÃ¡ disponÃ­vel, mas explicitando
    Optional<Veiculo> findByRenavam(String renavam);
    Optional<Veiculo> findByChassi(String chassi);
    List<Veiculo> findByModeloContainingIgnoreCase(String modelo);
    List<Veiculo> findByFabricanteContainingIgnoreCase(String fabricante);
    List<Veiculo> findByAno(Integer ano); // Busca exata por ano
    List<Veiculo> findByAnoBetween(Integer startAno, Integer endAno); // Busca por intervalo de ano
    List<Veiculo> findByCombustivelContainingIgnoreCase(String combustivel);
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\repository\ZonaRepository.java   |   package br.com.fiap.mottu.repository   |   class ZonaRepository
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\repository\ZonaRepository.java
package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Zona;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface ZonaRepository extends JpaRepository<Zona, Long>, JpaSpecificationExecutor<Zona> {
    Optional<Zona> findById(Long idZona); // JÃ¡ disponÃ­vel, mas explicitando
    List<Zona> findByNomeContainingIgnoreCase(String nome); // Mantido para buscas parciais
    Optional<Zona> findByNomeIgnoreCase(String nome); // ADICIONADO para checagem de duplicidade exata
    boolean existsByNomeIgnoreCase(String nome); // ADICIONADO como alternativa
    List<Zona> findByDataEntradaBetween(LocalDate startDate, LocalDate endDate);
    List<Zona> findByDataSaidaBetween(LocalDate startDate, LocalDate endDate);
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\repository\relacionamento\ClienteVeiculoRepository.java   |   package br.com.fiap.mottu.repository.relacionamento   |   class ClienteVeiculoRepository
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\ClienteVeiculoRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.ClienteVeiculo;
import br.com.fiap.mottu.model.relacionamento.ClienteVeiculoId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ClienteVeiculoRepository extends JpaRepository<ClienteVeiculo, ClienteVeiculoId>, JpaSpecificationExecutor<ClienteVeiculo> {
    // MÃ©todos customizados podem ser Ãºteis aqui
    List<ClienteVeiculo> findById_ClienteId(Long clienteId);
    List<ClienteVeiculo> findById_VeiculoId(Long veiculoId);
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\repository\relacionamento\ContatoPatioRepository.java   |   package br.com.fiap.mottu.repository.relacionamento   |   class ContatoPatioRepository
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\ContatoPatioRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.ContatoPatio;
import br.com.fiap.mottu.model.relacionamento.ContatoPatioId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface ContatoPatioRepository extends JpaRepository<ContatoPatio, ContatoPatioId>, JpaSpecificationExecutor<ContatoPatio> {
    // Adicione mÃ©todos de busca especÃ­ficos se precisar
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\repository\relacionamento\EnderecoPatioRepository.java   |   package br.com.fiap.mottu.repository.relacionamento   |   class EnderecoPatioRepository
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\EnderecoPatioRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.EnderecoPatio;
import br.com.fiap.mottu.model.relacionamento.EnderecoPatioId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface EnderecoPatioRepository extends JpaRepository<EnderecoPatio, EnderecoPatioId>, JpaSpecificationExecutor<EnderecoPatio> {
    // Adicione mÃ©todos de busca especÃ­ficos se precisar
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\repository\relacionamento\PatioBoxRepository.java   |   package br.com.fiap.mottu.repository.relacionamento   |   class PatioBoxRepository
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.PatioBox;
import br.com.fiap.mottu.model.relacionamento.PatioBoxId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface PatioBoxRepository extends JpaRepository<PatioBox, PatioBoxId>, JpaSpecificationExecutor<PatioBox> {
    // MÃ©todos customizados podem ser adicionados aqui se necessÃ¡rio
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\repository\relacionamento\VeiculoBoxRepository.java   |   package br.com.fiap.mottu.repository.relacionamento   |   class VeiculoBoxRepository
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\VeiculoBoxRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.VeiculoBox;
import br.com.fiap.mottu.model.relacionamento.VeiculoBoxId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface VeiculoBoxRepository extends JpaRepository<VeiculoBox, VeiculoBoxId>, JpaSpecificationExecutor<VeiculoBox> {
    // Adicione mÃ©todos de busca especÃ­ficos se precisar
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\repository\relacionamento\VeiculoPatioRepository.java   |   package br.com.fiap.mottu.repository.relacionamento   |   class VeiculoPatioRepository
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\VeiculoPatioRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.VeiculoPatio;
import br.com.fiap.mottu.model.relacionamento.VeiculoPatioId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface VeiculoPatioRepository extends JpaRepository<VeiculoPatio, VeiculoPatioId>, JpaSpecificationExecutor<VeiculoPatio> {
    // Adicione mÃ©todos de busca especÃ­ficos se precisar
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\repository\relacionamento\VeiculoRastreamentoRepository.java   |   package br.com.fiap.mottu.repository.relacionamento   |   class VeiculoRastreamentoRepository
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\VeiculoRastreamentoRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.VeiculoRastreamento;
import br.com.fiap.mottu.model.relacionamento.VeiculoRastreamentoId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface VeiculoRastreamentoRepository extends JpaRepository<VeiculoRastreamento, VeiculoRastreamentoId>, JpaSpecificationExecutor<VeiculoRastreamento> {
    // Adicione mÃ©todos de busca especÃ­ficos se precisar
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\repository\relacionamento\VeiculoZonaRepository.java   |   package br.com.fiap.mottu.repository.relacionamento   |   class VeiculoZonaRepository
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\VeiculoZonaRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.VeiculoZona;
import br.com.fiap.mottu.model.relacionamento.VeiculoZonaId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface VeiculoZonaRepository extends JpaRepository<VeiculoZona, VeiculoZonaId>, JpaSpecificationExecutor<VeiculoZona> {
    // Adicione mÃ©todos de busca especÃ­ficos se precisar
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\repository\relacionamento\ZonaBoxRepository.java   |   package br.com.fiap.mottu.repository.relacionamento   |   class ZonaBoxRepository
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\ZonaBoxRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.ZonaBox;
import br.com.fiap.mottu.model.relacionamento.ZonaBoxId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface ZonaBoxRepository extends JpaRepository<ZonaBox, ZonaBoxId>, JpaSpecificationExecutor<ZonaBox> {
    // Adicione mÃ©todos de busca especÃ­ficos se precisar
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\repository\relacionamento\ZonaPatioRepository.java   |   package br.com.fiap.mottu.repository.relacionamento   |   class ZonaPatioRepository
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\ZonaPatioRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.ZonaPatio;
import br.com.fiap.mottu.model.relacionamento.ZonaPatioId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface ZonaPatioRepository extends JpaRepository<ZonaPatio, ZonaPatioId>, JpaSpecificationExecutor<ZonaPatio> {
    // Adicione mÃ©todos de busca especÃ­ficos se precisar
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\service\BoxService.java   |   package br.com.fiap.mottu.service   |   class BoxService
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.box.BoxRequestDto;
import br.com.fiap.mottu.filter.BoxFilter;
import br.com.fiap.mottu.mapper.BoxMapper;
import br.com.fiap.mottu.model.Box;
import br.com.fiap.mottu.repository.BoxRepository;
import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;
import br.com.fiap.mottu.specification.BoxSpecification;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;

@Service
public class BoxService {

    private final BoxRepository boxRepository;
    private final BoxMapper boxMapper;

    @Autowired
    public BoxService(BoxRepository boxRepository, BoxMapper boxMapper) {
        this.boxRepository = boxRepository;
        this.boxMapper = boxMapper;
    }

    public List<Box> listarTodosBoxes() {
        return boxRepository.findAll();
    }

    public Box buscarBoxPorId(Long id) {
        return boxRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Box", id));
    }

    public List<Box> buscarBoxesPorFiltro(BoxFilter filter) {
        return boxRepository.findAll(BoxSpecification.withFilters(filter));
    }

    @Transactional
    public Box criarBox(BoxRequestDto boxRequestDto) {
        // Evita duplicaÃ§Ã£o de nome
        String nome = boxRequestDto.getNome();
        if (boxRepository.findByNomeContainingIgnoreCase(nome)
                .stream().anyMatch(b -> b.getNome().equalsIgnoreCase(nome))) {
            throw new DuplicatedResourceException("Box", "nome", nome);
        }
        Box box = boxMapper.toEntity(boxRequestDto);
        return boxRepository.save(box);
    }

    @Transactional
    public Box atualizarBox(Long id, BoxRequestDto boxRequestDto) {
        return boxRepository.findById(id)
                .map(boxExistente -> {
                    String novoNome = boxRequestDto.getNome();
                    if (novoNome != null
                            && !novoNome.isBlank()
                            && !novoNome.equalsIgnoreCase(boxExistente.getNome())
                            && boxRepository.findByNomeContainingIgnoreCase(novoNome)
                            .stream().anyMatch(b -> b.getNome().equalsIgnoreCase(novoNome))) {
                        throw new DuplicatedResourceException("Box", "nome", novoNome);
                    }
                    boxMapper.partialUpdate(boxRequestDto, boxExistente);
                    return boxRepository.save(boxExistente);
                })
                .orElseThrow(() -> new ResourceNotFoundException("Box", id));
    }

    @Transactional
    public void deletarBox(Long id) {
        if (!boxRepository.existsById(id)) {
            throw new ResourceNotFoundException("Box", id);
        }
        boxRepository.deleteById(id);
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\service\ClienteService.java   |   package br.com.fiap.mottu.service   |   class ClienteService
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// br/com/fiap/mottu/service/ClienteService.java
package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.cliente.ClienteRequestDto;
import br.com.fiap.mottu.dto.endereco.EnderecoRequestDto;
import br.com.fiap.mottu.dto.contato.ContatoRequestDto;
import br.com.fiap.mottu.filter.ClienteFilter;
import br.com.fiap.mottu.model.Cliente;
import br.com.fiap.mottu.model.Contato;
import br.com.fiap.mottu.model.Endereco;
import br.com.fiap.mottu.model.Veiculo;
import br.com.fiap.mottu.model.relacionamento.ClienteVeiculo;
import br.com.fiap.mottu.model.relacionamento.ClienteVeiculoId;
import br.com.fiap.mottu.repository.ClienteRepository;
import br.com.fiap.mottu.repository.relacionamento.ClienteVeiculoRepository;
import br.com.fiap.mottu.repository.ContatoRepository;
import br.com.fiap.mottu.repository.EnderecoRepository;
import br.com.fiap.mottu.repository.VeiculoRepository;
import br.com.fiap.mottu.specification.ClienteSpecification;
import br.com.fiap.mottu.exception.ResourceNotFoundException;
import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.InvalidInputException;
import br.com.fiap.mottu.mapper.ClienteMapper;
import br.com.fiap.mottu.mapper.ContatoMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import reactor.core.publisher.Mono;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class ClienteService {

    private final ClienteRepository clienteRepository;
    private final EnderecoRepository enderecoRepository;
    private final ContatoRepository contatoRepository;
    private final VeiculoRepository veiculoRepository;
    private final ClienteVeiculoRepository clienteVeiculoRepository;
    private final EnderecoService enderecoService;
    private final ClienteMapper clienteMapper;
    private final ContatoMapper contatoMapper;

    @Autowired
    public ClienteService(
            ClienteRepository clienteRepository,
            EnderecoRepository enderecoRepository,
            ContatoRepository contatoRepository,
            VeiculoRepository veiculoRepository,
            ClienteVeiculoRepository clienteVeiculoRepository,
            EnderecoService enderecoService,
            ClienteMapper clienteMapper,
            ContatoMapper contatoMapper
    ) {
        this.clienteRepository = clienteRepository;
        this.enderecoRepository = enderecoRepository;
        this.contatoRepository = contatoRepository;
        this.veiculoRepository = veiculoRepository;
        this.clienteVeiculoRepository = clienteVeiculoRepository;
        this.enderecoService = enderecoService;
        this.clienteMapper = clienteMapper;
        this.contatoMapper = contatoMapper;
    }

    public List<Cliente> listarTodosClientes() {
        return clienteRepository.findAll();
    }

    public Cliente buscarClientePorId(Long id) {
        return clienteRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Cliente", id));
    }

    public List<Cliente> buscarClientesPorFiltro(ClienteFilter filter) {
        return clienteRepository.findAll(ClienteSpecification.withFilters(filter));
    }

    @Transactional
    public Mono<Cliente> criarCliente(ClienteRequestDto dto) {
        if (clienteRepository.findByCpf(dto.getCpf()).isPresent()) {
            return Mono.error(new DuplicatedResourceException("Cliente", "CPF", dto.getCpf()));
        }

        Mono<Endereco> enderecoMono = (dto.getEnderecoRequestDto().getIdEndereco() != null)
                ? Mono.justOrEmpty(enderecoRepository.findById(dto.getEnderecoRequestDto().getIdEndereco()))
                .switchIfEmpty(Mono.error(new ResourceNotFoundException("EndereÃ§o", dto.getEnderecoRequestDto().getIdEndereco())))
                : enderecoService.criarEndereco(dto.getEnderecoRequestDto());

        Mono<Contato> contatoMono = (dto.getContatoRequestDto().getIdContato() != null)
                ? Mono.justOrEmpty(contatoRepository.findById(dto.getContatoRequestDto().getIdContato()))
                .switchIfEmpty(Mono.error(new ResourceNotFoundException("Contato", dto.getContatoRequestDto().getIdContato())))
                : Mono.just(contatoRepository.save(contatoMapper.toEntity(dto.getContatoRequestDto())));

        return Mono.zip(enderecoMono, contatoMono)
                .flatMap(tuple -> {
                    Cliente cliente = clienteMapper.toEntity(dto);
                    cliente.setEndereco(tuple.getT1());
                    cliente.setContato(tuple.getT2());
                    return Mono.just(clienteRepository.save(cliente));
                })
                .onErrorResume(e -> {
                    if (e instanceof ResourceNotFoundException
                            || e instanceof DuplicatedResourceException
                            || e instanceof InvalidInputException) {
                        return Mono.error(e);
                    }
                    return Mono.error(new InvalidInputException("Erro inesperado ao criar cliente: " + e.getMessage()));
                });
    }

    @Transactional
    public Mono<Cliente> atualizarCliente(Long id, ClienteRequestDto dto) {
        return Mono.justOrEmpty(clienteRepository.findById(id))
                .switchIfEmpty(Mono.error(new ResourceNotFoundException("Cliente", id)))
                .flatMap(clienteExistente -> {
                    if (dto.getCpf() != null
                            && !dto.getCpf().equals(clienteExistente.getCpf())
                            && clienteRepository.findByCpf(dto.getCpf()).isPresent()) {
                        return Mono.error(new DuplicatedResourceException("Cliente", "CPF", dto.getCpf()));
                    }

                    clienteMapper.partialUpdate(dto, clienteExistente);

                    Mono<Endereco> enderecoMono;
                    if (dto.getEnderecoRequestDto() != null) {
                        if (dto.getEnderecoRequestDto().getIdEndereco() != null) {
                            enderecoMono = enderecoService.atualizarEndereco(dto.getEnderecoRequestDto().getIdEndereco(), dto.getEnderecoRequestDto());
                        } else {
                            enderecoMono = enderecoService.criarEndereco(dto.getEnderecoRequestDto());
                        }
                    } else {
                        enderecoMono = Mono.just(clienteExistente.getEndereco());
                    }

                    Mono<Contato> contatoMono;
                    if (dto.getContatoRequestDto() != null) {
                        if (dto.getContatoRequestDto().getIdContato() != null) {
                            contatoMono = Mono.justOrEmpty(contatoRepository.findById(dto.getContatoRequestDto().getIdContato()))
                                    .switchIfEmpty(Mono.error(new ResourceNotFoundException("Contato", dto.getContatoRequestDto().getIdContato())))
                                    .flatMap(contatoExistente -> {
                                        contatoMapper.partialUpdate(dto.getContatoRequestDto(), contatoExistente);
                                        return Mono.just(contatoRepository.save(contatoExistente));
                                    });
                        } else {
                            contatoMono = Mono.just(contatoRepository.save(contatoMapper.toEntity(dto.getContatoRequestDto())));
                        }
                    } else {
                        contatoMono = Mono.just(clienteExistente.getContato());
                    }

                    return Mono.zip(enderecoMono, contatoMono)
                            .flatMap(tuple -> {
                                clienteExistente.setEndereco(tuple.getT1());
                                clienteExistente.setContato(tuple.getT2());
                                return Mono.just(clienteRepository.save(clienteExistente));
                            });
                })
                .onErrorResume(e -> {
                    if (e instanceof ResourceNotFoundException
                            || e instanceof DuplicatedResourceException
                            || e instanceof InvalidInputException) {
                        return Mono.error(e);
                    }
                    return Mono.error(new InvalidInputException("Erro inesperado ao atualizar cliente: " + e.getMessage()));
                });
    }

    @Transactional
    public void deletarCliente(Long id) {
        if (!clienteRepository.existsById(id)) {
            throw new ResourceNotFoundException("Cliente", id);
        }
        clienteRepository.deleteById(id);
    }

    @Transactional
    public ClienteVeiculo associarClienteVeiculo(Long clienteId, Long enderecoId, Long contatoId, Long veiculoId) {
        Cliente cliente = clienteRepository.findById(clienteId)
                .orElseThrow(() -> new ResourceNotFoundException("Cliente", clienteId));
        Veiculo veiculo = veiculoRepository.findById(veiculoId)
                .orElseThrow(() -> new ResourceNotFoundException("VeÃ­culo", veiculoId));

        ClienteVeiculoId id = new ClienteVeiculoId(clienteId, enderecoId, contatoId, veiculoId);
        if (clienteVeiculoRepository.existsById(id)) {
            throw new DuplicatedResourceException("AssociaÃ§Ã£o Cliente-VeÃ­culo", "IDs", id.toString());
        }
        ClienteVeiculo associacao = new ClienteVeiculo(cliente, veiculo);
        return clienteVeiculoRepository.save(associacao);
    }

    @Transactional
    public void desassociarClienteVeiculo(Long clienteId,
                                          Long enderecoId,
                                          Long contatoId,
                                          Long veiculoId) {
        // Cria o objeto de chave composta
        ClienteVeiculoId id = new ClienteVeiculoId(clienteId, enderecoId, contatoId, veiculoId);

        // Verifica existÃªncia usando a prÃ³pria chave composta
        if (!clienteVeiculoRepository.existsById(id)) {
            throw new ResourceNotFoundException(
                    "AssociaÃ§Ã£o Cliente-VeÃ­culo",  // nome do recurso
                    "ids",                           // nome do campo
                    id.toString()                    // valor que faltou
            );
        }

        // Remove passando o prÃ³prio ID (e nÃ£o uma String)
        clienteVeiculoRepository.deleteById(id);
    }


    public Set<Veiculo> getVeiculosByClienteId(Long clienteId) {
        Cliente cliente = clienteRepository.findById(clienteId)
                .orElseThrow(() -> new ResourceNotFoundException("Cliente", clienteId));
        return cliente.getClienteVeiculos().stream()
                .map(ClienteVeiculo::getVeiculo)
                .collect(Collectors.toSet());
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\service\ContatoService.java   |   package br.com.fiap.mottu.service   |   class ContatoService
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.contato.ContatoRequestDto;
import br.com.fiap.mottu.filter.ContatoFilter;
import br.com.fiap.mottu.mapper.ContatoMapper;
import br.com.fiap.mottu.model.Contato;
import br.com.fiap.mottu.repository.ContatoRepository;
import br.com.fiap.mottu.exception.*;
import br.com.fiap.mottu.specification.ContatoSpecification;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;

@Service
public class ContatoService {

    private final ContatoRepository contatoRepository;
    private final ContatoMapper contatoMapper;

    @Autowired
    public ContatoService(ContatoRepository contatoRepository, ContatoMapper contatoMapper) {
        this.contatoRepository = contatoRepository;
        this.contatoMapper = contatoMapper;
    }

    public List<Contato> listarTodosContatos() {
        return contatoRepository.findAll();
    }

    public Contato buscarContatoPorId(Long id) {
        return contatoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Contato", id));
    }

    public List<Contato> buscarContatosPorFiltro(ContatoFilter filter) {
        return contatoRepository.findAll(ContatoSpecification.withFilters(filter));
    }

    @Transactional
    public Contato criarContato(ContatoRequestDto dto) {
        String email = dto.getEmail();
        if (contatoRepository.findByEmail(email).isPresent()) {
            throw new DuplicatedResourceException("Contato", "email", email);
        }
        return contatoRepository.save(contatoMapper.toEntity(dto));
    }

    @Transactional
    public Contato atualizarContato(Long id, ContatoRequestDto dto) {
        return contatoRepository.findById(id)
                .map(existente -> {
                    String novoEmail = dto.getEmail();
                    if (novoEmail != null
                            && !novoEmail.equals(existente.getEmail())
                            && contatoRepository.findByEmail(novoEmail).isPresent()) {
                        throw new DuplicatedResourceException("Contato", "email", novoEmail);
                    }
                    contatoMapper.partialUpdate(dto, existente);
                    return contatoRepository.save(existente);
                })
                .orElseThrow(() -> new ResourceNotFoundException("Contato", id));
    }

    @Transactional
    public void deletarContato(Long id) {
        if (!contatoRepository.existsById(id)) {
            throw new ResourceNotFoundException("Contato", id);
        }
        contatoRepository.deleteById(id);
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\service\EnderecoService.java   |   package br.com.fiap.mottu.service   |   class EnderecoService
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// br/com/fiap/mottu/service/EnderecoService.java
package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.endereco.EnderecoRequestDto;
import br.com.fiap.mottu.external.viacep.ViaCepService;
import br.com.fiap.mottu.model.Endereco;
import br.com.fiap.mottu.mapper.EnderecoMapper;
import br.com.fiap.mottu.repository.EnderecoRepository;
import br.com.fiap.mottu.exception.ResourceNotFoundException;
import br.com.fiap.mottu.exception.InvalidInputException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import reactor.core.publisher.Mono;
import java.util.List;

@Service
public class EnderecoService {

    private final EnderecoRepository enderecoRepository;
    private final EnderecoMapper enderecoMapper;
    private final ViaCepService viaCepService;

    @Autowired
    public EnderecoService(EnderecoRepository enderecoRepository,
                           EnderecoMapper enderecoMapper,
                           ViaCepService viaCepService) {
        this.enderecoRepository = enderecoRepository;
        this.enderecoMapper = enderecoMapper;
        this.viaCepService = viaCepService;
    }

    public List<Endereco> listarTodosEnderecos() {
        return enderecoRepository.findAll();
    }

    public Endereco buscarEnderecoPorId(Long id) {
        return enderecoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("EndereÃ§o", id));
    }

    @Transactional
    public Mono<Endereco> criarEndereco(EnderecoRequestDto dto) {
        // ValidaÃ§Ã£o bÃ¡sica
        if (dto.getCep() == null || dto.getCep().isBlank()) {
            return Mono.error(new InvalidInputException("CEP nÃ£o pode ser nulo ou vazio."));
        }

        return viaCepService.buscarEnderecoPorCep(dto.getCep())
                .flatMap(resp -> {
                    Endereco endereco = enderecoMapper.toEntity(dto);
                    endereco.setLogradouro(resp.getLogradouro());
                    endereco.setBairro(resp.getBairro());
                    endereco.setCidade(resp.getLocalidade());
                    endereco.setEstado(resp.getUf());
                    endereco.setPais("Brasil");
                    return Mono.just(enderecoRepository.save(endereco));
                })
                // Aqui usamos o construtor de trÃªs argumentos:
                // (nome do recurso, nome do campo, valor do campo)
                .switchIfEmpty(Mono.error(
                        new ResourceNotFoundException("CEP", "cep", dto.getCep())
                ))
                .onErrorResume(e -> (e instanceof InvalidInputException)
                        ? Mono.error(e)
                        : Mono.error(new InvalidInputException("Erro ao criar endereÃ§o: " + e.getMessage())));
    }


    @Transactional
    public Mono<Endereco> atualizarEndereco(Long id, EnderecoRequestDto dto) {
        return Mono.justOrEmpty(enderecoRepository.findById(id))
                .switchIfEmpty(Mono.error(new ResourceNotFoundException("EndereÃ§o", id)))
                .flatMap(existing -> {
                    if (dto.getCep() != null && !dto.getCep().isBlank()) {
                        return viaCepService.buscarEnderecoPorCep(dto.getCep())
                                .flatMap(resp -> {
                                    enderecoMapper.partialUpdate(dto, existing);
                                    existing.setLogradouro(resp.getLogradouro());
                                    existing.setBairro(resp.getBairro());
                                    existing.setCidade(resp.getLocalidade());
                                    existing.setEstado(resp.getUf());
                                    existing.setPais("Brasil");
                                    return Mono.just(enderecoRepository.save(existing));
                                })
                                .switchIfEmpty(Mono.error(new ResourceNotFoundException("Dados de CEP para atualizaÃ§Ã£o", "CEP", dto.getCep())));
                    } else {
                        enderecoMapper.partialUpdate(dto, existing);
                        return Mono.just(enderecoRepository.save(existing));
                    }
                })
                .onErrorResume(e -> (e instanceof InvalidInputException || e instanceof ResourceNotFoundException)
                        ? Mono.error(e)
                        : Mono.error(new InvalidInputException("Erro inesperado ao atualizar endereÃ§o: " + e.getMessage())));
    }

    @Transactional
    public void deletarEndereco(Long id) {
        if (!enderecoRepository.existsById(id)) {
            throw new ResourceNotFoundException("EndereÃ§o", id);
        }
        enderecoRepository.deleteById(id);
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\service\PatioService.java   |   package br.com.fiap.mottu.service   |   class PatioService
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.patio.PatioRequestDto;
import br.com.fiap.mottu.filter.PatioFilter;
import br.com.fiap.mottu.mapper.PatioMapper;
import br.com.fiap.mottu.model.Patio;
import br.com.fiap.mottu.model.Veiculo;
import br.com.fiap.mottu.model.Zona;
import br.com.fiap.mottu.model.Box; // NOVO: Importar Box
import br.com.fiap.mottu.model.Contato;
import br.com.fiap.mottu.model.Endereco;

// Importar as classes de relacionamento e seus IDs
import br.com.fiap.mottu.model.relacionamento.VeiculoPatio;
import br.com.fiap.mottu.model.relacionamento.VeiculoPatioId;
import br.com.fiap.mottu.model.relacionamento.ZonaPatio;
import br.com.fiap.mottu.model.relacionamento.ZonaPatioId;
import br.com.fiap.mottu.model.relacionamento.ContatoPatio;
import br.com.fiap.mottu.model.relacionamento.ContatoPatioId;
import br.com.fiap.mottu.model.relacionamento.EnderecoPatio;
import br.com.fiap.mottu.model.relacionamento.EnderecoPatioId;
import br.com.fiap.mottu.model.relacionamento.PatioBox;    // NOVO
import br.com.fiap.mottu.model.relacionamento.PatioBoxId;  // NOVO


import br.com.fiap.mottu.repository.PatioRepository;
import br.com.fiap.mottu.repository.VeiculoRepository;
import br.com.fiap.mottu.repository.ZonaRepository;
import br.com.fiap.mottu.repository.BoxRepository;          // NOVO: Injetar BoxRepository
import br.com.fiap.mottu.repository.ContatoRepository;
import br.com.fiap.mottu.repository.EnderecoRepository;

// Importar os repositÃ³rios das tabelas de junÃ§Ã£o
import br.com.fiap.mottu.repository.relacionamento.VeiculoPatioRepository;
import br.com.fiap.mottu.repository.relacionamento.ZonaPatioRepository;
import br.com.fiap.mottu.repository.relacionamento.ContatoPatioRepository;
import br.com.fiap.mottu.repository.relacionamento.EnderecoPatioRepository;
import br.com.fiap.mottu.repository.relacionamento.PatioBoxRepository; // NOVO: Injetar


import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;
import br.com.fiap.mottu.specification.PatioSpecification;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;
import java.util.Set; // Para coleÃ§Ãµes
import java.util.stream.Collectors; // Para operaÃ§Ãµes com streams

@Service
public class PatioService {

    private final PatioRepository patioRepository;
    private final PatioMapper patioMapper;
    private final VeiculoRepository veiculoRepository;
    private final ZonaRepository zonaRepository;
    private final BoxRepository boxRepository; // NOVO
    private final ContatoRepository contatoRepository;
    private final EnderecoRepository enderecoRepository;

    // RepositÃ³rios das tabelas de junÃ§Ã£o
    private final VeiculoPatioRepository veiculoPatioRepository;
    private final ZonaPatioRepository zonaPatioRepository;
    private final ContatoPatioRepository contatoPatioRepository;
    private final EnderecoPatioRepository enderecoPatioRepository;
    private final PatioBoxRepository patioBoxRepository; // NOVO


    @Autowired
    public PatioService(PatioRepository patioRepository, PatioMapper patioMapper,
                        VeiculoRepository veiculoRepository, ZonaRepository zonaRepository,
                        ContatoRepository contatoRepository, EnderecoRepository enderecoRepository,
                        VeiculoPatioRepository veiculoPatioRepository, ZonaPatioRepository zonaPatioRepository,
                        ContatoPatioRepository contatoPatioRepository, EnderecoPatioRepository enderecoPatioRepository,
                        BoxRepository boxRepository, PatioBoxRepository patioBoxRepository) { // NOVO: Adicione BoxRepository e PatioBoxRepository aqui
        this.patioRepository = patioRepository;
        this.patioMapper = patioMapper;
        this.veiculoRepository = veiculoRepository;
        this.zonaRepository = zonaRepository;
        this.contatoRepository = contatoRepository;
        this.enderecoRepository = enderecoRepository;
        this.veiculoPatioRepository = veiculoPatioRepository;
        this.zonaPatioRepository = zonaPatioRepository;
        this.contatoPatioRepository = contatoPatioRepository;
        this.enderecoPatioRepository = enderecoPatioRepository;
        this.boxRepository = boxRepository;
        this.patioBoxRepository = patioBoxRepository;
    }

    public List<Patio> listarTodosPatios() {
        return patioRepository.findAll();
    }

    public Patio buscarPatioPorId(Long id) {
        return patioRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("PÃ¡tio", id));
    }

    public List<Patio> buscarPatiosPorFiltro(PatioFilter filter) {
        return patioRepository.findAll(PatioSpecification.withFilters(filter));
    }

    @Transactional
    public Patio criarPatio(PatioRequestDto dto) {
        String nome = dto.getNomePatio();
        if (patioRepository.findByNomePatioContainingIgnoreCase(nome)
                .stream().anyMatch(p -> p.getNomePatio().equalsIgnoreCase(nome))) {
            throw new DuplicatedResourceException("PÃ¡tio", "nome", nome);
        }
        Patio patio = patioMapper.toEntity(dto);
        return patioRepository.save(patio);
    }

    @Transactional
    public Patio atualizarPatio(Long id, PatioRequestDto dto) {
        return patioRepository.findById(id)
                .map(existente -> {
                    String novoNome = dto.getNomePatio();
                    if (novoNome != null
                            && !novoNome.equalsIgnoreCase(existente.getNomePatio())
                            && patioRepository.findByNomePatioContainingIgnoreCase(novoNome)
                            .stream().anyMatch(p -> p.getNomePatio().equalsIgnoreCase(novoNome))) {
                        throw new DuplicatedResourceException("PÃ¡tio", "nome", novoNome);
                    }
                    patioMapper.partialUpdate(dto, existente);
                    return patioRepository.save(existente);
                })
                .orElseThrow(() -> new ResourceNotFoundException("PÃ¡tio", id));
    }

    @Transactional
    public void deletarPatio(Long id) {
        if (!patioRepository.existsById(id)) {
            throw new ResourceNotFoundException("PÃ¡tio", id);
        }
        patioRepository.deleteById(id);
    }

    // MÃ©todos para gerenciar associaÃ§Ãµes de Patio

    // --- VeiculoPatio ---
    @Transactional
    public VeiculoPatio associarPatioVeiculo(Long patioId, Long veiculoId) {
        Patio patio = patioRepository.findById(patioId)
                .orElseThrow(() -> new ResourceNotFoundException("PÃ¡tio", patioId));
        Veiculo veiculo = veiculoRepository.findById(veiculoId)
                .orElseThrow(() -> new ResourceNotFoundException("VeÃ­culo", veiculoId));

        VeiculoPatioId id = new VeiculoPatioId(veiculoId, patioId); // Cria o ID composto
        if (veiculoPatioRepository.existsById(id)) {
            throw new DuplicatedResourceException("AssociaÃ§Ã£o PÃ¡tio-VeÃ­culo", "IDs", id.toString());
        }

        VeiculoPatio associacao = new VeiculoPatio(veiculo, patio); // Cria a entidade de relacionamento
        return veiculoPatioRepository.save(associacao);
    }

    @Transactional
    public void desassociarPatioVeiculo(Long patioId, Long veiculoId) {
        VeiculoPatioId id = new VeiculoPatioId(veiculoId, patioId); // Cria o ID composto
        if (!veiculoPatioRepository.existsById(id)) {
            throw new ResourceNotFoundException("AssociaÃ§Ã£o PÃ¡tio-VeÃ­culo", "IDs", id.toString());
        }
        veiculoPatioRepository.deleteById(id);
    }

    public Set<Veiculo> getVeiculosByPatioId(Long patioId) {
        Patio patio = patioRepository.findById(patioId)
                .orElseThrow(() -> new ResourceNotFoundException("PÃ¡tio", patioId));
        return patio.getVeiculoPatios().stream() // Assume que Patio tem um Set<VeiculoPatio>
                .map(VeiculoPatio::getVeiculo) // Mapeia para a entidade Veiculo
                .collect(Collectors.toSet());
    }

    // --- ZonaPatio ---
    @Transactional
    public ZonaPatio associarPatioZona(Long patioId, Long zonaId) {
        Patio patio = patioRepository.findById(patioId)
                .orElseThrow(() -> new ResourceNotFoundException("PÃ¡tio", patioId));
        Zona zona = zonaRepository.findById(zonaId)
                .orElseThrow(() -> new ResourceNotFoundException("Zona", zonaId));

        ZonaPatioId id = new ZonaPatioId(patioId, zonaId); // Cria o ID composto
        if (zonaPatioRepository.existsById(id)) {
            throw new DuplicatedResourceException("AssociaÃ§Ã£o PÃ¡tio-Zona", "IDs", id.toString());
        }

        ZonaPatio associacao = new ZonaPatio(patio, zona); // Cria a entidade de relacionamento
        return zonaPatioRepository.save(associacao);
    }

    @Transactional
    public void desassociarPatioZona(Long patioId, Long zonaId) {
        ZonaPatioId id = new ZonaPatioId(patioId, zonaId); // Cria o ID composto
        if (!zonaPatioRepository.existsById(id)) {
            throw new ResourceNotFoundException("AssociaÃ§Ã£o PÃ¡tio-Zona", "IDs", id.toString());
        }
        zonaPatioRepository.deleteById(id);
    }

    public Set<Zona> getZonasByPatioId(Long patioId) {
        Patio patio = patioRepository.findById(patioId)
                .orElseThrow(() -> new ResourceNotFoundException("PÃ¡tio", patioId));
        return patio.getZonaPatios().stream() // Assume que Patio tem um Set<ZonaPatio>
                .map(ZonaPatio::getZona) // Mapeia para a entidade Zona
                .collect(Collectors.toSet());
    }

    // --- ContatoPatio ---
    @Transactional
    public ContatoPatio associarPatioContato(Long patioId, Long contatoId) {
        Patio patio = patioRepository.findById(patioId)
                .orElseThrow(() -> new ResourceNotFoundException("PÃ¡tio", patioId));
        Contato contato = contatoRepository.findById(contatoId)
                .orElseThrow(() -> new ResourceNotFoundException("Contato", contatoId));

        ContatoPatioId id = new ContatoPatioId(patioId, contatoId); // Cria o ID composto
        if (contatoPatioRepository.existsById(id)) {
            throw new DuplicatedResourceException("AssociaÃ§Ã£o PÃ¡tio-Contato", "IDs", id.toString());
        }

        ContatoPatio associacao = new ContatoPatio(patio, contato); // Cria a entidade de relacionamento
        return contatoPatioRepository.save(associacao);
    }

    @Transactional
    public void desassociarPatioContato(Long patioId, Long contatoId) {
        ContatoPatioId id = new ContatoPatioId(patioId, contatoId); // Cria o ID composto
        if (!contatoPatioRepository.existsById(id)) {
            throw new ResourceNotFoundException("AssociaÃ§Ã£o PÃ¡tio-Contato", "IDs", id.toString());
        }
        contatoPatioRepository.deleteById(id);
    }

    public Set<Contato> getContatosByPatioId(Long patioId) {
        Patio patio = patioRepository.findById(patioId)
                .orElseThrow(() -> new ResourceNotFoundException("PÃ¡tio", patioId));
        return patio.getContatoPatios().stream() // Assume que Patio tem um Set<ContatoPatio>
                .map(ContatoPatio::getContato) // Mapeia para a entidade Contato
                .collect(Collectors.toSet());
    }

    // --- EnderecoPatio ---
    @Transactional
    public EnderecoPatio associarPatioEndereco(Long patioId, Long enderecoId) {
        Patio patio = patioRepository.findById(patioId)
                .orElseThrow(() -> new ResourceNotFoundException("PÃ¡tio", patioId));
        Endereco endereco = enderecoRepository.findById(enderecoId)
                .orElseThrow(() -> new ResourceNotFoundException("EndereÃ§o", enderecoId));

        // O EnderecoPatioId usa enderecoId primeiro, conforme seu DDL
        EnderecoPatioId id = new EnderecoPatioId(enderecoId, patioId); // Cria o ID composto
        if (enderecoPatioRepository.existsById(id)) {
            throw new DuplicatedResourceException("AssociaÃ§Ã£o PÃ¡tio-EndereÃ§o", "IDs", id.toString());
        }

        EnderecoPatio associacao = new EnderecoPatio(endereco, patio); // Cria a entidade de relacionamento
        return enderecoPatioRepository.save(associacao);
    }

    @Transactional
    public void desassociarPatioEndereco(Long patioId, Long enderecoId) {
        // O EnderecoPatioId usa enderecoId primeiro, conforme seu DDL
        EnderecoPatioId id = new EnderecoPatioId(enderecoId, patioId); // Cria o ID composto
        if (!enderecoPatioRepository.existsById(id)) {
            throw new ResourceNotFoundException("AssociaÃ§Ã£o PÃ¡tio-EndereÃ§o", "IDs", id.toString());
        }
        enderecoPatioRepository.deleteById(id);
    }

    public Set<Endereco> getEnderecosByPatioId(Long patioId) {
        Patio patio = patioRepository.findById(patioId)
                .orElseThrow(() -> new ResourceNotFoundException("PÃ¡tio", patioId));
        return patio.getEnderecoPatios().stream()
                .map(EnderecoPatio::getEndereco)
                .collect(Collectors.toSet());
    }

    // --- PatioBox (NOVO) ---
    @Transactional
    public PatioBox associarPatioBox(Long patioId, Long boxId) {
        Patio patio = patioRepository.findById(patioId)
                .orElseThrow(() -> new ResourceNotFoundException("PÃ¡tio", patioId));
        Box box = boxRepository.findById(boxId)
                .orElseThrow(() -> new ResourceNotFoundException("Box", boxId));

        PatioBoxId id = new PatioBoxId(patioId, boxId);
        if (patioBoxRepository.existsById(id)) {
            throw new DuplicatedResourceException("AssociaÃ§Ã£o PÃ¡tio-Box", "IDs", id.toString());
        }

        PatioBox associacao = new PatioBox(patio, box);
        return patioBoxRepository.save(associacao);
    }

    @Transactional
    public void desassociarPatioBox(Long patioId, Long boxId) {
        PatioBoxId id = new PatioBoxId(patioId, boxId);
        if (!patioBoxRepository.existsById(id)) {
            throw new ResourceNotFoundException("AssociaÃ§Ã£o PÃ¡tio-Box", "IDs", id.toString());
        }
        patioBoxRepository.deleteById(id);
    }

    public Set<Box> getBoxesByPatioId(Long patioId) {
        Patio patio = patioRepository.findById(patioId)
                .orElseThrow(() -> new ResourceNotFoundException("PÃ¡tio", patioId));
        return patio.getPatioBoxes().stream()
                .map(PatioBox::getBox)
                .collect(Collectors.toSet());
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\service\RastreamentoService.java   |   package br.com.fiap.mottu.service   |   class RastreamentoService
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.rastreamento.RastreamentoRequestDto;
import br.com.fiap.mottu.filter.RastreamentoFilter;
import br.com.fiap.mottu.mapper.RastreamentoMapper;
import br.com.fiap.mottu.model.Rastreamento;
import br.com.fiap.mottu.repository.RastreamentoRepository;
import br.com.fiap.mottu.exception.*;
import br.com.fiap.mottu.specification.RastreamentoSpecification;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;
import java.math.BigDecimal; // Importe BigDecimal!

@Service
public class RastreamentoService {

    private final RastreamentoRepository rastreamentoRepository;
    private final RastreamentoMapper rastreamentoMapper;

    @Autowired
    public RastreamentoService(RastreamentoRepository rastreamentoRepository,
                               RastreamentoMapper rastreamentoMapper) {
        this.rastreamentoRepository = rastreamentoRepository;
        this.rastreamentoMapper = rastreamentoMapper;
    }

    public List<Rastreamento> listarTodosRastreamentos() {
        return rastreamentoRepository.findAll();
    }

    public Rastreamento buscarRastreamentoPorId(Long id) {
        return rastreamentoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Rastreamento", id));
    }

    public List<Rastreamento> buscarRastreamentosPorFiltro(RastreamentoFilter filter) {
        return rastreamentoRepository.findAll(RastreamentoSpecification.withFilters(filter));
    }

    @Transactional
    public Rastreamento criarRastreamento(RastreamentoRequestDto dto) {
        if (dto.getIpsX() == null || dto.getIpsY() == null || dto.getIpsZ() == null ||
                dto.getGprsLatitude() == null || dto.getGprsLongitude() == null || dto.getGprsAltitude() == null) {
            throw new InvalidInputException("Todas as coordenadas (IPS_X, IPS_Y, IPS_Z, GPRS_LATITUDE, GPRS_LONGITUDE, GPRS_ALTITUDE) sÃ£o obrigatÃ³rias.");
        }
        Rastreamento r = rastreamentoMapper.toEntity(dto);
        return rastreamentoRepository.save(r);
    }

    @Transactional
    public Rastreamento atualizarRastreamento(Long id, RastreamentoRequestDto dto) {
        return rastreamentoRepository.findById(id)
                .map(existente -> {
                    rastreamentoMapper.partialUpdate(dto, existente);
                    return rastreamentoRepository.save(existente);
                })
                .orElseThrow(() -> new ResourceNotFoundException("Rastreamento", id));
    }

    @Transactional
    public void deletarRastreamento(Long id) {
        if (!rastreamentoRepository.existsById(id)) {
            throw new ResourceNotFoundException("Rastreamento", id);
        }
        rastreamentoRepository.deleteById(id);
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\service\VeiculoService.java   |   package br.com.fiap.mottu.service   |   class VeiculoService
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.veiculo.VeiculoRequestDto;
import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.mottu.dto.veiculo.VeiculoLocalizacaoResponseDto; // NOVO: Importar o DTO de localizaÃ§Ã£o

import br.com.fiap.mottu.filter.VeiculoFilter;
import br.com.fiap.mottu.mapper.VeiculoMapper;
import br.com.fiap.mottu.mapper.RastreamentoMapper; // NOVO: Injetar para mapear Rastreamento
import br.com.fiap.mottu.mapper.PatioMapper;       // NOVO: Injetar para mapear Patio
import br.com.fiap.mottu.mapper.ZonaMapper;         // NOVO: Injetar para mapear Zona
import br.com.fiap.mottu.mapper.BoxMapper;           // NOVO: Injetar para mapear Box

import br.com.fiap.mottu.model.Veiculo;
import br.com.fiap.mottu.model.Rastreamento; // NOVO: Importar Rastreamento
import br.com.fiap.mottu.model.Patio;       // NOVO: Importar Patio
import br.com.fiap.mottu.model.Zona;         // NOVO: Importar Zona
import br.com.fiap.mottu.model.Box;          // NOVO: Importar Box

// Importar as classes de relacionamento
import br.com.fiap.mottu.model.relacionamento.VeiculoRastreamento;
import br.com.fiap.mottu.model.relacionamento.VeiculoPatio;
import br.com.fiap.mottu.model.relacionamento.VeiculoZona;
import br.com.fiap.mottu.model.relacionamento.VeiculoBox;

import br.com.fiap.mottu.repository.VeiculoRepository;
import br.com.fiap.mottu.repository.relacionamento.VeiculoRastreamentoRepository; // NOVO: Injetar

import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;
import br.com.fiap.mottu.specification.VeiculoSpecification;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.time.LocalDateTime; // Para o timestamp da consulta
import java.util.List;
import java.util.Comparator; // Para encontrar o Ãºltimo rastreamento
import java.util.Optional; // Para lidar com Optional
import java.util.Set; // Para coleÃ§Ãµes
import java.util.stream.Collectors; // Para streams

@Service
public class VeiculoService {

    private final VeiculoRepository veiculoRepository;
    private final VeiculoMapper veiculoMapper;
    private final VeiculoRastreamentoRepository veiculoRastreamentoRepository;
    private final RastreamentoMapper rastreamentoMapper;
    private final PatioMapper patioMapper;
    private final ZonaMapper zonaMapper;
    private final BoxMapper boxMapper;

    @Autowired
    public VeiculoService(VeiculoRepository veiculoRepository,
                          VeiculoMapper veiculoMapper,
                          VeiculoRastreamentoRepository veiculoRastreamentoRepository,
                          RastreamentoMapper rastreamentoMapper,
                          PatioMapper patioMapper,
                          ZonaMapper zonaMapper,
                          BoxMapper boxMapper) {
        this.veiculoRepository = veiculoRepository;
        this.veiculoMapper = veiculoMapper;
        this.veiculoRastreamentoRepository = veiculoRastreamentoRepository;
        this.rastreamentoMapper = rastreamentoMapper;
        this.patioMapper = patioMapper;
        this.zonaMapper = zonaMapper;
        this.boxMapper = boxMapper;
    }

    @Transactional(readOnly = true)
    public List<Veiculo> listarTodosVeiculos() {
        return veiculoRepository.findAll();
    }

    @Transactional(readOnly = true)
    public Veiculo buscarVeiculoPorId(Long id) {
        return veiculoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("VeÃ­culo", id));
    }

    @Transactional(readOnly = true)
    public List<Veiculo> buscarVeiculosPorFiltro(VeiculoFilter filter) {
        return veiculoRepository.findAll(VeiculoSpecification.withFilters(filter));
    }

    @Transactional
    public Veiculo criarVeiculo(VeiculoRequestDto dto) {
        // ValidaÃ§Ãµes de duplicidade: placa, RENAVAM e chassi
        if (veiculoRepository.findByPlaca(dto.getPlaca()).isPresent()) {
            throw new DuplicatedResourceException("VeÃ­culo", "placa", dto.getPlaca());
        }
        if (veiculoRepository.findByRenavam(dto.getRenavam()).isPresent()) {
            throw new DuplicatedResourceException("VeÃ­culo", "RENAVAM", dto.getRenavam());
        }
        if (veiculoRepository.findByChassi(dto.getChassi()).isPresent()) {
            throw new DuplicatedResourceException("VeÃ­culo", "chassi", dto.getChassi());
        }
        Veiculo veiculo = veiculoMapper.toEntity(dto);
        return veiculoRepository.save(veiculo);
    }

    @Transactional
    public Veiculo atualizarVeiculo(Long id, VeiculoRequestDto dto) {
        Veiculo existente = veiculoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("VeÃ­culo", id));

        // ValidaÃ§Ã£o de placa duplicada (se alterada e diferente da placa de outro veÃ­culo)
        if (dto.getPlaca() != null && !dto.getPlaca().isBlank() && !dto.getPlaca().equals(existente.getPlaca())) {
            if (veiculoRepository.findByPlaca(dto.getPlaca())
                    .filter(v -> !v.getIdVeiculo().equals(id)) // Exclui o prÃ³prio veÃ­culo da checagem
                    .isPresent()) {
                throw new DuplicatedResourceException("VeÃ­culo", "placa", dto.getPlaca());
            }
        }

        // ValidaÃ§Ã£o de RENAVAM duplicado (se alterado e diferente do RENAVAM de outro veÃ­culo)
        if (dto.getRenavam() != null && !dto.getRenavam().isBlank() && !dto.getRenavam().equals(existente.getRenavam())) {
            if (veiculoRepository.findByRenavam(dto.getRenavam())
                    .filter(v -> !v.getIdVeiculo().equals(id)) // Exclui o prÃ³prio veÃ­culo
                    .isPresent()) {
                throw new DuplicatedResourceException("VeÃ­culo", "RENAVAM", dto.getRenavam());
            }
        }

        // ValidaÃ§Ã£o de chassi duplicado (se alterado e diferente do chassi de outro veÃ­culo)
        if (dto.getChassi() != null && !dto.getChassi().isBlank() && !dto.getChassi().equals(existente.getChassi())) {
            if (veiculoRepository.findByChassi(dto.getChassi())
                    .filter(v -> !v.getIdVeiculo().equals(id)) // Exclui o prÃ³prio veÃ­culo
                    .isPresent()) {
                throw new DuplicatedResourceException("VeÃ­culo", "chassi", dto.getChassi());
            }
        }

        veiculoMapper.partialUpdate(dto, existente);
        return veiculoRepository.save(existente);
    }

    @Transactional
    public void deletarVeiculo(Long id) {
        if (!veiculoRepository.existsById(id)) {
            throw new ResourceNotFoundException("VeÃ­culo", id);
        }
        veiculoRepository.deleteById(id);
    }

    /**
     * Retorna o Ãºltimo ponto de rastreamento de um veÃ­culo e suas associaÃ§Ãµes atuais
     * com PÃ¡tio, Zona e Box.
     * @param veiculoId ID do veÃ­culo.
     * @return DTO com informaÃ§Ãµes de localizaÃ§Ã£o do veÃ­culo.
     * @throws ResourceNotFoundException se o veÃ­culo nÃ£o for encontrado.
     */
    @Transactional(readOnly = true)
    public VeiculoLocalizacaoResponseDto getLocalizacaoVeiculo(Long veiculoId) {
        Veiculo veiculo = veiculoRepository.findById(veiculoId)
                .orElseThrow(() -> new ResourceNotFoundException("VeÃ­culo", veiculoId));

        Rastreamento ultimoRastreamento = null;
        // Encontrar o Ãºltimo rastreamento associado ao veÃ­culo.
        // Assumimos que a tabela VeiculoRastreamento nÃ£o tem um campo de timestamp prÃ³prio para a associaÃ§Ã£o,
        // entÃ£o usamos o ID do Rastreamento como proxy para o mais recente.
        // Se sua entidade Rastreamento tiver um campo de data/hora (ex: `dataHoraRegistro`),
        // Ã© MELHOR usar: `Comparator.comparing(va -> va.getRastreamento().getDataHoraRegistro())`
        Optional<VeiculoRastreamento> ultimaAssociacaoRastreamento = veiculo.getVeiculoRastreamentos().stream()
                .max(Comparator.comparing(va -> va.getRastreamento().getIdRastreamento())); // Usando ID como proxy para o mais recente

        if (ultimaAssociacaoRastreamento.isPresent()) {
            ultimoRastreamento = ultimaAssociacaoRastreamento.get().getRastreamento();
        }

        // Encontrar Patio associado (um veÃ­culo pode estar em um Patio via VeiculoPatio)
        // Assumimos que um veÃ­culo estÃ¡ em no mÃ¡ximo um pÃ¡tio por vez ou pegamos o primeiro.
        Patio patioAssociado = veiculo.getVeiculoPatios().stream()
                .map(VeiculoPatio::getPatio)
                .findFirst()
                .orElse(null);

        // Encontrar Zona associada (um veÃ­culo pode estar em uma Zona via VeiculoZona)
        // Assumimos que um veÃ­culo estÃ¡ em no mÃ¡ximo uma zona por vez ou pegamos a primeira.
        Zona zonaAssociada = veiculo.getVeiculoZonas().stream()
                .map(VeiculoZona::getZona)
                .findFirst()
                .orElse(null);

        // Encontrar Box associado (um veÃ­culo pode estar em um Box via VeiculoBox)
        // Assumimos que um veÃ­culo estÃ¡ em no mÃ¡ximo um box por vez ou pegamos o primeiro.
        Box boxAssociado = veiculo.getVeiculoBoxes().stream()
                .map(VeiculoBox::getBox)
                .findFirst()
                .orElse(null);

        return new VeiculoLocalizacaoResponseDto(
                veiculo.getIdVeiculo(),
                veiculo.getPlaca(),
                veiculo.getModelo(),
                veiculo.getFabricante(),
                (ultimoRastreamento != null) ? rastreamentoMapper.toResponseDto(ultimoRastreamento) : null,
                (patioAssociado != null) ? patioMapper.toResponseDto(patioAssociado) : null,
                (zonaAssociada != null) ? zonaMapper.toResponseDto(zonaAssociada) : null,
                (boxAssociado != null) ? boxMapper.toResponseDto(boxAssociado) : null,
                LocalDateTime.now() // Timestamp da consulta
        );
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\service\ZonaService.java   |   package br.com.fiap.mottu.service   |   class ZonaService
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.zona.ZonaRequestDto;
import br.com.fiap.mottu.filter.ZonaFilter;
import br.com.fiap.mottu.mapper.ZonaMapper;
import br.com.fiap.mottu.model.Zona;
import br.com.fiap.mottu.repository.ZonaRepository;
import br.com.fiap.mottu.exception.*;
import br.com.fiap.mottu.specification.ZonaSpecification;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;

@Service
public class ZonaService {

    private final ZonaRepository zonaRepository;
    private final ZonaMapper zonaMapper;

    @Autowired
    public ZonaService(ZonaRepository zonaRepository, ZonaMapper zonaMapper) {
        this.zonaRepository = zonaRepository;
        this.zonaMapper = zonaMapper;
    }

    public List<Zona> listarTodasZonas() {
        return zonaRepository.findAll();
    }

    public Zona buscarZonaPorId(Long id) {
        return zonaRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Zona", id));
    }

    public List<Zona> buscarZonasPorFiltro(ZonaFilter filter) {
        return zonaRepository.findAll(ZonaSpecification.withFilters(filter));
    }

    @Transactional
    public Zona criarZona(ZonaRequestDto dto) {
        String nome = dto.getNome();
        if (zonaRepository.findByNomeContainingIgnoreCase(nome)
                .stream().anyMatch(z -> z.getNome().equalsIgnoreCase(nome))) {
            throw new DuplicatedResourceException("Zona", "nome", nome);
        }
        Zona z = zonaMapper.toEntity(dto);
        return zonaRepository.save(z);
    }

    @Transactional
    public Zona atualizarZona(Long id, ZonaRequestDto dto) {
        return zonaRepository.findById(id)
                .map(existente -> {
                    String novoNome = dto.getNome();
                    if (novoNome != null
                            && !novoNome.equalsIgnoreCase(existente.getNome())
                            && zonaRepository.findByNomeContainingIgnoreCase(novoNome)
                            .stream().anyMatch(z -> z.getNome().equalsIgnoreCase(novoNome))) {
                        throw new DuplicatedResourceException("Zona", "nome", novoNome);
                    }
                    zonaMapper.partialUpdate(dto, existente);
                    return zonaRepository.save(existente);
                })
                .orElseThrow(() -> new ResourceNotFoundException("Zona", id));
    }

    @Transactional
    public void deletarZona(Long id) {
        if (!zonaRepository.existsById(id)) {
            throw new ResourceNotFoundException("Zona", id);
        }
        zonaRepository.deleteById(id);
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\specification\BoxSpecification.java   |   package br.com.fiap.mottu.specification   |   class BoxSpecification
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\specification\BoxSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.BoxFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Box;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class BoxSpecification {

    public static Specification<Box> withFilters(BoxFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.nome() != null && !filter.nome().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("nome")), "%" + filter.nome().toLowerCase() + "%"));
            }
            if (filter.status() != null && !filter.status().isBlank()) {
                predicates.add(cb.equal(root.get("status"), filter.status()));
            }
            if (filter.dataEntradaInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataEntrada"), filter.dataEntradaInicio()));
            }
            if (filter.dataEntradaFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataEntrada"), filter.dataEntradaFim()));
            }
            if (filter.dataSaidaInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataSaida"), filter.dataSaidaInicio()));
            }
            if (filter.dataSaidaFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataSaida"), filter.dataSaidaFim()));
            }
            if (filter.observacao() != null && !filter.observacao().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("observacao")), "%" + filter.observacao().toLowerCase() + "%"));
            }

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\specification\ClienteSpecification.java   |   package br.com.fiap.mottu.specification   |   class ClienteSpecification
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\specification\ClienteSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.ClienteFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Cliente;
import br.com.fiap.mottu.model.relacionamento.ClienteVeiculo;
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class ClienteSpecification {

    public static Specification<Cliente> withFilters(ClienteFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.nome() != null && !filter.nome().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("nome")), "%" + filter.nome().toLowerCase() + "%"));
            }
            if (filter.sobrenome() != null && !filter.sobrenome().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("sobrenome")), "%" + filter.sobrenome().toLowerCase() + "%"));
            }
            if (filter.cpf() != null && !filter.cpf().isBlank()) {
                predicates.add(cb.equal(root.get("cpf"), filter.cpf()));
            }
            if (filter.sexo() != null && !filter.sexo().isBlank()) {
                predicates.add(cb.equal(root.get("sexo"), filter.sexo()));
            }
            if (filter.profissao() != null && !filter.profissao().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("profissao")), "%" + filter.profissao().toLowerCase() + "%"));
            }
            if (filter.estadoCivil() != null && !filter.estadoCivil().isBlank()) {
                predicates.add(cb.equal(root.get("estadoCivil"), filter.estadoCivil()));
            }
            if (filter.dataCadastroInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataCadastro"), filter.dataCadastroInicio()));
            }
            if (filter.dataCadastroFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataCadastro"), filter.dataCadastroFim()));
            }
            if (filter.dataNascimentoInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataNascimento"), filter.dataNascimentoInicio()));
            }
            if (filter.dataNascimentoFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataNascimento"), filter.dataNascimentoFim()));
            }

            // Filtro por relacionamento ManyToOne (Endereco)
            if (filter.enderecoCidade() != null && !filter.enderecoCidade().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("endereco").get("cidade")), "%" + filter.enderecoCidade().toLowerCase() + "%"));
            }
            if (filter.enderecoEstado() != null && !filter.enderecoEstado().isBlank()) {
                predicates.add(cb.equal(root.get("endereco").get("estado"), filter.enderecoEstado()));
            }

            // Filtro por relacionamento ManyToOne (Contato)
            if (filter.contatoEmail() != null && !filter.contatoEmail().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("contato").get("email")), "%" + filter.contatoEmail().toLowerCase() + "%"));
            }
            if (filter.contatoCelular() != null && !filter.contatoCelular().isBlank()) {
                predicates.add(cb.like(root.get("contato").get("celular"), "%" + filter.contatoCelular() + "%"));
            }

            // Filtro por relacionamento OneToMany (ClienteVeiculo) para propriedade de Veiculo
            // Isso envolve fazer um JOIN com a tabela de junÃ§Ã£o e depois com a entidade Veiculo
            if (filter.veiculoPlaca() != null && !filter.veiculoPlaca().isBlank()) {
                Join<Cliente, ClienteVeiculo> clienteVeiculoJoin = root.join("clienteVeiculos");
                predicates.add(cb.equal(clienteVeiculoJoin.get("veiculo").get("placa"), filter.veiculoPlaca()));
            }
            if (filter.veiculoModelo() != null && !filter.veiculoModelo().isBlank()) {
                Join<Cliente, ClienteVeiculo> clienteVeiculoJoin = root.join("clienteVeiculos");
                predicates.add(cb.like(cb.lower(clienteVeiculoJoin.get("veiculo").get("modelo")), "%" + filter.veiculoModelo().toLowerCase() + "%"));
            }

            query.distinct(true); // Evitar duplicaÃ§Ã£o de resultados ao usar joins para coleÃ§Ãµes

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\specification\ContatoSpecification.java   |   package br.com.fiap.mottu.specification   |   class ContatoSpecification
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\specification\ContatoSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.ContatoFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Contato;
import jakarta.persistence.criteria.Predicate;
import jakarta.persistence.criteria.Join;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class ContatoSpecification {

    public static Specification<Contato> withFilters(ContatoFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.email() != null && !filter.email().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("email")), "%" + filter.email().toLowerCase() + "%"));
            }
            if (filter.ddd() != null) {
                predicates.add(cb.equal(root.get("ddd"), filter.ddd()));
            }
            if (filter.ddi() != null) {
                predicates.add(cb.equal(root.get("ddi"), filter.ddi()));
            }
            if (filter.telefone1() != null && !filter.telefone1().isBlank()) {
                predicates.add(cb.like(root.get("telefone1"), "%" + filter.telefone1() + "%"));
            }
            if (filter.celular() != null && !filter.celular().isBlank()) {
                predicates.add(cb.like(root.get("celular"), "%" + filter.celular() + "%"));
            }
            if (filter.observacao() != null && !filter.observacao().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("observacao")), "%" + filter.observacao().toLowerCase() + "%"));
            }

            // Filtro por relacionamento OneToMany (Cliente)
            if (filter.clienteNome() != null && !filter.clienteNome().isBlank()) {
                Join<Contato, br.com.fiap.mottu.model.Cliente> clienteJoin = root.join("clienteContatos"); // Mapeia para o nome da coleÃ§Ã£o em Contato
                predicates.add(cb.like(cb.lower(clienteJoin.get("nome")), "%" + filter.clienteNome().toLowerCase() + "%"));
            }

            query.distinct(true); // Evitar duplicaÃ§Ã£o de resultados

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\specification\EnderecoSpecification.java   |   package br.com.fiap.mottu.specification   |   class EnderecoSpecification
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\specification\EnderecoSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.EnderecoFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Endereco;
import jakarta.persistence.criteria.Predicate;
import jakarta.persistence.criteria.Join;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class EnderecoSpecification {

    public static Specification<Endereco> withFilters(EnderecoFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.cep() != null && !filter.cep().isBlank()) {
                predicates.add(cb.equal(root.get("cep"), filter.cep()));
            }
            if (filter.numero() != null) {
                predicates.add(cb.equal(root.get("numero"), filter.numero()));
            }
            if (filter.logradouro() != null && !filter.logradouro().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("logradouro")), "%" + filter.logradouro().toLowerCase() + "%"));
            }
            if (filter.bairro() != null && !filter.bairro().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("bairro")), "%" + filter.bairro().toLowerCase() + "%"));
            }
            if (filter.cidade() != null && !filter.cidade().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("cidade")), "%" + filter.cidade().toLowerCase() + "%"));
            }
            if (filter.estado() != null && !filter.estado().isBlank()) {
                predicates.add(cb.equal(root.get("estado"), filter.estado()));
            }
            if (filter.pais() != null && !filter.pais().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("pais")), "%" + filter.pais().toLowerCase() + "%"));
            }
            if (filter.observacao() != null && !filter.observacao().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("observacao")), "%" + filter.observacao().toLowerCase() + "%"));
            }

            // Filtro por relacionamento OneToMany (Cliente)
            if (filter.clienteNome() != null && !filter.clienteNome().isBlank()) {
                Join<Endereco, br.com.fiap.mottu.model.Cliente> clienteJoin = root.join("clienteEnderecos"); // Mapeia para o nome da coleÃ§Ã£o em Endereco
                predicates.add(cb.like(cb.lower(clienteJoin.get("nome")), "%" + filter.clienteNome().toLowerCase() + "%"));
            }

            query.distinct(true); // Evitar duplicaÃ§Ã£o de resultados

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\specification\PatioSpecification.java   |   package br.com.fiap.mottu.specification   |   class PatioSpecification
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\specification\PatioSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.PatioFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Patio;
import br.com.fiap.mottu.model.relacionamento.VeiculoPatio; // Exemplo de junÃ§Ã£o
import br.com.fiap.mottu.model.relacionamento.EnderecoPatio; // Exemplo de junÃ§Ã£o
import br.com.fiap.mottu.model.relacionamento.ContatoPatio; // Exemplo de junÃ§Ã£o
import br.com.fiap.mottu.model.relacionamento.ZonaPatio; // Exemplo de junÃ§Ã£o
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class PatioSpecification {

    public static Specification<Patio> withFilters(PatioFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.nomePatio() != null && !filter.nomePatio().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("nomePatio")), "%" + filter.nomePatio().toLowerCase() + "%"));
            }
            if (filter.dataEntradaInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataEntrada"), filter.dataEntradaInicio()));
            }
            if (filter.dataEntradaFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataEntrada"), filter.dataEntradaFim()));
            }
            if (filter.dataSaidaInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataSaida"), filter.dataSaidaInicio()));
            }
            if (filter.dataSaidaFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataSaida"), filter.dataSaidaFim()));
            }
            if (filter.observacao() != null && !filter.observacao().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("observacao")), "%" + filter.observacao().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (VeiculoPatio)
            if (filter.veiculoPlaca() != null && !filter.veiculoPlaca().isBlank()) {
                Join<Patio, VeiculoPatio> veiculoPatioJoin = root.join("veiculoPatios");
                predicates.add(cb.equal(veiculoPatioJoin.get("veiculo").get("placa"), filter.veiculoPlaca()));
            }

            // Filtro por relacionamento ManyToMany (EnderecoPatio)
            if (filter.enderecoCidade() != null && !filter.enderecoCidade().isBlank()) {
                Join<Patio, EnderecoPatio> enderecoPatioJoin = root.join("enderecoPatios");
                predicates.add(cb.like(cb.lower(enderecoPatioJoin.get("endereco").get("cidade")), "%" + filter.enderecoCidade().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (ContatoPatio)
            if (filter.contatoEmail() != null && !filter.contatoEmail().isBlank()) {
                Join<Patio, ContatoPatio> contatoPatioJoin = root.join("contatoPatios");
                predicates.add(cb.like(cb.lower(contatoPatioJoin.get("contato").get("email")), "%" + filter.contatoEmail().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (ZonaPatio)
            if (filter.zonaNome() != null && !filter.zonaNome().isBlank()) {
                Join<Patio, ZonaPatio> zonaPatioJoin = root.join("zonaPatios");
                predicates.add(cb.like(cb.lower(zonaPatioJoin.get("zona").get("nome")), "%" + filter.zonaNome().toLowerCase() + "%"));
            }

            query.distinct(true); // Evitar duplicaÃ§Ã£o de resultados

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\specification\RastreamentoSpecification.java   |   package br.com.fiap.mottu.specification   |   class RastreamentoSpecification
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.RastreamentoFilter;
import br.com.fiap.mottu.model.Rastreamento;
import br.com.fiap.mottu.model.relacionamento.VeiculoRastreamento;
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;
import java.math.BigDecimal; // Importe BigDecimal!

public class RastreamentoSpecification {

    public static Specification<Rastreamento> withFilters(RastreamentoFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            // Filtros para IPS
            if (filter.ipsX() != null) {
                predicates.add(cb.equal(root.get("ipsX"), filter.ipsX()));
            }
            if (filter.ipsY() != null) {
                predicates.add(cb.equal(root.get("ipsY"), filter.ipsY()));
            }
            if (filter.ipsZ() != null) {
                predicates.add(cb.equal(root.get("ipsZ"), filter.ipsZ()));
            }

            // Filtros para GPRS
            if (filter.gprsLatitude() != null) {
                predicates.add(cb.equal(root.get("gprsLatitude"), filter.gprsLatitude()));
            }
            if (filter.gprsLongitude() != null) {
                predicates.add(cb.equal(root.get("gprsLongitude"), filter.gprsLongitude()));
            }
            if (filter.gprsAltitude() != null) {
                predicates.add(cb.equal(root.get("gprsAltitude"), filter.gprsAltitude()));
            }

            // Filtro por relacionamento ManyToMany (VeiculoRastreamento)
            if (filter.veiculoPlaca() != null && !filter.veiculoPlaca().isBlank()) {
                Join<Rastreamento, VeiculoRastreamento> veiculoRastreamentoJoin = root.join("veiculoRastreamentos");
                predicates.add(cb.equal(veiculoRastreamentoJoin.get("veiculo").get("placa"), filter.veiculoPlaca()));
            }

            query.distinct(true); // Evitar duplicaÃ§Ã£o de resultados

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\specification\VeiculoSpecification.java   |   package br.com.fiap.mottu.specification   |   class VeiculoSpecification
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\specification\VeiculoSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.VeiculoFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Veiculo;
import br.com.fiap.mottu.model.relacionamento.ClienteVeiculo;
import br.com.fiap.mottu.model.relacionamento.VeiculoBox;
import br.com.fiap.mottu.model.relacionamento.VeiculoPatio;
import br.com.fiap.mottu.model.relacionamento.VeiculoZona;
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class VeiculoSpecification {

    public static Specification<Veiculo> withFilters(VeiculoFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.placa() != null && !filter.placa().isBlank()) {
                predicates.add(cb.equal(root.get("placa"), filter.placa()));
            }
            if (filter.renavam() != null && !filter.renavam().isBlank()) {
                predicates.add(cb.equal(root.get("renavam"), filter.renavam()));
            }
            if (filter.chassi() != null && !filter.chassi().isBlank()) {
                predicates.add(cb.equal(root.get("chassi"), filter.chassi()));
            }
            if (filter.fabricante() != null && !filter.fabricante().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("fabricante")), "%" + filter.fabricante().toLowerCase() + "%"));
            }
            if (filter.modelo() != null && !filter.modelo().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("modelo")), "%" + filter.modelo().toLowerCase() + "%"));
            }
            if (filter.motor() != null && !filter.motor().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("motor")), "%" + filter.motor().toLowerCase() + "%"));
            }
            if (filter.ano() != null) {
                predicates.add(cb.equal(root.get("ano"), filter.ano()));
            }
            if (filter.combustivel() != null && !filter.combustivel().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("combustivel")), "%" + filter.combustivel().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (ClienteVeiculo)
            if (filter.clienteCpf() != null && !filter.clienteCpf().isBlank()) {
                Join<Veiculo, ClienteVeiculo> clienteVeiculoJoin = root.join("clienteVeiculos");
                predicates.add(cb.equal(clienteVeiculoJoin.get("cliente").get("cpf"), filter.clienteCpf()));
            }

            // Filtro por relacionamento ManyToMany (VeiculoBox)
            if (filter.boxNome() != null && !filter.boxNome().isBlank()) {
                Join<Veiculo, VeiculoBox> veiculoBoxJoin = root.join("veiculoBoxes");
                predicates.add(cb.like(cb.lower(veiculoBoxJoin.get("box").get("nome")), "%" + filter.boxNome().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (VeiculoPatio)
            if (filter.patioNome() != null && !filter.patioNome().isBlank()) {
                Join<Veiculo, VeiculoPatio> veiculoPatioJoin = root.join("veiculoPatios");
                predicates.add(cb.like(cb.lower(veiculoPatioJoin.get("patio").get("nomePatio")), "%" + filter.patioNome().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (VeiculoZona)
            if (filter.zonaNome() != null && !filter.zonaNome().isBlank()) {
                Join<Veiculo, VeiculoZona> veiculoZonaJoin = root.join("veiculoZonas");
                predicates.add(cb.like(cb.lower(veiculoZonaJoin.get("zona").get("nome")), "%" + filter.zonaNome().toLowerCase() + "%"));
            }

            query.distinct(true); // Evitar duplicaÃ§Ã£o de resultados

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\mottu\specification\ZonaSpecification.java   |   package br.com.fiap.mottu.specification   |   class ZonaSpecification
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Caminho do arquivo: br\com\fiap\mottu\specification\ZonaSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.ZonaFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Zona;
import br.com.fiap.mottu.model.relacionamento.ZonaBox;
import br.com.fiap.mottu.model.relacionamento.ZonaPatio;
import br.com.fiap.mottu.model.relacionamento.VeiculoZona;
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class ZonaSpecification {

    public static Specification<Zona> withFilters(ZonaFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.nome() != null && !filter.nome().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("nome")), "%" + filter.nome().toLowerCase() + "%"));
            }
            if (filter.dataEntradaInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataEntrada"), filter.dataEntradaInicio()));
            }
            if (filter.dataEntradaFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataEntrada"), filter.dataEntradaFim()));
            }
            if (filter.dataSaidaInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataSaida"), filter.dataSaidaInicio()));
            }
            if (filter.dataSaidaFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataSaida"), filter.dataSaidaFim()));
            }
            if (filter.observacao() != null && !filter.observacao().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("observacao")), "%" + filter.observacao().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (ZonaBox)
            if (filter.boxNome() != null && !filter.boxNome().isBlank()) {
                Join<Zona, ZonaBox> zonaBoxJoin = root.join("zonaBoxes");
                predicates.add(cb.like(cb.lower(zonaBoxJoin.get("box").get("nome")), "%" + filter.boxNome().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (VeiculoZona)
            if (filter.veiculoPlaca() != null && !filter.veiculoPlaca().isBlank()) {
                Join<Zona, VeiculoZona> veiculoZonaJoin = root.join("veiculoZonas");
                predicates.add(cb.equal(veiculoZonaJoin.get("veiculo").get("placa"), filter.veiculoPlaca()));
            }

            // Filtro por relacionamento ManyToMany (ZonaPatio)
            if (filter.patioNome() != null && !filter.patioNome().isBlank()) {
                Join<Zona, ZonaPatio> zonaPatioJoin = root.join("zonaPatios");
                predicates.add(cb.like(cb.lower(zonaPatioJoin.get("patio").get("nomePatio")), "%" + filter.patioNome().toLowerCase() + "%"));
            }

            query.distinct(true); // Evitar duplicaÃ§Ã£o de resultados

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// test\java\br\com\fiap\mottu\MottuApplicationTests.java   |   package br.com.fiap.mottu   |   class MottuApplicationTests
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.mottu;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class MottuApplicationTests {

	@Test
	void contextLoads() {
	}

}

