// Script: converte-classes-java-em-txt-unico (v3)
// Data de criação do arquivo de saída: 2025-05-13 11:48:25

// Estrutura de diretórios do projeto:
main/
    java/
        br/
            com/
                fiap/
                    config/
                        security/
                            jwt/
                    controller/
                        auth/
                    dto/
                        agenda/
                        cliente/
                        contato/
                        endereco/
                        oficina/
                        orcamento/
                        pagamento/
                        pecas/
                        relatorio/
                        security/
                        veiculo/
                    exception/
                    mapper/
                    model/
                        autenticar/
                        relacionamentos/
                    repository/
                        relacionamentos/
                        specification/
                    service/
                        agenda/
                        cep/
                        clientes/
                        ia/
                        oficina/
                        orcamento/
                        pagamento/
                        pecas/
                        relatorio/
                            cliente/
                        security/
                        veiculo/
    resources/
        static/
        templates/

// Arquivos encontrados (FQN => caminho relativo):
// br.com.fiap.App => java\br\com\fiap\App.java
// br.com.fiap.config.SwaggerBrowserLauncher => java\br\com\fiap\config\SwaggerBrowserLauncher.java
// br.com.fiap.config.security.DefaultUserInitializer => java\br\com\fiap\config\security\DefaultUserInitializer.java
// br.com.fiap.config.security.SecurityConfig => java\br\com\fiap\config\security\SecurityConfig.java
// br.com.fiap.config.security.jwt.JwtAuthenticationFilter => java\br\com\fiap\config\security\jwt\JwtAuthenticationFilter.java
// br.com.fiap.config.security.jwt.TokenService => java\br\com\fiap\config\security\jwt\TokenService.java
// br.com.fiap.controller.AgendaController => java\br\com\fiap\controller\AgendaController.java
// br.com.fiap.controller.ClienteRelatorioController => java\br\com\fiap\controller\ClienteRelatorioController.java
// br.com.fiap.controller.ClientesController => java\br\com\fiap\controller\ClientesController.java
// br.com.fiap.controller.IaController => java\br\com\fiap\controller\IaController.java
// br.com.fiap.controller.OficinaController => java\br\com\fiap\controller\OficinaController.java
// br.com.fiap.controller.OrcamentoController => java\br\com\fiap\controller\OrcamentoController.java
// br.com.fiap.controller.PagamentoController => java\br\com\fiap\controller\PagamentoController.java
// br.com.fiap.controller.PecasController => java\br\com\fiap\controller\PecasController.java
// br.com.fiap.controller.RelatorioController => java\br\com\fiap\controller\RelatorioController.java
// br.com.fiap.controller.VeiculoController => java\br\com\fiap\controller\VeiculoController.java
// br.com.fiap.controller.auth.AuthController => java\br\com\fiap\controller\auth\AuthController.java
// br.com.fiap.dto.agenda.AgendaRequestDto => java\br\com\fiap\dto\agenda\AgendaRequestDto.java
// br.com.fiap.dto.agenda.AgendaResponseDto => java\br\com\fiap\dto\agenda\AgendaResponseDto.java
// br.com.fiap.dto.cliente.ClienteInfoDTO => java\br\com\fiap\dto\cliente\ClienteInfoDTO.java
// br.com.fiap.dto.cliente.ClienteRequestDto => java\br\com\fiap\dto\cliente\ClienteRequestDto.java
// br.com.fiap.dto.cliente.ClienteResponseDto => java\br\com\fiap\dto\cliente\ClienteResponseDto.java
// br.com.fiap.dto.contato.ContatoRequestDto => java\br\com\fiap\dto\contato\ContatoRequestDto.java
// br.com.fiap.dto.contato.ContatoResponseDto => java\br\com\fiap\dto\contato\ContatoResponseDto.java
// br.com.fiap.dto.endereco.EnderecoRequestDto => java\br\com\fiap\dto\endereco\EnderecoRequestDto.java
// br.com.fiap.dto.endereco.EnderecoResponseDto => java\br\com\fiap\dto\endereco\EnderecoResponseDto.java
// br.com.fiap.dto.oficina.ItemPecaServicoDto => java\br\com\fiap\dto\oficina\ItemPecaServicoDto.java
// br.com.fiap.dto.oficina.OficinaRequestDto => java\br\com\fiap\dto\oficina\OficinaRequestDto.java
// br.com.fiap.dto.oficina.OficinaResponseDto => java\br\com\fiap\dto\oficina\OficinaResponseDto.java
// br.com.fiap.dto.oficina.ServicoHistoricoResponseDto => java\br\com\fiap\dto\oficina\ServicoHistoricoResponseDto.java
// br.com.fiap.dto.orcamento.OrcamentoComServicoRequestDto => java\br\com\fiap\dto\orcamento\OrcamentoComServicoRequestDto.java
// br.com.fiap.dto.orcamento.OrcamentoRequestDto => java\br\com\fiap\dto\orcamento\OrcamentoRequestDto.java
// br.com.fiap.dto.orcamento.OrcamentoResponseDto => java\br\com\fiap\dto\orcamento\OrcamentoResponseDto.java
// br.com.fiap.dto.pagamento.PagamentoRequestDto => java\br\com\fiap\dto\pagamento\PagamentoRequestDto.java
// br.com.fiap.dto.pagamento.PagamentoResponseDto => java\br\com\fiap\dto\pagamento\PagamentoResponseDto.java
// br.com.fiap.dto.pecas.PecasRequestDto => java\br\com\fiap\dto\pecas\PecasRequestDto.java
// br.com.fiap.dto.pecas.PecasResponseDto => java\br\com\fiap\dto\pecas\PecasResponseDto.java
// br.com.fiap.dto.relatorio.ClienteRelatorioCompletoDTO => java\br\com\fiap\dto\relatorio\ClienteRelatorioCompletoDTO.java
// br.com.fiap.dto.relatorio.ContagemMensalDTO => java\br\com\fiap\dto\relatorio\ContagemMensalDTO.java
// br.com.fiap.dto.relatorio.ContagemMensalResultadoNativo => java\br\com\fiap\dto\relatorio\ContagemMensalResultadoNativo.java
// br.com.fiap.dto.relatorio.EstatisticasPagamentosDto => java\br\com\fiap\dto\relatorio\EstatisticasPagamentosDto.java
// br.com.fiap.dto.relatorio.EvolucaoMensalPagamentoNativo => java\br\com\fiap\dto\relatorio\EvolucaoMensalPagamentoNativo.java
// br.com.fiap.dto.relatorio.EvolucaoMensalValorDto => java\br\com\fiap\dto\relatorio\EvolucaoMensalValorDto.java
// br.com.fiap.dto.relatorio.HistoricoAgendamentoClienteDTO => java\br\com\fiap\dto\relatorio\HistoricoAgendamentoClienteDTO.java
// br.com.fiap.dto.relatorio.PagamentoPorTipoDto => java\br\com\fiap\dto\relatorio\PagamentoPorTipoDto.java
// br.com.fiap.dto.relatorio.ServicoAgendadoDTO => java\br\com\fiap\dto\relatorio\ServicoAgendadoDTO.java
// br.com.fiap.dto.security.LoginRequestDto => java\br\com\fiap\dto\security\LoginRequestDto.java
// br.com.fiap.dto.security.LoginResponseDto => java\br\com\fiap\dto\security\LoginResponseDto.java
// br.com.fiap.dto.security.RegistroUsuarioDto => java\br\com\fiap\dto\security\RegistroUsuarioDto.java
// br.com.fiap.dto.veiculo.VeiculoRequestDto => java\br\com\fiap\dto\veiculo\VeiculoRequestDto.java
// br.com.fiap.dto.veiculo.VeiculoResponseDto => java\br\com\fiap\dto\veiculo\VeiculoResponseDto.java
// br.com.fiap.exception.AgendaNotFoundException => java\br\com\fiap\exception\AgendaNotFoundException.java
// br.com.fiap.exception.AssociacaoNotFoundException => java\br\com\fiap\exception\AssociacaoNotFoundException.java
// br.com.fiap.exception.AutenticarNotFoundException => java\br\com\fiap\exception\AutenticarNotFoundException.java
// br.com.fiap.exception.ClientesNotFoundException => java\br\com\fiap\exception\ClientesNotFoundException.java
// br.com.fiap.exception.ContatoNotFoundException => java\br\com\fiap\exception\ContatoNotFoundException.java
// br.com.fiap.exception.EnderecoNotFoundException => java\br\com\fiap\exception\EnderecoNotFoundException.java
// br.com.fiap.exception.OficinaNotFoundException => java\br\com\fiap\exception\OficinaNotFoundException.java
// br.com.fiap.exception.OrcamentoNotFoundException => java\br\com\fiap\exception\OrcamentoNotFoundException.java
// br.com.fiap.exception.PagamentoNotFoundException => java\br\com\fiap\exception\PagamentoNotFoundException.java
// br.com.fiap.exception.PecasNotFoundException => java\br\com\fiap\exception\PecasNotFoundException.java
// br.com.fiap.exception.VeiculoNotFoundException => java\br\com\fiap\exception\VeiculoNotFoundException.java
// br.com.fiap.mapper.AgendaMapper => java\br\com\fiap\mapper\AgendaMapper.java
// br.com.fiap.mapper.ClienteMapper => java\br\com\fiap\mapper\ClienteMapper.java
// br.com.fiap.mapper.ContatoMapper => java\br\com\fiap\mapper\ContatoMapper.java
// br.com.fiap.mapper.EnderecoMapper => java\br\com\fiap\mapper\EnderecoMapper.java
// br.com.fiap.mapper.OficinaMapper => java\br\com\fiap\mapper\OficinaMapper.java
// br.com.fiap.mapper.OrcamentoMapper => java\br\com\fiap\mapper\OrcamentoMapper.java
// br.com.fiap.mapper.PagamentoMapper => java\br\com\fiap\mapper\PagamentoMapper.java
// br.com.fiap.mapper.PecasMapper => java\br\com\fiap\mapper\PecasMapper.java
// br.com.fiap.mapper.VeiculoMapper => java\br\com\fiap\mapper\VeiculoMapper.java
// br.com.fiap.model.Agenda => java\br\com\fiap\model\Agenda.java
// br.com.fiap.model.Clientes => java\br\com\fiap\model\Clientes.java
// br.com.fiap.model.Contato => java\br\com\fiap\model\Contato.java
// br.com.fiap.model.Endereco => java\br\com\fiap\model\Endereco.java
// br.com.fiap.model.Oficina => java\br\com\fiap\model\Oficina.java
// br.com.fiap.model.Orcamento => java\br\com\fiap\model\Orcamento.java
// br.com.fiap.model.Pagamento => java\br\com\fiap\model\Pagamento.java
// br.com.fiap.model.Pecas => java\br\com\fiap\model\Pecas.java
// br.com.fiap.model.Veiculo => java\br\com\fiap\model\Veiculo.java
// br.com.fiap.model.autenticar.Autenticar => java\br\com\fiap\model\autenticar\Autenticar.java
// br.com.fiap.model.relacionamentos.AgendaOficina => java\br\com\fiap\model\relacionamentos\AgendaOficina.java
// br.com.fiap.model.relacionamentos.AgendaVeiculo => java\br\com\fiap\model\relacionamentos\AgendaVeiculo.java
// br.com.fiap.model.relacionamentos.ClienteId => java\br\com\fiap\model\relacionamentos\ClienteId.java
// br.com.fiap.model.relacionamentos.ClienteOrcamento => java\br\com\fiap\model\relacionamentos\ClienteOrcamento.java
// br.com.fiap.model.relacionamentos.ClientePagamento => java\br\com\fiap\model\relacionamentos\ClientePagamento.java
// br.com.fiap.model.relacionamentos.ClienteVeiculo => java\br\com\fiap\model\relacionamentos\ClienteVeiculo.java
// br.com.fiap.model.relacionamentos.OficinaOrcamento => java\br\com\fiap\model\relacionamentos\OficinaOrcamento.java
// br.com.fiap.model.relacionamentos.OficinaPeca => java\br\com\fiap\model\relacionamentos\OficinaPeca.java
// br.com.fiap.model.relacionamentos.OficinaVeiculo => java\br\com\fiap\model\relacionamentos\OficinaVeiculo.java
// br.com.fiap.model.relacionamentos.PagamentoOrcamento => java\br\com\fiap\model\relacionamentos\PagamentoOrcamento.java
// br.com.fiap.model.relacionamentos.PecaVeiculo => java\br\com\fiap\model\relacionamentos\PecaVeiculo.java
// br.com.fiap.repository.AgendaRepository => java\br\com\fiap\repository\AgendaRepository.java
// br.com.fiap.repository.AutenticarRepository => java\br\com\fiap\repository\AutenticarRepository.java
// br.com.fiap.repository.ClientesRepository => java\br\com\fiap\repository\ClientesRepository.java
// br.com.fiap.repository.ContatoRepository => java\br\com\fiap\repository\ContatoRepository.java
// br.com.fiap.repository.EnderecoRepository => java\br\com\fiap\repository\EnderecoRepository.java
// br.com.fiap.repository.OficinaRepository => java\br\com\fiap\repository\OficinaRepository.java
// br.com.fiap.repository.OrcamentoRepository => java\br\com\fiap\repository\OrcamentoRepository.java
// br.com.fiap.repository.PagamentoRepository => java\br\com\fiap\repository\PagamentoRepository.java
// br.com.fiap.repository.PecasRepository => java\br\com\fiap\repository\PecasRepository.java
// br.com.fiap.repository.VeiculoRepository => java\br\com\fiap\repository\VeiculoRepository.java
// br.com.fiap.repository.relacionamentos.AgendaOficinaRepository => java\br\com\fiap\repository\relacionamentos\AgendaOficinaRepository.java
// br.com.fiap.repository.relacionamentos.AgendaVeiculoRepository => java\br\com\fiap\repository\relacionamentos\AgendaVeiculoRepository.java
// br.com.fiap.repository.relacionamentos.ClienteOrcamentoRepository => java\br\com\fiap\repository\relacionamentos\ClienteOrcamentoRepository.java
// br.com.fiap.repository.relacionamentos.ClientePagamentoRepository => java\br\com\fiap\repository\relacionamentos\ClientePagamentoRepository.java
// br.com.fiap.repository.relacionamentos.ClienteVeiculoRepository => java\br\com\fiap\repository\relacionamentos\ClienteVeiculoRepository.java
// br.com.fiap.repository.relacionamentos.OficinaOrcamentoRepository => java\br\com\fiap\repository\relacionamentos\OficinaOrcamentoRepository.java
// br.com.fiap.repository.relacionamentos.OficinaPecaRepository => java\br\com\fiap\repository\relacionamentos\OficinaPecaRepository.java
// br.com.fiap.repository.relacionamentos.OficinaVeiculoRepository => java\br\com\fiap\repository\relacionamentos\OficinaVeiculoRepository.java
// br.com.fiap.repository.relacionamentos.PagamentoOrcamentoRepository => java\br\com\fiap\repository\relacionamentos\PagamentoOrcamentoRepository.java
// br.com.fiap.repository.relacionamentos.PecaVeiculoRepository => java\br\com\fiap\repository\relacionamentos\PecaVeiculoRepository.java
// br.com.fiap.repository.specification.AgendaSpecification => java\br\com\fiap\repository\specification\AgendaSpecification.java
// br.com.fiap.repository.specification.ClienteSpecification => java\br\com\fiap\repository\specification\ClienteSpecification.java
// br.com.fiap.repository.specification.PagamentoSpecification => java\br\com\fiap\repository\specification\PagamentoSpecification.java
// br.com.fiap.repository.specification.VeiculoSpecification => java\br\com\fiap\repository\specification\VeiculoSpecification.java
// br.com.fiap.service.agenda.AgendaService => java\br\com\fiap\service\agenda\AgendaService.java
// br.com.fiap.service.agenda.AgendaServiceImpl => java\br\com\fiap\service\agenda\AgendaServiceImpl.java
// br.com.fiap.service.cep.CepService => java\br\com\fiap\service\cep\CepService.java
// br.com.fiap.service.clientes.ClienteService => java\br\com\fiap\service\clientes\ClienteService.java
// br.com.fiap.service.clientes.ClienteServiceImpl => java\br\com\fiap\service\clientes\ClienteServiceImpl.java
// br.com.fiap.service.ia.GoogleGeminiService => java\br\com\fiap\service\ia\GoogleGeminiService.java
// br.com.fiap.service.ia.GoogleGeminiServiceImpl => java\br\com\fiap\service\ia\GoogleGeminiServiceImpl.java
// br.com.fiap.service.oficina.OficinaService => java\br\com\fiap\service\oficina\OficinaService.java
// br.com.fiap.service.oficina.OficinaServiceImpl => java\br\com\fiap\service\oficina\OficinaServiceImpl.java
// br.com.fiap.service.orcamento.OrcamentoService => java\br\com\fiap\service\orcamento\OrcamentoService.java
// br.com.fiap.service.orcamento.OrcamentoServiceImpl => java\br\com\fiap\service\orcamento\OrcamentoServiceImpl.java
// br.com.fiap.service.pagamento.PagamentoService => java\br\com\fiap\service\pagamento\PagamentoService.java
// br.com.fiap.service.pagamento.PagamentoServiceImpl => java\br\com\fiap\service\pagamento\PagamentoServiceImpl.java
// br.com.fiap.service.pecas.PecasService => java\br\com\fiap\service\pecas\PecasService.java
// br.com.fiap.service.pecas.PecasServiceImpl => java\br\com\fiap\service\pecas\PecasServiceImpl.java
// br.com.fiap.service.relatorio.RelatorioService => java\br\com\fiap\service\relatorio\RelatorioService.java
// br.com.fiap.service.relatorio.RelatorioServiceImpl => java\br\com\fiap\service\relatorio\RelatorioServiceImpl.java
// br.com.fiap.service.relatorio.cliente.RelatorioClienteService => java\br\com\fiap\service\relatorio\cliente\RelatorioClienteService.java
// br.com.fiap.service.relatorio.cliente.RelatorioClienteServiceImpl => java\br\com\fiap\service\relatorio\cliente\RelatorioClienteServiceImpl.java
// br.com.fiap.service.security.AutenticarUserDetailsService => java\br\com\fiap\service\security\AutenticarUserDetailsService.java
// br.com.fiap.service.veiculo.VeiculoService => java\br\com\fiap\service\veiculo\VeiculoService.java
// br.com.fiap.service.veiculo.VeiculoServiceImpl => java\br\com\fiap\service\veiculo\VeiculoServiceImpl.java

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\App.java   |   package br.com.fiap   |   class App
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap;

import io.swagger.v3.oas.annotations.OpenAPIDefinition;
import io.swagger.v3.oas.annotations.info.Info;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean; // <-- Importar @Bean
import org.springframework.context.annotation.ComponentScan;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.web.client.RestTemplate; // <-- Importar RestTemplate

@EnableJpaRepositories
@SpringBootApplication
// @ComponentScan(basePackages = "br.com.fiap")
@EnableCaching
@OpenAPIDefinition(info = @Info(title = "PROJETO-SEMESTRAL-1.0", description = "REFATORAÇÃO DO CHALLENGE 2024", version = "v1"))
public class App {

	public static void main(String[] args) {
		SpringApplication.run(App.class, args);
	}

	// Adiciona este método para criar o Bean do RestTemplate
	@Bean
	public RestTemplate restTemplate() {
		return new RestTemplate();
	}

}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\config\SwaggerBrowserLauncher.java   |   package br.com.fiap.config   |   class SwaggerBrowserLauncher
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.config; // Ou o pacote que preferir

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

import java.awt.Desktop;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;

@Component
public class SwaggerBrowserLauncher {

    private static final Logger log = LoggerFactory.getLogger(SwaggerBrowserLauncher.class);

    // Pega a porta do servidor do application.properties ou usa 8080 como padrão
    @Value("${server.port:8080}")
    private String serverPort;

    // Pega o contexto da aplicação (se houver) do application.properties
    @Value("${server.servlet.context-path:}")
    private String contextPath;

    // Pega o path da UI do Swagger do application.properties ou usa o padrão do Springdoc
    @Value("${springdoc.swagger-ui.path:/swagger-ui.html}") // Padrão do Springdoc
    private String swaggerUiPath;

    // Condição para habilitar/desabilitar a abertura automática
    @Value("${app.launch-swagger-on-startup:true}") // Adicione esta propriedade no application.properties
    private boolean launchSwaggerOnStartup;

    @EventListener(ApplicationReadyEvent.class)
    public void launchBrowserOnStartup() {
        if (!launchSwaggerOnStartup) {
            log.info("Abertura automática do Swagger no navegador está desabilitada.");
            return;
        }

        // Remove barras iniciais/finais duplicadas do contextPath e swaggerUiPath
        String cleanContextPath = contextPath.startsWith("/") ? contextPath : "/" + contextPath;
        if (cleanContextPath.endsWith("/")) {
            cleanContextPath = cleanContextPath.substring(0, cleanContextPath.length() - 1);
        }

        String cleanSwaggerUiPath = swaggerUiPath.startsWith("/") ? swaggerUiPath : "/" + swaggerUiPath;


        String url = "http://localhost:" + serverPort + cleanContextPath + cleanSwaggerUiPath;
        log.info("Tentando abrir o Swagger UI em: {}", url);

        if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {
            try {
                Desktop.getDesktop().browse(new URI(url));
                log.info("Navegador aberto com sucesso na URL do Swagger UI.");
            } catch (IOException | URISyntaxException e) {
                log.error("Erro ao tentar abrir o navegador para o Swagger UI: {}", e.getMessage());
            }
        } else {
            log.warn("Abertura automática do navegador não é suportada neste ambiente. Acesse manualmente: {}", url);
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\config\security\DefaultUserInitializer.java   |   package br.com.fiap.config.security   |   class DefaultUserInitializer
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.config.security; // <--- PACOTE CORRIGIDO PARA A NOVA LOCALIZAÇÃO

import br.com.fiap.model.autenticar.Autenticar; // Importe a entidade Autenticar
import br.com.fiap.repository.AutenticarRepository; // Importe o repositório Autenticar
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.password.PasswordEncoder; // Importe PasswordEncoder

@Configuration // Marca como classe de configuração (para garantir que o Bean seja criado)
public class DefaultUserInitializer {

    private static final Logger log = LoggerFactory.getLogger(DefaultUserInitializer.class);

    // Defina aqui o usuário e senha padrão que você deseja
    private static final String DEFAULT_USERNAME = "admin";
    private static final String DEFAULT_PASSWORD = "admin123"; // << ATENÇÃO: Use uma senha mais segura em ambientes reais!

    @Autowired
    private AutenticarRepository autenticarRepository; // Injete o repositório

    @Autowired
    private PasswordEncoder passwordEncoder; // Injete o PasswordEncoder

    @Bean
    public CommandLineRunner initDefaultUser() {
        return args -> {
            log.info("Verificando usuário padrão...");

            // Verifica se o usuário padrão já existe
            // Use findByUsuario que adicionamos no AutenticarRepository
            if (autenticarRepository.findByUsuario(DEFAULT_USERNAME).isEmpty()) {
                log.info("Usuário padrão '{}' não encontrado. Criando...", DEFAULT_USERNAME);

                // Cria a nova entidade Autenticar
                Autenticar defaultUser = new Autenticar();
                defaultUser.setUsuario(DEFAULT_USERNAME);
                // Criptografa a senha antes de salvar
                defaultUser.setSenha(passwordEncoder.encode(DEFAULT_PASSWORD));

                try {
                    // Salva o usuário no banco de dados
                    autenticarRepository.save(defaultUser);
                    log.info("Usuário padrão '{}' criado com sucesso.", DEFAULT_USERNAME);
                } catch (Exception e) {
                    log.error("Erro ao criar usuário padrão '{}': {}", DEFAULT_USERNAME, e.getMessage(), e);
                    // Em caso de erro (ex: problema de conexão com BD na inicialização), a aplicação pode falhar.
                    // Considere o tratamento de erro apropriado para o seu caso.
                }
            } else {
                log.info("Usuário padrão '{}' já existe.", DEFAULT_USERNAME);
            }
        };
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\config\security\SecurityConfig.java   |   package br.com.fiap.config.security   |   class SecurityConfig
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.config.security;

import br.com.fiap.config.security.jwt.JwtAuthenticationFilter; // Importe o filtro JWT
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationProvider; // Importe AuthenticationProvider
import org.springframework.security.authentication.dao.DaoAuthenticationProvider; // Importe DaoAuthenticationProvider
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService; // Importe UserDetailsService
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter; // Importe este filtro padrão

@Configuration
@EnableWebSecurity // Habilita a configuração de segurança web do Spring Security
public class SecurityConfig {

    // Injete o filtro JWT que criamos
    private final JwtAuthenticationFilter jwtAuthFilter;
    // Injete o UserDetailsService (o seu AutenticarUserDetailsService)
    private final UserDetailsService userDetailsService;

    // Construtor para injetar as dependências
    public SecurityConfig(JwtAuthenticationFilter jwtAuthFilter, UserDetailsService userDetailsService) {
        this.jwtAuthFilter = jwtAuthFilter;
        this.userDetailsService = userDetailsService;
    }

    // Define a cadeia de filtros de segurança HTTP
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable()) // Desabilita CSRF para APIs REST (stateless)
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) // Configura para não manter estado de sessão (RESTful)
                .authorizeHttpRequests(authorize -> authorize
                        // *** Rotas Públicas (PermitAll) Vêm Primeiro ***

                        // Permitir requisições OPTIONS para /auth/login (pré-voo CORS)
                        .requestMatchers(HttpMethod.OPTIONS, "/auth/login").permitAll() // <--- ADICIONADO!

                        // Endpoint de login (POST - DEVE ser público)
                        .requestMatchers(HttpMethod.POST, "/auth/login").permitAll()

                        // Endpoint de registro (se for público)
                        .requestMatchers(HttpMethod.POST, "/auth/register").permitAll()

                        // Endpoints de IA e CEP (se forem públicos)
                        .requestMatchers("/rest/ia/**").permitAll()
                        .requestMatchers("/rest/cep/**").permitAll()

                        // Documentação Swagger
                        .requestMatchers("/v3/api-docs/**", "/swagger-ui/**", "/swagger-ui.html").permitAll()
                        .requestMatchers("/webjars/**", "/swagger-resources/**").permitAll()
                        // Adicionar outros recursos públicos se houver (ex: arquivos estáticos)
                        // .requestMatchers("/public/**").permitAll()


                        // *** Rotas Protegidas (Authenticated) Vêm Depois ***

                        // Requer autenticação (via JWT) para todos os endpoints /rest/**
                        .requestMatchers("/rest/**").authenticated()

                        // Qualquer outra requisição que não foi explicitamente permitida acima
                        // também requer autenticação por padrão.
                        .anyRequest().authenticated() // Esta regra captura todo o resto
                );
        // ... restante da configuração (authenticationProvider, addFilterBefore) ...

        return http.build();
    }

    // Define o AuthenticationProvider que usará nosso UserDetailsService e PasswordEncoder
    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        // Define o UserDetailsService para carregar os detalhes do usuário
        authProvider.setUserDetailsService(userDetailsService);
        // Define o PasswordEncoder para verificar a senha
        authProvider.setPasswordEncoder(passwordEncoder()); // <--- A CHAMADA ESTÁ AQUI
        return authProvider;
    }

    // Define o encoder de senha (BCrypt é recomendado)
    @Bean // <--- A DEFINIÇÃO DO MÉTODO ESTÁ AQUI
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    // Exponha o AuthenticationManager (necessário para autenticar o usuário no endpoint /auth/login)
    @Bean
    public org.springframework.security.authentication.AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\config\security\jwt\JwtAuthenticationFilter.java   |   package br.com.fiap.config.security.jwt   |   class JwtAuthenticationFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.config.security.jwt;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.lang.NonNull; // Usar @NonNull para indicar que parâmetros não devem ser nulos
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter; // Garante que o filtro roda uma vez por requisição

import java.io.IOException;

@Component // Marca como um componente Spring
public class JwtAuthenticationFilter extends OncePerRequestFilter { // Extende OncePerRequestFilter

    @Autowired // Injete o TokenService que criamos
    private TokenService tokenService;

    @Autowired // Injete o UserDetailsService para carregar os detalhes do usuário
    private UserDetailsService userDetailsService;

    /**
     * Este método é executado uma vez para cada requisição HTTP.
     * Ele verifica se a requisição contém um token JWT válido.
     * @param request A requisição HTTP.
     * @param response A resposta HTTP.
     * @param filterChain A cadeia de filtros.
     */
    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest request, // @NonNull indica que o parâmetro não deve ser nulo
            @NonNull HttpServletResponse response,
            @NonNull FilterChain filterChain
    ) throws ServletException, IOException {

        // 1. Tenta obter o cabeçalho Authorization
        final String authHeader = request.getHeader("Authorization");
        final String jwt;
        final String userEmail; // Usaremos o nome de usuário (email ou login) aqui

        // Verifica se o cabeçalho existe e começa com "Bearer "
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            // Se não houver token Bearer, passa para o próximo filtro na cadeia
            filterChain.doFilter(request, response);
            return; // Sai do método
        }

        // 2. Extrai o token JWT (removendo o prefixo "Bearer ")
        jwt = authHeader.substring(7); // "Bearer " tem 7 caracteres

        // 3. Extrai o nome de usuário do token
        // Se houver algum erro na extração (token inválido, etc.), o TokenService pode lançar exceções.
        // Podemos adicionar tratamento de exceção aqui se necessário, mas por enquanto,
        // deixaremos as exceções serem tratadas pelo Spring Security ou por um GlobalExceptionHandler.
        userEmail = tokenService.extractUsername(jwt);

        // 4. Verifica se o nome de usuário foi extraído E se o usuário NÃO está autenticado no contexto de segurança atual
        // SecurityContextHolder.getContext().getAuthentication() == null verifica se o usuário já foi autenticado nesta requisição
        if (userEmail != null && SecurityContextHolder.getContext().getAuthentication() == null) {

            // 5. Carrega os detalhes do usuário usando o UserDetailsService
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(userEmail);

            // 6. Valida o token
            if (tokenService.isTokenValid(jwt, userDetails)) {
                // Se o token for válido, cria um objeto de autenticação
                // UsernamePasswordAuthenticationToken é a implementação padrão
                // Passamos userDetails, credenciais (null para JWT, pois já autenticamos pelo token)
                // e as authorities (papéis/permissões) do usuário.
                UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                        userDetails,
                        null, // Credenciais são null para JWT após validação
                        userDetails.getAuthorities() // Papéis/Authorities do usuário
                );

                // Adiciona detalhes da requisição ao objeto de autenticação (opcional, mas boa prática)
                authToken.setDetails(
                        new WebAuthenticationDetailsSource().buildDetails(request)
                );

                // 7. Define o objeto de autenticação no SecurityContextHolder
                // Isso informa ao Spring Security que o usuário atual está autenticado
                // para esta requisição.
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }

        // 8. Continua a cadeia de filtros
        // Passa a requisição (agora possivelmente autenticada) para o próximo filtro
        filterChain.doFilter(request, response);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\config\security\jwt\TokenService.java   |   package br.com.fiap.config.security.jwt   |   class TokenService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.config.security.jwt;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import java.security.Key;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

@Service // Marca como um serviço Spring
public class TokenService {

    // Chave secreta para assinar e verificar os tokens
    // É ALTAMENTE recomendado que esta chave seja armazenada de forma segura
    // (ex: em variáveis de ambiente, HashiCorp Vault, etc.) e NÃO HARDCODADA!
    // Por enquanto, usaremos uma chave do application.properties
    @Value("${jwt.secret}") // Injeta o valor da propriedade 'jwt.secret'
    private String secret;

    // Tempo de expiração do token em milissegundos (ex: 24 horas)
    @Value("${jwt.expiration}") // Injeta o valor da propriedade 'jwt.expiration'
    private long expiration;

    /**
     * Extrai o nome de usuário (subject) do token JWT.
     * @param token O token JWT.
     * @return O nome de usuário.
     */
    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    /**
     * Extrai um claim específico do token JWT.
     * @param token O token JWT.
     * @param claimsResolver Função para resolver o claim.
     * @param <T> Tipo do claim.
     * @return O valor do claim.
     */
    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    /**
     * Extrai todos os claims do token JWT.
     * Requer a chave de assinatura.
     * @param token O token JWT.
     * @return Todos os claims.
     */
    private Claims extractAllClaims(String token) {
        return Jwts
                .parserBuilder()
                .setSigningKey(getSigningKey()) // Usa a chave de assinatura
                .build()
                .parseClaimsJws(token)
                .getBody(); // Retorna o corpo com os claims
    }

    /**
     * Obtém a chave de assinatura a partir da chave secreta.
     * A chave secreta deve ser codificada em Base64.
     * @return A chave de assinatura.
     */
    private Key getSigningKey() {
        byte[] keyBytes = Decoders.BASE64.decode(secret); // Decodifica a chave secreta Base64
        return Keys.hmacShaKeyFor(keyBytes); // Cria uma chave HMAC SHA a partir dos bytes
    }


    /**
     * Gera um token JWT para um UserDetails.
     * @param userDetails Os detalhes do usuário.
     * @return O token JWT.
     */
    public String generateToken(UserDetails userDetails) {
        // Claims extras podem ser adicionados aqui, como papéis/autoridades
        return generateToken(new HashMap<>(), userDetails);
    }

    /**
     * Gera um token JWT com claims extras.
     * @param extraClaims Claims adicionais.
     * @param userDetails Os detalhes do usuário.
     * @return O token JWT.
     */
    public String generateToken(Map<String, Object> extraClaims, UserDetails userDetails) {
        return Jwts
                .builder()
                .setClaims(extraClaims) // Adiciona claims extras
                .setSubject(userDetails.getUsername()) // Define o nome de usuário como subject
                .setIssuedAt(new Date(System.currentTimeMillis())) // Define a data de emissão
                .setExpiration(new Date(System.currentTimeMillis() + expiration)) // Define a data de expiração
                .signWith(getSigningKey(), SignatureAlgorithm.HS256) // Assina o token com a chave e algoritmo HS256
                .compact(); // Compacta para a string final do token
    }

    /**
     * Verifica se o token JWT é válido.
     * @param token O token JWT.
     * @param userDetails Os detalhes do usuário para comparação.
     * @return true se o token for válido, false caso contrário.
     */
    public boolean isTokenValid(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        // Verifica se o nome de usuário no token corresponde ao UserDetails
        // e se o token não expirou.
        return (username.equals(userDetails.getUsername())) && !isTokenExpired(token);
    }

    /**
     * Verifica se o token JWT expirou.
     * @param token O token JWT.
     * @return true se o token expirou, false caso contrário.
     */
    private boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date()); // Compara a data de expiração com a data atual
    }

    /**
     * Extrai a data de expiração do token JWT.
     * @param token O token JWT.
     * @return A data de expiração.
     */
    private Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\controller\AgendaController.java   |   package br.com.fiap.controller   |   class AgendaController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/main/java/br/com/fiap/Controller/AgendaController.java
package br.com.fiap.controller;

import br.com.fiap.dto.agenda.AgendaRequestDto;
import br.com.fiap.dto.agenda.AgendaResponseDto;
import br.com.fiap.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.exception.AgendaNotFoundException;
import br.com.fiap.exception.AssociacaoNotFoundException;
import br.com.fiap.exception.VeiculoNotFoundException;
import br.com.fiap.service.agenda.AgendaService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag; // <<< Importar Tag
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.time.LocalDate;
import java.util.List;

@RestController
@RequestMapping("/rest/agenda")
@CrossOrigin(origins = "http://localhost:3000")
@Tag(name = "Agendamentos", description = "Operações relacionadas a agendamentos de serviços") // <<< TAG ATUALIZADA
public class AgendaController {

    private static final Logger log = LoggerFactory.getLogger(AgendaController.class);

    @Autowired
    private AgendaService agendaService;

    @GetMapping
    @Operation(summary = "Listar Agendamentos",
            description = "Retorna uma lista paginada de agendamentos, com opções de filtro por data e observação. Parâmetros de paginação: ?page=0&size=10&sort=dataAgendamento,desc")
    @ApiResponses(value = { // <<< ApiResponses Adicionadas/Revisadas
            @ApiResponse(responseCode = "200", description = "Lista de agendamentos retornada"),
            @ApiResponse(responseCode = "204", description = "Nenhum agendamento encontrado para os filtros"),
            @ApiResponse(responseCode = "400", description = "Parâmetros de filtro ou paginação inválidos"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<Page<AgendaResponseDto>> findWithFilters(
            @Parameter(description = "Filtrar por data inicial (formato YYYY-MM-DD)") @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate dataInicio,
            @Parameter(description = "Filtrar por data final (formato YYYY-MM-DD)") @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate dataFim,
            @Parameter(description = "Filtrar por parte da observação (case-insensitive)") @RequestParam(required = false) String observacao,
            @Parameter(hidden = true) Pageable pageable
    ) {
        log.info("Requisição GET /rest/agenda com filtros e paginação recebida.");
        Page<AgendaResponseDto> paginaAgendas = agendaService.findWithFilters(dataInicio, dataFim, observacao, pageable);
        if (paginaAgendas.isEmpty()) {
            return ResponseEntity.noContent().build();
        }
        return ResponseEntity.ok(paginaAgendas);
    }

    @GetMapping("/{id}")
    @Operation(summary = "Buscar Agendamento por ID", description = "Retorna um agendamento específico pelo seu ID.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Agendamento encontrado"),
            @ApiResponse(responseCode = "404", description = "Agendamento não encontrado para o ID fornecido"), // Descrição adicionada
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<AgendaResponseDto> findById(
            @Parameter(description = "ID do agendamento a ser buscado") @PathVariable Long id // <<< @Parameter adicionado
    ) {
        try {
            AgendaResponseDto agenda = agendaService.findById(id);
            return ResponseEntity.ok(agenda);
        } catch (AgendaNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PostMapping
    @CacheEvict(value = {"agendas", "veiculosDaAgenda"}, allEntries = true)
    @Operation(summary = "Criar Novo Agendamento", description = "Registra um novo agendamento no sistema.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Agendamento criado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Dados inválidos fornecidos para o agendamento"), // Descrição adicionada
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar criar o agendamento")
    })
    public ResponseEntity<?> create(
            @Parameter(description = "Dados do agendamento para criação") // <<< @Parameter adicionado
            @RequestBody @Valid AgendaRequestDto agendaDto
    ) {
        try {
            AgendaResponseDto savedAgenda = agendaService.create(agendaDto);
            return ResponseEntity.status(HttpStatus.CREATED).body(savedAgenda);
        } catch (Exception e) {
            // Simplificado para retornar apenas o status 500, o log de erro está no service
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PutMapping("/{id}")
    @CacheEvict(value = {"agendas", "veiculosDaAgenda"}, allEntries = true)
    @Operation(summary = "Atualizar Agendamento", description = "Atualiza os dados de um agendamento existente.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Agendamento atualizado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Dados inválidos fornecidos para atualização"),
            @ApiResponse(responseCode = "404", description = "Agendamento não encontrado para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar atualizar o agendamento")
    })
    public ResponseEntity<?> update(
            @Parameter(description = "ID do agendamento a ser atualizado") @PathVariable Long id, // <<< @Parameter adicionado
            @Parameter(description = "Dados atualizados do agendamento") @RequestBody @Valid AgendaRequestDto agendaDto // <<< @Parameter adicionado
    ) {
        try {
            AgendaResponseDto updatedAgenda = agendaService.update(id, agendaDto);
            return ResponseEntity.ok(updatedAgenda);
        } catch (AgendaNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @DeleteMapping("/{id}")
    @CacheEvict(value = {"agendas", "veiculosDaAgenda"}, allEntries = true)
    @Operation(summary = "Deletar Agendamento", description = "Remove um agendamento do sistema.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Agendamento deletado com sucesso"),
            @ApiResponse(responseCode = "404", description = "Agendamento não encontrado para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar deletar o agendamento") // Ou 409 se houver conflito de integridade
    })
    public ResponseEntity<Void> delete(
            @Parameter(description = "ID do agendamento a ser deletado") @PathVariable Long id // <<< @Parameter adicionado
    ) {
        try {
            agendaService.deleteById(id);
            return ResponseEntity.noContent().build();
        } catch (AgendaNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            // Poderia verificar DataIntegrityViolationException e retornar 409 Conflict
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    // --- Endpoints de Relacionamento ---
    @PostMapping("/{agendaId}/veiculos/{veiculoId}")
    @CacheEvict(value = "veiculosDaAgenda", key = "#agendaId")
    @Operation(summary = "Associar Veículo a uma Agenda", description = "Cria uma associação entre um agendamento e um veículo existentes.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Associação criada com sucesso"),
            @ApiResponse(responseCode = "404", description = "Agenda ou Veículo não encontrado com os IDs fornecidos")
            // Poderia adicionar 409 se a associação já existir
    })
    public ResponseEntity<Void> associarVeiculo(
            @Parameter(description = "ID da agenda") @PathVariable Long agendaId,
            @Parameter(description = "ID do veículo a ser associado") @PathVariable Long veiculoId
    ) {
        log.info("Requisição para associar veículo ID {} à agenda ID {}", veiculoId, agendaId);
        try {
            agendaService.associarVeiculo(agendaId, veiculoId);
            return ResponseEntity.noContent().build();
        } catch (AgendaNotFoundException | VeiculoNotFoundException e) {
            log.warn("Erro ao associar veículo {} à agenda {}: {}", veiculoId, agendaId, e.getMessage());
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro inesperado ao associar veículo {} à agenda {}: {}", veiculoId, agendaId, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @DeleteMapping("/{agendaId}/veiculos/{veiculoId}")
    @CacheEvict(value = "veiculosDaAgenda", key = "#agendaId")
    @Operation(summary = "Desassociar Veículo de uma Agenda", description = "Remove a associação entre um agendamento e um veículo.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Associação removida com sucesso"),
            @ApiResponse(responseCode = "404", description = "Associação não encontrada entre a Agenda e o Veículo fornecidos")
    })
    public ResponseEntity<Void> desassociarVeiculo(
            @Parameter(description = "ID da agenda") @PathVariable Long agendaId,
            @Parameter(description = "ID do veículo a ser desassociado") @PathVariable Long veiculoId
    ) {
        log.info("Requisição para desassociar veículo ID {} da agenda ID {}", veiculoId, agendaId);
        try {
            agendaService.desassociarVeiculo(agendaId, veiculoId);
            return ResponseEntity.noContent().build();
        } catch (AssociacaoNotFoundException e) {
            log.warn("Erro ao desassociar veículo {} da agenda {}: {}", veiculoId, agendaId, e.getMessage());
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro inesperado ao desassociar veículo {} da agenda {}: {}", veiculoId, agendaId, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @GetMapping("/{agendaId}/veiculos")
    @Operation(summary = "Listar Veículos de uma Agenda", description = "Retorna a lista de veículos associados a um agendamento específico.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Lista de veículos retornada (pode ser vazia)"),
            @ApiResponse(responseCode = "404", description = "Agenda não encontrada com o ID fornecido")
    })
    public ResponseEntity<List<VeiculoResponseDto>> findVeiculosByAgendaId(
            @Parameter(description = "ID da agenda para a qual listar os veículos") @PathVariable Long agendaId
    ) {
        log.info("Requisição para listar veículos da agenda ID {}", agendaId);
        try {
            List<VeiculoResponseDto> veiculos = agendaService.findVeiculosByAgendaId(agendaId);
            return ResponseEntity.ok(veiculos); // Retorna 200 OK mesmo se a lista for vazia
        } catch (AgendaNotFoundException e) {
            log.warn("Agenda não encontrada para listar veículos, ID: {}", agendaId);
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro inesperado ao listar veículos da agenda {}: {}", agendaId, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\controller\ClienteRelatorioController.java   |   package br.com.fiap.controller   |   class ClienteRelatorioController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// --- Arquivo: src/main/java/br/com/fiap/controller/ClienteRelatorioController.java ---
package br.com.fiap.controller;

import br.com.fiap.dto.relatorio.ClienteRelatorioCompletoDTO;
import br.com.fiap.exception.ClientesNotFoundException;
import br.com.fiap.service.relatorio.cliente.RelatorioClienteService; // Importa o serviço de relatório
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/rest/relatorios/cliente") // <<< Novo RequestMapping base para relatórios de cliente
@CrossOrigin(origins = "http://localhost:3000")
@Tag(name = "Relatórios Cliente", description = "Endpoints para gerar relatórios específicos de clientes") // <<< Nova Tag
public class ClienteRelatorioController {

    private static final Logger log = LoggerFactory.getLogger(ClienteRelatorioController.class);

    @Autowired
    private RelatorioClienteService relatorioClienteService; // <<< Injeta o serviço de relatório

    @GetMapping("/completo") // <<< Endpoint relativo ao RequestMapping da classe
    @Operation(summary = "Relatório Completo do Cliente", description = "Busca todos os dados relacionados a um cliente por ID ou Documento.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Relatório gerado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Parâmetros de busca inválidos"),
            @ApiResponse(responseCode = "404", description = "Cliente não encontrado"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<ClienteRelatorioCompletoDTO> getRelatorioCompleto(
            @Parameter(description = "Tipo de busca: 'id' para ID_CLI ou 'documento' para CPF/CNPJ", required = true, example = "documento")
            @RequestParam String tipoBusca,
            @Parameter(description = "Valor correspondente ao tipo de busca", required = true, example = "12345678900")
            @RequestParam String valorBusca
    ) {
        log.info("Requisição GET /rest/relatorios/cliente/completo: tipo={}, valor={}", tipoBusca, valorBusca);
        try {
            ClienteRelatorioCompletoDTO relatorio = relatorioClienteService.getRelatorioCompletoCliente(tipoBusca, valorBusca);
            return ResponseEntity.ok(relatorio);
        } catch (ClientesNotFoundException e) {
            log.warn("Cliente não encontrado para relatório: tipo={}, valor={}", tipoBusca, valorBusca);
            return ResponseEntity.notFound().build(); // 404
        } catch (IllegalArgumentException e) {
            log.warn("Argumento inválido para relatório: {}", e.getMessage());
            // Retorna 400 com a mensagem de erro no corpo para o frontend
            return ResponseEntity.badRequest().body(null); // Corpo vazio ou pode criar um DTO de erro { "error": e.getMessage() }
        } catch (Exception e) {
            log.error("Erro ao gerar relatório completo para cliente: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build(); // 500
        }
    }

}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\controller\ClientesController.java   |   package br.com.fiap.controller   |   class ClientesController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// --- Arquivo: src/main/java/br/com/fiap/controller/ClientesController.java ---
package br.com.fiap.controller;

import br.com.fiap.dto.veiculo.VeiculoResponseDto;

import br.com.fiap.dto.cliente.ClienteInfoDTO;
import br.com.fiap.dto.cliente.ClienteRequestDto;
import br.com.fiap.dto.cliente.ClienteResponseDto;
import br.com.fiap.exception.ClientesNotFoundException;
import br.com.fiap.exception.AutenticarNotFoundException; // Importe esta exceção
import br.com.fiap.model.relacionamentos.ClienteId;
import br.com.fiap.service.clientes.ClienteService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException; // Importar

import java.util.List;

// ------------------------------------------------------

@RestController
@RequestMapping("/rest/clientes") // Mapping base permanece o mesmo
@CrossOrigin(origins = "http://localhost:3000")
@Tag(name = "Clientes", description = "Gerenciamento de clientes e seus dados associados")
public class ClientesController {

    private static final Logger log = LoggerFactory.getLogger(ClientesController.class);

    @Autowired
    private ClienteService clienteService; // <<< Apenas ClienteService injetado

    // --- Endpoint de Busca de Clientes (Existente) ---
    @GetMapping("/buscar")
    @Operation(summary = "Buscar Clientes por Critérios",
            description = "Retorna uma lista de clientes (com IDs e dados básicos) que correspondem aos critérios fornecidos (nome, documento ou ID Cliente). Pelo menos um critério deve ser informado.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Busca realizada com sucesso, retornando lista de clientes"),
            @ApiResponse(responseCode = "204", description = "Nenhum cliente encontrado para os critérios fornecidos"),
            @ApiResponse(responseCode = "400", description = "Nenhum critério de busca válido foi fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<List<ClienteInfoDTO>> buscar(
            @Parameter(description = "Parte do nome ou sobrenome do cliente (case-insensitive)") @RequestParam(required = false) String nome,
            @Parameter(description = "Número exato do documento (CPF/CNPJ)") @RequestParam(required = false) String documento,
            @Parameter(description = "ID exato do cliente (ID_CLI)") @RequestParam(required = false) Long idCliente
    ) {
        log.info("Requisição GET /rest/clientes/buscar: nome={}, documento={}, idCliente={}", nome, documento, idCliente);
        if ((nome == null || nome.isBlank()) && (documento == null || documento.isBlank()) && (idCliente == null || idCliente <= 0)) {
            log.warn("Busca de clientes chamada sem nenhum critério válido.");
            return ResponseEntity.badRequest().build(); // 400
        }
        try {
            List<ClienteInfoDTO> clientes = clienteService.buscarClientes(nome, documento, idCliente);
            if (clientes.isEmpty()) {
                log.info("Nenhum cliente encontrado para os critérios fornecidos.");
                return ResponseEntity.noContent().build(); // 204
            }
            log.info("Retornando {} clientes encontrados.", clientes.size());
            return ResponseEntity.ok(clientes); // 200
        } catch (Exception e) {
            log.error("Erro ao buscar clientes: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build(); // 500
        }
    }

    // --- Endpoints CRUD (Existentes) ---
    @GetMapping("/all")
    @Cacheable("clientes")
    @Operation(summary = "Listar Todos os Clientes", description = "Retorna uma lista completa de todos os clientes cadastrados.")
    @ApiResponses(value = { /* ... */ })
    public ResponseEntity<List<ClienteResponseDto>> findAll() {
        log.info("Requisição para listar todos os clientes recebida");
        List<ClienteResponseDto> clientes = clienteService.findAll();
        if (clientes.isEmpty()) {
            log.info("Nenhum cliente encontrado.");
            return ResponseEntity.noContent().build(); // 204
        }
        log.info("Retornando {} clientes.", clientes.size());
        return ResponseEntity.ok(clientes); // 200
    }

    @GetMapping("/{idCliente}/{idEndereco}")
    @Operation(summary = "Buscar Cliente por ID Composto", description = "Retorna um cliente específico pelo seu ID_CLI e ID_ENDERECO.")
    @ApiResponses(value = { /* ... */ })
    public ResponseEntity<ClienteResponseDto> findById(
            @Parameter(description = "ID numérico do cliente (parte da chave composta)") @PathVariable Long idCliente,
            @Parameter(description = "ID do endereço associado (parte da chave composta)") @PathVariable Long idEndereco
    ) {
        ClienteId id = new ClienteId(idCliente, idEndereco);
        log.info("Requisição para buscar cliente por ID: {}", id);
        try {
            ClienteResponseDto cliente = clienteService.findById(id);
            log.info("Cliente encontrado: {}", id);
            return ResponseEntity.ok(cliente); // 200
        } catch (ClientesNotFoundException e) {
            log.warn("Cliente não encontrado para o ID: {}", id);
            return ResponseEntity.notFound().build(); // 404
        } catch (IllegalArgumentException e) {
            log.warn("ID Composto inválido fornecido: {}: {}", id, e.getMessage());
            return ResponseEntity.badRequest().build(); // 400
        } catch (Exception e) {
            log.error("Erro inesperado ao buscar cliente por ID {}: {}", id, e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build(); // 500
        }
    }

    // --- Método CREATE CORRIGIDO ---
    @PostMapping
    @CacheEvict(value = "clientes", allEntries = true)
    @Operation(summary = "Criar Novo Cliente", description = "Cria um novo registro de cliente, incluindo seu endereço e contato inicial, opcionalmente associado a um usuário de autenticação existente.") // Descrição atualizada
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Cliente criado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Dados inválidos fornecidos ou ID de autenticação inválido"),
            @ApiResponse(responseCode = "404", description = "Credencial de autenticação não encontrada com o ID fornecido"), // Adicionado 404
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar criar o cliente")
    })
    public ResponseEntity<ClienteResponseDto> create(
            @Parameter(description = "Dados completos do cliente para criação")
            @RequestBody @Valid ClienteRequestDto clienteDto,
            // --- ADICIONE ESTE PARÂMETRO ---
            @Parameter(description = "ID opcional da credencial de autenticação existente para associar a este cliente")
            @RequestParam(required = false) Long autenticarId // Recebe o ID da autenticação como parâmetro de requisição opcional
            // -----------------------------
    ) {
        log.info("Requisição para criar novo cliente recebida: {}{}",
                clienteDto.getNome(),
                autenticarId != null ? " com autenticarId: " + autenticarId : "");
        try {
            // --- Chame o serviço com o novo parâmetro ---
            ClienteResponseDto savedCliente = clienteService.create(clienteDto, autenticarId); // Passe o autenticarId para o serviço
            // -------------------------------------------
            log.info("Cliente criado com sucesso com ID_CLI: {}{}",
                    savedCliente.getIdCli(),
                    autenticarId != null ? " associado ao Autenticar ID: " + autenticarId : "");

            return ResponseEntity.status(HttpStatus.CREATED).body(savedCliente); // 201
        } catch (AutenticarNotFoundException e) {
            // Captura a exceção específica do serviço e retorna 404
            log.warn("Erro ao criar cliente: {}", e.getMessage());
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build(); // Retorna 404 Not Found
        }
        catch (Exception e) {
            log.error("Erro ao criar cliente: {}", e.getMessage(), e);
            // Retorna uma resposta de erro mais informativa se possível
            // String message = "Erro interno ao criar cliente. Detalhes: " + e.getMessage();
            // Evita expor stack trace completo, mas dá uma pista
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null); // 500 Internal Server Error
            // Ou retornar um objeto de erro { "error": message }
        }
    }
    // --- Fim do Método CREATE CORRIGIDO ---


    @PutMapping("/{idCliente}/{idEndereco}")
    @CacheEvict(value = "clientes", allEntries = true)
    @Operation(summary = "Atualizar Cliente", description = "Atualiza um cliente existente (e seus dados de endereço/contato associados) pelo seu ID composto.")
    @ApiResponses(value = { /* ... */ })
    public ResponseEntity<ClienteResponseDto> update(
            @Parameter(description = "ID numérico do cliente a ser atualizado") @PathVariable Long idCliente,
            @Parameter(description = "ID do endereço associado ao cliente a ser atualizado") @PathVariable Long idEndereco,
            @Parameter(description = "Dados atualizados do cliente") @RequestBody @Valid ClienteRequestDto clienteDto
    ) {
        ClienteId id = new ClienteId(idCliente, idEndereco);
        log.info("Requisição para atualizar cliente ID: {}", id);
        try {
            // Note: Este método update no Controller NÃO recebe autenticarId,
            // pois a associação de autenticação não é atualizada via este endpoint.
            ClienteResponseDto updatedCliente = clienteService.update(id, clienteDto);
            log.info("Cliente ID {} atualizado com sucesso.", id);
            return ResponseEntity.ok(updatedCliente); // 200
        } catch (ClientesNotFoundException e) {
            log.warn("Cliente não encontrado para atualização, ID: {}", id);
            return ResponseEntity.notFound().build(); // 404
        } catch (IllegalArgumentException e) {
            log.warn("ID Composto inválido fornecido para atualização: {}", id);
            return ResponseEntity.badRequest().build(); // 400
        } catch (Exception e) {
            log.error("Erro ao atualizar cliente ID {}: {}", id, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build(); // 500
        }
    }

    @DeleteMapping("/{idCliente}/{idEndereco}")
    @CacheEvict(value = "clientes", allEntries = true)
    @Operation(summary = "Deletar Cliente", description = "Deleta um cliente existente pelo seu ID composto. ATENÇÃO: Pode falhar se houver dependências.")
    @ApiResponses(value = { /* ... */ })
    public ResponseEntity<Void> delete(
            @Parameter(description = "ID numérico do cliente a ser deletado") @PathVariable Long idCliente,
            @Parameter(description = "ID do endereço associado ao cliente a ser deletado") @PathVariable Long idEndereco
    ) {
        ClienteId id = new ClienteId(idCliente, idEndereco);
        log.info("Requisição para deletar cliente ID: {}", id);
        try {
            clienteService.deleteById(id);
            log.info("Cliente ID {} deletado com sucesso.", id);
            return ResponseEntity.noContent().build(); // 204
        } catch (ClientesNotFoundException e) {
            log.warn("Cliente não encontrado para exclusão, ID: {}", id);
            return ResponseEntity.notFound().build(); // 404
        } catch (IllegalArgumentException e) {
            log.warn("ID Composto inválido fornecido para exclusão: {}", id);
            return ResponseEntity.badRequest().build(); // 400
        } catch (Exception e) { // Captura DataIntegrityViolationException ou outros
            log.error("Erro ao deletar cliente ID {}: {}", id, e.getMessage(), e);
            // Retorna 500, mas poderia retornar 409 (Conflict) se detectar DataIntegrityViolationException especificamente
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    // <<< NOVO ENDPOINT ADICIONADO >>>
    @GetMapping("/{idCliente}/{idEndereco}/veiculos")
    @Operation(summary = "Listar Veículos de um Cliente", description = "Retorna a lista de veículos associados a um cliente específico pelo seu ID composto.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Lista de veículos retornada"),
            @ApiResponse(responseCode = "404", description = "Cliente não encontrado com os IDs fornecidos"),
            @ApiResponse(responseCode = "204", description = "Nenhum veículo encontrado para este cliente (lista vazia)"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<List<VeiculoResponseDto>> getVeiculosByClienteId(
            @Parameter(description = "ID numérico do cliente") @PathVariable Long idCliente,
            @Parameter(description = "ID do endereço associado ao cliente") @PathVariable Long idEndereco
    ) {
        ClienteId clienteIdObj = new ClienteId(idCliente, idEndereco);
        log.info("Requisição GET /rest/clientes/{}/{}/veiculos", idCliente, idEndereco);
        try {
            List<VeiculoResponseDto> veiculos = clienteService.findVeiculosByClienteId(clienteIdObj);
            if (veiculos.isEmpty()) {
                return ResponseEntity.noContent().build(); // 204
            }
            return ResponseEntity.ok(veiculos); // 200
        } catch (ClientesNotFoundException e) {
            log.warn("Cliente não encontrado para listar veículos: {}", clienteIdObj);
            // A exceção ClientesNotFoundException já pode ter @ResponseStatus(HttpStatus.NOT_FOUND)
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, e.getMessage(), e);
        } catch (IllegalArgumentException e) {
            log.warn("Argumento inválido para listar veículos: {}", e.getMessage());
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, e.getMessage(), e);
        } catch (Exception e) {
            log.error("Erro inesperado ao listar veículos do cliente {}: {}", clienteIdObj, e.getMessage(), e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Erro ao listar veículos", e);
        }
    }
    // --- Fim do Novo Endpoint ---


} // Fim da classe ClientesController

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\controller\IaController.java   |   package br.com.fiap.controller   |   class IaController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/main/java/br/com/fiap/Controller/IaController.java
package br.com.fiap.controller;

import br.com.fiap.service.ia.GoogleGeminiService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/rest/ia")
@CrossOrigin(origins = "http://localhost:3000")
@Tag(name = "IA Service", description = "Endpoint para interação com a IA Generativa (Google Gemini)") // Descrição um pouco mais específica
public class IaController {

    private static final Logger log = LoggerFactory.getLogger(IaController.class);
    @Autowired
    private GoogleGeminiService iaService;

    @GetMapping("/diagnostico")
    @Operation(summary = "Gerar Diagnóstico via IA",
            description = "Recebe a descrição de um problema de veículo e retorna um possível diagnóstico, partes afetadas e estimativa de horas, gerados pela IA.") // Descrição atualizada
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Diagnóstico gerado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Descrição do problema não fornecida ou inválida"), // Atualizado
            @ApiResponse(responseCode = "500", description = "Erro interno, falha na comunicação com a IA ou IA não configurada") // Atualizado
    })
    public ResponseEntity<String> gerarDiagnostico(
            @Parameter(description = "Descrição textual do problema do veículo.", required = true, example = "Motor falhando na partida a frio e fumaça branca saindo do escapamento.")
            @RequestParam String descricao
    ) {
        log.info("Requisição para gerar diagnóstico via IA recebida para descrição: '{}'", descricao);
        if (descricao == null || descricao.isBlank()) {
            log.warn("Descrição do problema está vazia.");
            return ResponseEntity.badRequest().body("A descrição do problema é obrigatória."); // Retorna 400
        }
        try {
            String diagnostico = iaService.gerarDiagnostico(descricao);
            // Verifica se o diagnóstico é válido ou uma mensagem de erro/placeholder do serviço
            if (diagnostico != null && !diagnostico.isBlank() && !diagnostico.toLowerCase().contains("erro") && !diagnostico.toLowerCase().contains("não configurado")) {
                log.info("Diagnóstico da IA retornado com sucesso.");
                return ResponseEntity.ok(diagnostico); // 200
            } else {
                log.error("Serviço de IA retornou um erro, placeholder ou diagnóstico inválido: {}", diagnostico);
                // Retorna 500 com a mensagem de erro/placeholder do serviço
                return ResponseEntity.status(500).body(diagnostico != null ? diagnostico : "Erro desconhecido no serviço de IA.");
            }
        } catch (Exception e) {
            log.error("Erro inesperado ao chamar o serviço de IA: {}", e.getMessage(), e);
            return ResponseEntity.status(500).body("Erro interno ao processar solicitação de diagnóstico."); // 500
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\controller\OficinaController.java   |   package br.com.fiap.controller   |   class OficinaController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/main/java/br/com/fiap/Controller/OficinaController.java
package br.com.fiap.controller;

import br.com.fiap.dto.oficina.OficinaRequestDto;
import br.com.fiap.dto.oficina.OficinaResponseDto;
import br.com.fiap.exception.OficinaNotFoundException;
import br.com.fiap.service.oficina.OficinaService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter; // <<< Importar
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag; // <<< Importar
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/rest/oficina")
@CrossOrigin(origins = "http://localhost:3000")
@Tag(name = "Oficina (Diagnósticos)", description = "Operações relacionadas aos registros de diagnóstico da oficina") // <<< TAG ADICIONADA
public class OficinaController {

    private static final Logger log = LoggerFactory.getLogger(OficinaController.class);
    @Autowired
    private OficinaService oficinaService;

    @GetMapping("/all")
    @Cacheable("oficinas")
    @Operation(summary = "Listar Todos os Diagnósticos", description = "Retorna uma lista de todos os registros de diagnósticos da oficina.") // Descrição adicionada
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Lista de registros retornada"),
            @ApiResponse(responseCode = "204", description = "Nenhum registro encontrado"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<List<OficinaResponseDto>> findAll() {
        log.info("Requisição para listar todos os registros de oficina");
        List<OficinaResponseDto> oficinas = oficinaService.findAll();
        if (oficinas.isEmpty()) {
            return ResponseEntity.noContent().build();
        }
        return ResponseEntity.ok(oficinas);
    }

    @GetMapping("/{id}")
    @Operation(summary = "Buscar Diagnóstico por ID", description = "Retorna um registro de diagnóstico específico pelo seu ID.") // Descrição adicionada
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Registro encontrado"),
            @ApiResponse(responseCode = "404", description = "Registro não encontrado para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<OficinaResponseDto> findById(
            @Parameter(description = "ID do registro de oficina a ser buscado") @PathVariable Long id // <<< @Parameter
    ) {
        log.info("Requisição para buscar registro de oficina por ID: {}", id);
        try {
            OficinaResponseDto oficina = oficinaService.findById(id);
            return ResponseEntity.ok(oficina);
        } catch (OficinaNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro inesperado ao buscar registro de oficina ID {}: {}", id, e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PostMapping
    @CacheEvict(value = "oficinas", allEntries = true)
    @Operation(summary = "Criar Novo Diagnóstico", description = "Cria um novo registro de diagnóstico na oficina.") // Descrição adicionada
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Registro criado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Dados inválidos fornecidos"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar criar o registro")
    })
    public ResponseEntity<OficinaResponseDto> create(
            @Parameter(description = "Dados do diagnóstico para criação") @RequestBody @Valid OficinaRequestDto oficinaDto // <<< @Parameter
    ) {
        log.info("Requisição para criar novo registro de oficina: {}", oficinaDto.getDataOficina());
        try {
            OficinaResponseDto savedOficina = oficinaService.create(oficinaDto);
            return ResponseEntity.status(HttpStatus.CREATED).body(savedOficina);
        } catch (Exception e) {
            log.error("Erro ao criar registro de oficina: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PutMapping("/{id}")
    @CacheEvict(value = "oficinas", allEntries = true)
    @Operation(summary = "Atualizar Diagnóstico", description = "Atualiza um registro de diagnóstico existente.") // Descrição adicionada
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Registro atualizado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Dados inválidos fornecidos"),
            @ApiResponse(responseCode = "404", description = "Registro não encontrado para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar atualizar")
    })
    public ResponseEntity<OficinaResponseDto> update(
            @Parameter(description = "ID do registro a ser atualizado") @PathVariable Long id, // <<< @Parameter
            @Parameter(description = "Dados atualizados do diagnóstico") @RequestBody @Valid OficinaRequestDto oficinaDto // <<< @Parameter
    ) {
        log.info("Requisição para atualizar registro de oficina ID: {}", id);
        try {
            OficinaResponseDto updatedOficina = oficinaService.update(id, oficinaDto);
            return ResponseEntity.ok(updatedOficina);
        } catch (OficinaNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro ao atualizar registro de oficina ID {}: {}", id, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @DeleteMapping("/{id}")
    @CacheEvict(value = "oficinas", allEntries = true)
    @Operation(summary = "Deletar Diagnóstico", description = "Remove um registro de diagnóstico.") // Descrição adicionada
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Registro deletado com sucesso"),
            @ApiResponse(responseCode = "404", description = "Registro não encontrado para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar deletar")
    })
    public ResponseEntity<Void> delete(
            @Parameter(description = "ID do registro a ser deletado") @PathVariable Long id // <<< @Parameter
    ) {
        log.info("Requisição para deletar registro de oficina ID: {}", id);
        try {
            oficinaService.deleteById(id);
            return ResponseEntity.noContent().build();
        } catch (OficinaNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro ao deletar registro de oficina ID {}: {}", id, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\controller\OrcamentoController.java   |   package br.com.fiap.controller   |   class OrcamentoController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// br/com/fiap/controller/OrcamentoController.java
package br.com.fiap.controller;

import br.com.fiap.dto.orcamento.OrcamentoComServicoRequestDto;
import br.com.fiap.dto.orcamento.OrcamentoRequestDto; // Para o CRUD simples, se mantido
import br.com.fiap.dto.orcamento.OrcamentoResponseDto;
import br.com.fiap.exception.*; // Importa todas as suas custom exceptions
import br.com.fiap.service.orcamento.OrcamentoService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException; // Import para ResponseStatusException
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.net.URI;
import java.util.List;

@RestController
@RequestMapping("/rest/orcamentos")
@CrossOrigin(origins = "http://localhost:3000")
@Tag(name = "Orçamentos", description = "Operações relacionadas a orçamentos de serviços")
public class OrcamentoController {

    private static final Logger log = LoggerFactory.getLogger(OrcamentoController.class);

    @Autowired
    private OrcamentoService orcamentoService;

    @PostMapping("/completo")
    @Operation(summary = "Registrar Serviço com Orçamento e Peças",
            description = "Cria um novo serviço de oficina com suas peças e um orçamento associado.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Serviço e Orçamento registrados com sucesso",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = OrcamentoResponseDto.class))),
            @ApiResponse(responseCode = "400", description = "Dados inválidos fornecidos"),
            @ApiResponse(responseCode = "404", description = "Entidade relacionada não encontrada (ex: Peça, Cliente, Veículo)"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<OrcamentoResponseDto> registrarServicoComOrcamento(
            @Parameter(description = "Dados completos do serviço da oficina e do orçamento", required = true)
            @Valid @RequestBody OrcamentoComServicoRequestDto dto) {
        log.info("Requisição POST /rest/orcamentos/completo recebida");
        try {
            OrcamentoResponseDto orcamentoSalvo = orcamentoService.registrarServicoComOrcamento(dto);
            URI location = ServletUriComponentsBuilder.fromCurrentContextPath()
                    .path("/rest/orcamentos/{id}")
                    .buildAndExpand(orcamentoSalvo.getId()).toUri();
            log.info("Serviço e Orçamento registrados com sucesso. Orçamento ID: {}", orcamentoSalvo.getId());
            return ResponseEntity.created(location).body(orcamentoSalvo);
        } catch (PecasNotFoundException | OficinaNotFoundException | ClientesNotFoundException | VeiculoNotFoundException e) {
            log.warn("Erro de entidade não encontrada ao registrar serviço com orçamento: {}", e.getMessage());
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, e.getMessage());
        } catch (IllegalArgumentException e) {
            log.warn("Argumento inválido ao registrar serviço com orçamento: {}", e.getMessage());
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, e.getMessage());
        } catch (Exception e) {
            log.error("Erro interno ao registrar serviço com orçamento: {}", e.getMessage(), e);
            // CORREÇÃO: Adicionar o throw ou return aqui
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Erro interno ao processar a solicitação.", e);
        }
    } // Fechamento do método registrarServicoComOrcamento

    // Se você decidir manter o CRUD simples de Orcamento (sem peças/serviço detalhado)
    @PostMapping("/simples")
    @Operation(summary = "Criar Novo Orçamento (Simples)", description = "Cria um novo registro de orçamento apenas com dados de mão de obra.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Orçamento criado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Dados inválidos fornecidos"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar criar o orçamento")
    })
    public ResponseEntity<OrcamentoResponseDto> createOrcamentoSimples(
            @Parameter(description = "Dados do orçamento para criação (apenas mão de obra)")
            @Valid @RequestBody OrcamentoRequestDto dto
    ) {
        log.info("Requisição POST /rest/orcamentos/simples");
        try {
            OrcamentoResponseDto orcamentoSalvo = orcamentoService.create(dto); // Chama o método create que recebe OrcamentoRequestDto
            URI location = ServletUriComponentsBuilder.fromCurrentRequestUri().path("/{id}") // Ajustado para pegar da request atual e adicionar /id
                    .buildAndExpand(orcamentoSalvo.getId()).toUri();
            return ResponseEntity.created(location).body(orcamentoSalvo);
        } catch (Exception e) {
            log.error("Erro ao criar orçamento (simples): {}", e.getMessage(), e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Erro ao processar o cadastro do orçamento (simples).", e);
        }
    }


    @GetMapping
    @Operation(summary = "Listar Todos os Orçamentos (Simples)", description = "Retorna uma lista de todos os orçamentos cadastrados (sem detalhes de peças/serviço).")
    public ResponseEntity<List<OrcamentoResponseDto>> findAll() {
        log.info("Requisição para listar todos os orçamentos (simples)");
        List<OrcamentoResponseDto> orcamentos = orcamentoService.findAll();
        if (orcamentos.isEmpty()) {
            return ResponseEntity.noContent().build();
        }
        return ResponseEntity.ok(orcamentos);
    }

    @GetMapping("/{id}")
    @Operation(summary = "Buscar Orçamento por ID (Simples)", description = "Retorna um orçamento específico pelo seu ID (sem detalhes de peças/serviço).")
    public ResponseEntity<OrcamentoResponseDto> findById(@PathVariable Long id) {
        log.info("Requisição para buscar orçamento (simples) por ID: {}", id);
        // O findById no serviço já lança OrcamentoNotFoundException, que é @ResponseStatus(NOT_FOUND)
        OrcamentoResponseDto orcamento = orcamentoService.findById(id);
        return ResponseEntity.ok(orcamento);
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Deletar Orçamento", description = "Remove um orçamento e suas associações diretas.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Orçamento deletado com sucesso"),
            @ApiResponse(responseCode = "404", description = "Orçamento não encontrado"),
            @ApiResponse(responseCode = "500", description = "Erro interno ou falha de integridade de dados")
    })
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        log.info("Requisição para deletar orçamento ID: {}", id);
        try {
            orcamentoService.deleteById(id);
            return ResponseEntity.noContent().build();
        } catch (OrcamentoNotFoundException e) {
            log.warn("Orçamento não encontrado para deleção: ID {}", id);
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, e.getMessage());
        } catch (Exception e) { // Pode ser DataIntegrityViolationException ou outra
            log.error("Erro ao deletar orçamento ID {}: {}", id, e.getMessage());
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Erro ao deletar orçamento. Verifique dependências.", e);
        }
    }
    // A linha 102 original provavelmente estava aqui, após o fechamento da classe,
    // ou dentro de um método que não foi fechado corretamente.
    // Garantindo que a classe seja fechada corretamente:
} // <<< ESTA É A CHAVE DE FECHAMENTO DA CLASSE OrcamentoController

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\controller\PagamentoController.java   |   package br.com.fiap.controller   |   class PagamentoController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.controller;

import br.com.fiap.dto.pagamento.PagamentoRequestDto;
import br.com.fiap.dto.pagamento.PagamentoResponseDto;
import br.com.fiap.exception.PagamentoNotFoundException;
import br.com.fiap.service.pagamento.PagamentoService;
import io.swagger.v3.oas.annotations.Operation;       // <<< IMPORT
import io.swagger.v3.oas.annotations.Parameter;      // <<< IMPORT
import io.swagger.v3.oas.annotations.media.Content;  // <<< IMPORT (para respostas com corpo)
import io.swagger.v3.oas.annotations.media.Schema;   // <<< IMPORT (para respostas com corpo)
import io.swagger.v3.oas.annotations.responses.ApiResponse; // <<< IMPORT
import io.swagger.v3.oas.annotations.responses.ApiResponses; // <<< IMPORT
import io.swagger.v3.oas.annotations.tags.Tag;           // <<< IMPORT
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.math.BigDecimal;
import java.net.URI;
import java.time.LocalDate;
import java.util.List; // Necessário se for manter o método listarTodos sem paginação

@RestController
@RequestMapping("/rest/pagamentos")
@CrossOrigin(origins = "*") // Ajuste em produção!
@Tag(name = "Pagamentos (Simulado)", description = "Operações para registro e consulta de pagamentos simulados (controle interno).") // <<< TAG
public class PagamentoController {

    private static final Logger log = LoggerFactory.getLogger(PagamentoController.class);

    @Autowired
    private PagamentoService pagamentoService;

    // --- GET /rest/pagamentos (COM FILTROS E PAGINAÇÃO) ---
    @GetMapping
    @Operation(summary = "Listar Pagamentos com Filtros e Paginação",
            description = "Retorna uma lista paginada de pagamentos, com opções de filtro por data, tipo, valor, cliente e orçamento. " +
                    "Parâmetros de paginação: ?page=0&size=10&sort=dataPagamento,desc")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Lista de pagamentos retornada",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = Page.class /* de PagamentoResponseDto */))),
            @ApiResponse(responseCode = "204", description = "Nenhum pagamento encontrado para os filtros aplicados"),
            @ApiResponse(responseCode = "400", description = "Parâmetros de filtro ou paginação inválidos"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<Page<PagamentoResponseDto>> listarPagamentosComFiltro(
            @Parameter(description = "Filtrar por data inicial do pagamento (formato AAAA-MM-DD)")
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate dataInicio,
            @Parameter(description = "Filtrar por data final do pagamento (formato AAAA-MM-DD)")
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate dataFim,
            @Parameter(description = "Filtrar por tipo de pagamento (ex: 'pix', 'credito')")
            @RequestParam(required = false) String tipoPagamento,
            @Parameter(description = "Filtrar por valor mínimo do pagamento (total com desconto)")
            @RequestParam(required = false) BigDecimal valorMin,
            @Parameter(description = "Filtrar por valor máximo do pagamento (total com desconto)")
            @RequestParam(required = false) BigDecimal valorMax,
            @Parameter(description = "ID do cliente para filtrar pagamentos associados")
            @RequestParam(required = false) Long clienteId,
            @Parameter(description = "ID do orçamento para filtrar pagamentos associados")
            @RequestParam(required = false) Long orcamentoId,
            @Parameter(hidden = true) // Pageable é injetado, não precisa aparecer na UI do Swagger como parâmetro manual
            Pageable pageable
    ) {
        log.info("Requisição GET /rest/pagamentos com filtros e paginação recebida.");
        try {
            Page<PagamentoResponseDto> paginaPagamentos = pagamentoService.findWithFilters(
                    dataInicio, dataFim, tipoPagamento, valorMin, valorMax,
                    clienteId, orcamentoId, pageable
            );

            if (paginaPagamentos.isEmpty()) {
                return ResponseEntity.noContent().build();
            }
            return ResponseEntity.ok(paginaPagamentos);

        } catch (IllegalArgumentException e) {
            log.warn("Argumento inválido na busca de pagamentos: {}", e.getMessage());
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, e.getMessage());
        } catch (Exception e) {
            log.error("Erro interno ao buscar pagamentos com filtros: {}", e.getMessage(), e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Erro ao buscar pagamentos.");
        }
    }

    // --- GET /rest/pagamentos/{id} (Buscar por ID) ---
    @GetMapping("/{id}")
    @Operation(summary = "Buscar Pagamento por ID", description = "Retorna um pagamento específico pelo seu ID.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Pagamento encontrado",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = PagamentoResponseDto.class))),
            @ApiResponse(responseCode = "404", description = "Pagamento não encontrado para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<PagamentoResponseDto> buscarPagamentoPorId(
            @Parameter(description = "ID do pagamento a ser buscado", required = true, example = "1") @PathVariable Long id
    ) {
        log.info("Requisição GET /rest/pagamentos/{}", id);
        PagamentoResponseDto pagamento = pagamentoService.buscarPorId(id); // Lança PagamentoNotFoundException se não achar
        log.info("Pagamento ID {} encontrado.", id);
        return ResponseEntity.ok(pagamento);
    }

    // --- POST /rest/pagamentos (Cadastrar novo) ---
    @PostMapping
    @Operation(summary = "Registrar Novo Pagamento", description = "Cria um novo registro de pagamento simulado.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Pagamento registrado com sucesso",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = PagamentoResponseDto.class))),
            @ApiResponse(responseCode = "400", description = "Dados inválidos fornecidos para o registro do pagamento"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar registrar o pagamento")
    })
    public ResponseEntity<PagamentoResponseDto> cadastrarPagamento(
            @Parameter(description = "Dados do pagamento para registro", required = true,
                    schema = @Schema(implementation = PagamentoRequestDto.class))
            @Valid @RequestBody PagamentoRequestDto dto
    ) {
        log.info("Requisição POST /rest/pagamentos");
        try {
            PagamentoResponseDto pagamentoSalvo = pagamentoService.cadastrar(dto);
            log.info("Pagamento cadastrado com ID: {}", pagamentoSalvo.getId());
            URI location = ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}")
                    .buildAndExpand(pagamentoSalvo.getId()).toUri();
            return ResponseEntity.created(location).body(pagamentoSalvo);
        } catch (Exception e) {
            log.error("Erro interno ao cadastrar pagamento: {}", e.getMessage(), e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Erro ao processar o cadastro do pagamento.");
        }
    }

    // --- PUT /rest/pagamentos/{id} (Alterar existente) ---
    @PutMapping("/{id}")
    @Operation(summary = "Alterar Registro de Pagamento", description = "Atualiza um registro de pagamento existente.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Registro de pagamento atualizado com sucesso",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = PagamentoResponseDto.class))),
            @ApiResponse(responseCode = "400", description = "Dados inválidos fornecidos para atualização"),
            @ApiResponse(responseCode = "404", description = "Registro de pagamento não encontrado para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar atualizar o registro")
    })
    public ResponseEntity<PagamentoResponseDto> alterarPagamento(
            @Parameter(description = "ID do pagamento a ser alterado", required = true, example = "1") @PathVariable Long id,
            @Parameter(description = "Dados atualizados do pagamento", required = true,
                    schema = @Schema(implementation = PagamentoRequestDto.class))
            @Valid @RequestBody PagamentoRequestDto dto
    ) {
        log.info("Requisição PUT /rest/pagamentos/{}", id);
        try {
            PagamentoResponseDto pagamentoAtualizado = pagamentoService.alterar(id, dto);
            log.info("Pagamento ID {} alterado.", id);
            return ResponseEntity.ok(pagamentoAtualizado);
        } catch (PagamentoNotFoundException e) { // Captura específica para log
            log.warn("Pagamento não encontrado para alteração com ID: {}", id);
            throw e; // Relança para ser tratado pelo @ResponseStatus da exceção
        } catch (Exception e) {
            log.error("Erro interno ao alterar pagamento {}: {}", id, e.getMessage(), e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Erro ao processar a alteração do pagamento.");
        }
    }

    // --- DELETE /rest/pagamentos/{id} (Deletar) ---
    @DeleteMapping("/{id}")
    @Operation(summary = "Deletar Registro de Pagamento", description = "Remove um registro de pagamento existente.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Registro de pagamento deletado com sucesso"),
            @ApiResponse(responseCode = "404", description = "Registro de pagamento não encontrado para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar deletar o registro")
            // @ApiResponse(responseCode = "409", description = "Conflito de integridade, pagamento associado a outros registros") // Se tratar DataIntegrityViolationException
    })
    public ResponseEntity<Void> deletarPagamento(
            @Parameter(description = "ID do pagamento a ser deletado", required = true, example = "1") @PathVariable Long id
    ) {
        log.info("Requisição DELETE /rest/pagamentos/{}", id);
        try {
            pagamentoService.deletar(id); // Lança PagamentoNotFoundException se não achar
            log.info("Pagamento ID {} deletado.", id);
            return ResponseEntity.noContent().build();
        } catch (PagamentoNotFoundException e) { // Captura específica para log
            log.warn("Pagamento não encontrado para exclusão com ID: {}", id);
            throw e; // Relança para ser tratado pelo @ResponseStatus da exceção
        } catch (Exception e) {
            log.error("Erro interno ao deletar pagamento {}: {}", id, e.getMessage(), e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Erro ao processar a exclusão do pagamento.");
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\controller\PecasController.java   |   package br.com.fiap.controller   |   class PecasController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/main/java/br/com/fiap/Controller/PecasController.java
package br.com.fiap.controller;

import br.com.fiap.dto.pecas.PecasRequestDto;
import br.com.fiap.dto.pecas.PecasResponseDto;
import br.com.fiap.exception.PecasNotFoundException;
import br.com.fiap.service.pecas.PecasService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter; // <<< Importar
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag; // <<< Importar
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/rest/pecas")
@CrossOrigin(origins = "http://localhost:3000")
@Tag(name = "Peças", description = "Operações relacionadas a peças de veículos") // <<< TAG ADICIONADA
public class PecasController {

    private static final Logger log = LoggerFactory.getLogger(PecasController.class);
    @Autowired
    private PecasService pecasService;

    @GetMapping("/all")
    @Cacheable("pecas")
    @Operation(summary = "Listar Todas as Peças", description = "Retorna uma lista de todas as peças cadastradas.") // Descrição
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Lista de peças retornada"),
            @ApiResponse(responseCode = "204", description = "Nenhuma peça encontrada"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<List<PecasResponseDto>> findAll() {
        log.info("Requisição para listar todas as peças");
        List<PecasResponseDto> pecas = pecasService.findAll();
        if (pecas.isEmpty()) { return ResponseEntity.noContent().build(); }
        return ResponseEntity.ok(pecas);
    }

    @GetMapping("/{id}")
    @Operation(summary = "Buscar Peça por ID", description = "Retorna uma peça específica pelo seu ID.") // Descrição
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Peça encontrada"),
            @ApiResponse(responseCode = "404", description = "Peça não encontrada para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<PecasResponseDto> findById(
            @Parameter(description = "ID da peça a ser buscada") @PathVariable Long id // <<< @Parameter
    ) {
        log.info("Requisição para buscar peça por ID: {}", id);
        try {
            PecasResponseDto peca = pecasService.findById(id);
            return ResponseEntity.ok(peca);
        } catch (PecasNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro inesperado ao buscar peça ID {}: {}", id, e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PostMapping
    @CacheEvict(value = "pecas", allEntries = true)
    @Operation(summary = "Criar Nova Peça", description = "Cria um novo registro de peça.") // Descrição
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Peça criada com sucesso"),
            @ApiResponse(responseCode = "400", description = "Dados inválidos fornecidos"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar criar a peça")
    })
    public ResponseEntity<PecasResponseDto> create(
            @Parameter(description = "Dados da peça para criação") @RequestBody @Valid PecasRequestDto pecasDto // <<< @Parameter
    ) {
        log.info("Requisição para criar nova peça: {}", pecasDto.getDescricao());
        try {
            PecasResponseDto savedPeca = pecasService.create(pecasDto);
            return ResponseEntity.status(HttpStatus.CREATED).body(savedPeca);
        } catch (Exception e) {
            log.error("Erro ao criar peça: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PutMapping("/{id}")
    @CacheEvict(value = "pecas", allEntries = true)
    @Operation(summary = "Atualizar Peça", description = "Atualiza uma peça existente.") // Descrição
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Peça atualizada com sucesso"),
            @ApiResponse(responseCode = "400", description = "Dados inválidos fornecidos"),
            @ApiResponse(responseCode = "404", description = "Peça não encontrada para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar atualizar")
    })
    public ResponseEntity<PecasResponseDto> update(
            @Parameter(description = "ID da peça a ser atualizada") @PathVariable Long id, // <<< @Parameter
            @Parameter(description = "Dados atualizados da peça") @RequestBody @Valid PecasRequestDto pecasDto // <<< @Parameter
    ) {
        log.info("Requisição para atualizar peça ID: {}", id);
        try {
            PecasResponseDto updatedPeca = pecasService.update(id, pecasDto);
            return ResponseEntity.ok(updatedPeca);
        } catch (PecasNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro ao atualizar peça ID {}: {}", id, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @DeleteMapping("/{id}")
    @CacheEvict(value = "pecas", allEntries = true)
    @Operation(summary = "Deletar Peça", description = "Remove uma peça.") // Descrição
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Peça deletada com sucesso"),
            @ApiResponse(responseCode = "404", description = "Peça não encontrada para o ID fornecido"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao tentar deletar")
    })
    public ResponseEntity<Void> delete(
            @Parameter(description = "ID da peça a ser deletada") @PathVariable Long id // <<< @Parameter
    ) {
        log.info("Requisição para deletar peça ID: {}", id);
        try {
            pecasService.deleteById(id);
            return ResponseEntity.noContent().build();
        } catch (PecasNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Erro ao deletar peça ID {}: {}", id, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\controller\RelatorioController.java   |   package br.com.fiap.controller   |   class RelatorioController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/main/java/br/com/fiap/controller/RelatorioController.java
package br.com.fiap.controller;

// --- Imports NECESSÁRIOS ---
import br.com.fiap.dto.relatorio.*; // Importa todos os DTOs de relatório
import br.com.fiap.exception.ClientesNotFoundException;
import br.com.fiap.model.relacionamentos.ClienteId;
import br.com.fiap.service.relatorio.RelatorioService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;

import java.time.LocalDate;
import java.util.List;

@RestController
@RequestMapping("/rest/relatorios")
@CrossOrigin(origins = "http://localhost:3000") // Ajuste para sua URL de frontend
@Tag(name = "Relatórios", description = "Endpoints para geração de relatórios consolidados")
public class RelatorioController {

    private static final Logger log = LoggerFactory.getLogger(RelatorioController.class);
    @Autowired
    private RelatorioService relatorioService;

    // Endpoint Contagem Mensal (Existente)
    @GetMapping("/contagem-agendamentos-mensal")
    @Operation(summary = "Relatório de Contagem Mensal de Agendamentos", description = "Retorna a quantidade de agendamentos agrupados por mês/ano.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Contagem retornada com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = ContagemMensalDTO.class))),
            @ApiResponse(responseCode = "204", description = "Nenhum agendamento encontrado no período"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<List<ContagemMensalDTO>> getContagemMensal() {
        log.info("Requisição GET /rest/relatorios/contagem-agendamentos-mensal");
        try {
            List<ContagemMensalDTO> contagem = relatorioService.getContagemMensalAgendamentos();
            if (contagem.isEmpty()) { return ResponseEntity.noContent().build(); }
            return ResponseEntity.ok(contagem);
        } catch (Exception e) {
            log.error("Erro ao gerar relatório de contagem mensal: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    // Endpoint Histórico Cliente (Existente)
    @GetMapping("/historico-cliente/{idCliente}/{idEndereco}")
    @Operation(summary = "Histórico de Agendamentos por Cliente", description = "Retorna o histórico de agendamentos para um cliente específico.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Histórico retornado com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = HistoricoAgendamentoClienteDTO.class))),
            @ApiResponse(responseCode = "204", description = "Nenhum histórico encontrado para o cliente"),
            @ApiResponse(responseCode = "400", description = "IDs de cliente ou endereço inválidos"),
            @ApiResponse(responseCode = "404", description = "Cliente não encontrado"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<List<HistoricoAgendamentoClienteDTO>> getHistoricoCliente(
            @Parameter(description = "ID_CLI do cliente") @PathVariable Long idCliente,
            @Parameter(description = "ENDERECOS_ID_END do cliente") @PathVariable Long idEndereco
    ) {
        ClienteId clienteIdObj = new ClienteId(idCliente, idEndereco);
        log.info("Requisição GET /rest/relatorios/historico-cliente/{}", clienteIdObj);
        try {
            List<HistoricoAgendamentoClienteDTO> historico = relatorioService.getHistoricoAgendamentosCliente(clienteIdObj);
            if (historico.isEmpty()) { return ResponseEntity.noContent().build(); }
            return ResponseEntity.ok(historico);
        } catch (ClientesNotFoundException e) {
            log.warn("Cliente não encontrado para histórico: {}", clienteIdObj);
            return ResponseEntity.notFound().build();
        } catch (IllegalArgumentException e) {
            log.warn("ID inválido para histórico de cliente: {}: {}", clienteIdObj, e.getMessage());
            return ResponseEntity.badRequest().build();
        } catch (Exception e) {
            log.error("Erro ao gerar histórico para cliente {}: {}", clienteIdObj, e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    // Endpoint Serviços Agendados (Existente)
    @GetMapping("/servicos-agendados")
    @Operation(summary = "Relatório de Serviços Agendados", description = "Lista os serviços agendados a partir de uma data, com detalhes do veículo e diagnóstico.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Serviços agendados retornados com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = Page.class))),
            @ApiResponse(responseCode = "204", description = "Nenhum serviço agendado encontrado para os critérios"),
            @ApiResponse(responseCode = "400", description = "Parâmetros de data ou paginação inválidos"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<Page<ServicoAgendadoDTO>> getServicosAgendados(
            @Parameter(description = "Data inicial (AAAA-MM-DD) para buscar serviços. Padrão: data atual.")
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate dataInicio,
            @Parameter(hidden = true) Pageable pageable
    ) {
        LocalDate dataInicioFiltro = (dataInicio != null) ? dataInicio : LocalDate.now();
        log.info("Requisição GET /rest/relatorios/servicos-agendados: dataInicio={}, pageable={}", dataInicioFiltro, pageable);
        try {
            Page<ServicoAgendadoDTO> paginaServicos = relatorioService.findServicosAgendados(dataInicioFiltro, pageable);
            if (paginaServicos.isEmpty()) { return ResponseEntity.noContent().build(); }
            return ResponseEntity.ok(paginaServicos);
        } catch (Exception e) {
            log.error("Erro ao gerar relatório de serviços agendados: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    // --- NOVOS ENDPOINTS PARA RELATÓRIOS DE PAGAMENTO ---

    @GetMapping("/pagamentos/estatisticas")
    @Operation(summary = "Estatísticas Gerais de Pagamentos", description = "Retorna o total de operações, valor total arrecadado e ticket médio dos pagamentos em um período.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Estatísticas retornadas com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = EstatisticasPagamentosDto.class))),
            @ApiResponse(responseCode = "400", description = "Parâmetros de data inválidos"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<EstatisticasPagamentosDto> getEstatisticasPagamentos(
            @Parameter(description = "Data inicial do período (AAAA-MM-DD)", required = true) @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate dataInicio,
            @Parameter(description = "Data final do período (AAAA-MM-DD)", required = true) @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate dataFim
    ) {
        log.info("Requisição GET /rest/relatorios/pagamentos/estatisticas para período: {} a {}", dataInicio, dataFim);
        if (dataInicio == null || dataFim == null || dataFim.isBefore(dataInicio)) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Datas de início e fim são obrigatórias e a data fim não pode ser anterior à data início.");
        }
        try {
            EstatisticasPagamentosDto estatisticas = relatorioService.getEstatisticasPagamentos(dataInicio, dataFim);
            return ResponseEntity.ok(estatisticas);
        } catch (Exception e) {
            log.error("Erro ao gerar estatísticas de pagamentos: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @GetMapping("/pagamentos/por-tipo")
    @Operation(summary = "Pagamentos Agrupados por Tipo", description = "Retorna a quantidade e o valor total de pagamentos agrupados por forma de pagamento em um período.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Dados retornados com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = PagamentoPorTipoDto.class))),
            @ApiResponse(responseCode = "204", description = "Nenhum pagamento encontrado no período"),
            @ApiResponse(responseCode = "400", description = "Parâmetros de data inválidos"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<List<PagamentoPorTipoDto>> getPagamentosPorTipo(
            @Parameter(description = "Data inicial do período (AAAA-MM-DD)", required = true) @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate dataInicio,
            @Parameter(description = "Data final do período (AAAA-MM-DD)", required = true) @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate dataFim
    ) {
        log.info("Requisição GET /rest/relatorios/pagamentos/por-tipo para período: {} a {}", dataInicio, dataFim);
        if (dataInicio == null || dataFim == null || dataFim.isBefore(dataInicio)) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Datas de início e fim são obrigatórias e a data fim não pode ser anterior à data início.");
        }
        try {
            List<PagamentoPorTipoDto> resultado = relatorioService.getPagamentosPorTipo(dataInicio, dataFim);
            if (resultado.isEmpty()) {
                return ResponseEntity.noContent().build();
            }
            return ResponseEntity.ok(resultado);
        } catch (Exception e) {
            log.error("Erro ao gerar relatório de pagamentos por tipo: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @GetMapping("/pagamentos/evolucao-mensal-valor")
    @Operation(summary = "Evolução Mensal do Valor dos Pagamentos", description = "Retorna o valor total de pagamentos agrupados por mês/ano em um período.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Dados retornados com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = EvolucaoMensalValorDto.class))),
            @ApiResponse(responseCode = "204", description = "Nenhum pagamento encontrado no período"),
            @ApiResponse(responseCode = "400", description = "Parâmetros de data inválidos"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<List<EvolucaoMensalValorDto>> getEvolucaoMensalValorPagamentos(
            @Parameter(description = "Data inicial do período (AAAA-MM-DD)", required = true) @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate dataInicio,
            @Parameter(description = "Data final do período (AAAA-MM-DD)", required = true) @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate dataFim
    ) {
        log.info("Requisição GET /rest/relatorios/pagamentos/evolucao-mensal-valor para período: {} a {}", dataInicio, dataFim);
        if (dataInicio == null || dataFim == null || dataFim.isBefore(dataInicio)) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Datas de início e fim são obrigatórias e a data fim não pode ser anterior à data início.");
        }
        try {
            List<EvolucaoMensalValorDto> resultado = relatorioService.getEvolucaoMensalValorPagamentos(dataInicio, dataFim);
            if (resultado.isEmpty()) {
                return ResponseEntity.noContent().build();
            }
            return ResponseEntity.ok(resultado);
        } catch (Exception e) {
            log.error("Erro ao gerar relatório de evolução mensal do valor dos pagamentos: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    // ----------------------------------------------------------
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\controller\VeiculoController.java   |   package br.com.fiap.controller   |   class VeiculoController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.controller

package br.com.fiap.controller;

// Imports necessários
import br.com.fiap.dto.oficina.ServicoHistoricoResponseDto; // DTO para o histórico
import br.com.fiap.dto.veiculo.VeiculoRequestDto;
import br.com.fiap.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.exception.VeiculoNotFoundException;
import br.com.fiap.service.oficina.OficinaService; // <<< SERVIÇO DA OFICINA
import br.com.fiap.service.veiculo.VeiculoService; // <<< SERVIÇO DO VEÍCULO
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;

import java.util.List;

@RestController
@RequestMapping("/rest/veiculo") // Mantendo o path base original
@CrossOrigin(origins = "http://localhost:3000") // Ajuste se necessário
@Tag(name = "Veículos", description = "Operações relacionadas a veículos e seu histórico de serviços") // Tag atualizada
public class VeiculoController {

    private static final Logger log = LoggerFactory.getLogger(VeiculoController.class);

    // Injeção do VeiculoService (já existente)
    @Autowired
    private VeiculoService veiculoService;

    // <<< ADICIONADO: Injeção do OficinaService >>>
    @Autowired
    private OficinaService oficinaService;
    // <<< FIM DA ADIÇÃO >>>

    // --- Endpoints CRUD de Veículo (Existente) ---

    @GetMapping("/all")
    @Cacheable("veiculos")
    @Operation(summary = "Listar ou Buscar Veículos", description = "Retorna veículos, podendo filtrar por placa, modelo ou proprietário.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Lista de veículos retornada"),
            @ApiResponse(responseCode = "204", description = "Nenhum veículo encontrado"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<List<VeiculoResponseDto>> findVeiculos(
            @Parameter(description = "Filtrar por parte da placa") @RequestParam(required = false) String placa,
            @Parameter(description = "Filtrar por parte do modelo") @RequestParam(required = false) String modelo,
            @Parameter(description = "Filtrar por parte do proprietário") @RequestParam(required = false) String proprietario) {
        log.info("Requisição para buscar/listar veículos com filtros: placa='{}', modelo='{}', proprietario='{}'", placa, modelo, proprietario);
        List<VeiculoResponseDto> veiculos;
        if ((placa != null && !placa.isBlank()) || (modelo != null && !modelo.isBlank()) || (proprietario != null && !proprietario.isBlank())) {
            veiculos = veiculoService.buscarVeiculos(placa, modelo, proprietario);
        } else {
            veiculos = veiculoService.findAll();
        }
        if (veiculos.isEmpty()) {
            return ResponseEntity.noContent().build();
        }
        return ResponseEntity.ok(veiculos);
    }

    @GetMapping("/{id}")
    @Operation(summary = "Buscar Veículo por ID", description = "Retorna um veículo específico pelo seu ID.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Veículo encontrado"),
            @ApiResponse(responseCode = "404", description = "Veículo não encontrado"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<VeiculoResponseDto> findById(
            @Parameter(description = "ID do veículo") @PathVariable Long id) {
        log.info("Requisição para buscar veículo por ID: {}", id);
        try {
            VeiculoResponseDto veiculo = veiculoService.findById(id);
            return ResponseEntity.ok(veiculo);
        } catch (VeiculoNotFoundException e) {
            // A exceção já tem @ResponseStatus(NOT_FOUND), mas relançar com ResponseStatusException dá mais controle se necessário
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, e.getMessage(), e);
        } catch (Exception e) {
            log.error("Erro inesperado ao buscar veículo ID {}: {}", id, e.getMessage());
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Erro ao buscar veículo", e);
        }
    }

    @PostMapping
    @CacheEvict(value = "veiculos", allEntries = true)
    @Operation(summary = "Criar Novo Veículo", description = "Cria um novo registro de veículo.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Veículo criado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Dados inválidos fornecidos"),
            @ApiResponse(responseCode = "500", description = "Erro interno ao criar veículo")
    })
    public ResponseEntity<VeiculoResponseDto> create(
            @Parameter(description = "Dados do veículo") @Valid @RequestBody VeiculoRequestDto veiculoDto) {
        log.info("Requisição para criar novo veículo: {}", veiculoDto.getPlaca());
        try {
            VeiculoResponseDto savedVeiculo = veiculoService.create(veiculoDto);
            // Considerar retornar a URI do recurso criado no header Location
            return ResponseEntity.status(HttpStatus.CREATED).body(savedVeiculo);
        } catch (Exception e) {
            log.error("Erro ao criar veículo: {}", e.getMessage(), e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Erro ao criar veículo", e);
        }
    }

    @PutMapping("/{id}")
    @CacheEvict(value = "veiculos", allEntries = true)
    @Operation(summary = "Atualizar Veículo", description = "Atualiza um veículo existente.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Veículo atualizado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Dados inválidos"),
            @ApiResponse(responseCode = "404", description = "Veículo não encontrado"),
            @ApiResponse(responseCode = "500", description = "Erro interno")
    })
    public ResponseEntity<VeiculoResponseDto> update(
            @Parameter(description = "ID do veículo") @PathVariable Long id,
            @Parameter(description = "Dados atualizados") @Valid @RequestBody VeiculoRequestDto veiculoDto) {
        log.info("Requisição para atualizar veículo ID: {}", id);
        try {
            VeiculoResponseDto updatedVeiculo = veiculoService.update(id, veiculoDto);
            return ResponseEntity.ok(updatedVeiculo);
        } catch (VeiculoNotFoundException e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, e.getMessage(), e);
        } catch (Exception e) {
            log.error("Erro ao atualizar veículo ID {}: {}", id, e.getMessage(), e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Erro ao atualizar veículo", e);
        }
    }

    @DeleteMapping("/{id}")
    @CacheEvict(value = "veiculos", allEntries = true)
    @Operation(summary = "Deletar Veículo", description = "Remove um veículo.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Veículo deletado com sucesso"),
            @ApiResponse(responseCode = "404", description = "Veículo não encontrado"),
            @ApiResponse(responseCode = "500", description = "Erro interno ou violação de integridade")
    })
    public ResponseEntity<Void> delete(
            @Parameter(description = "ID do veículo") @PathVariable Long id) {
        log.info("Requisição para deletar veículo ID: {}", id);
        try {
            veiculoService.deleteById(id);
            return ResponseEntity.noContent().build(); // 204
        } catch (VeiculoNotFoundException e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, e.getMessage(), e);
            // Capturar DataIntegrityViolationException se quiser retornar 409 Conflict
        } catch (Exception e) {
            log.error("Erro ao deletar veículo ID {}: {}", id, e.getMessage(), e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Erro ao deletar veículo", e);
        }
    }

    // --- NOVO ENDPOINT: Histórico de Serviços do Veículo ---
    @GetMapping("/{veiculoId}/servicos")
    @Operation(summary = "Listar Histórico de Serviços de um Veículo", description = "Retorna a lista de serviços/diagnósticos associados a um veículo específico.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Lista de serviços retornada"),
            @ApiResponse(responseCode = "404", description = "Veículo não encontrado com o ID fornecido"),
            @ApiResponse(responseCode = "204", description = "Nenhum serviço encontrado para este veículo"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<List<ServicoHistoricoResponseDto>> getServicosByVeiculoId(
            @Parameter(description = "ID do veículo") @PathVariable Long veiculoId
    ) {
        log.info("Requisição GET /rest/veiculo/{}/servicos", veiculoId);
        try {
            // <<< USA O oficinaService INJETADO >>>
            List<ServicoHistoricoResponseDto> historico = oficinaService.findServicosByVeiculoId(veiculoId);
            if (historico.isEmpty()) {
                return ResponseEntity.noContent().build(); // 204
            }
            return ResponseEntity.ok(historico); // 200
        } catch (VeiculoNotFoundException e) {
            log.warn("Veículo não encontrado ao buscar histórico de serviços: ID {}", veiculoId);
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, e.getMessage(), e);
        } catch (Exception e) {
            log.error("Erro inesperado ao listar histórico do veículo {}: {}", veiculoId, e.getMessage(), e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Erro ao listar histórico do veículo", e);
        }
    }
    // --- Fim do Novo Endpoint ---

} // <<< FIM DA CLASSE VeiculoController >>>

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\controller\auth\AuthController.java   |   package br.com.fiap.controller.auth   |   class AuthController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.controller.auth;

import br.com.fiap.config.security.jwt.TokenService;
import br.com.fiap.dto.security.RegistroUsuarioDto;
import br.com.fiap.dto.security.LoginRequestDto;
import br.com.fiap.dto.security.LoginResponseDto;
import br.com.fiap.model.autenticar.Autenticar;
import br.com.fiap.repository.AutenticarRepository;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.CrossOrigin; // Importe CrossOrigin
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Optional;

@RestController
@RequestMapping("/auth") // Prefixo para endpoints de autenticação
@Tag(name = "Autenticação", description = "Gerenciamento de usuários e login com JWT") // Atualize a descrição
@CrossOrigin(origins = "http://localhost:3000") // ADICIONADO: Permite requisições do seu frontend Next.js
public class AuthController {

    private static final Logger log = LoggerFactory.getLogger(AuthController.class);

    // Injete o repositório Autenticar (para registro, se mantido)
    private final AutenticarRepository autenticarRepository;
    // Injete o PasswordEncoder (para registro e verificação no login)
    private final PasswordEncoder passwordEncoder;
    // Injete o TokenService para gerar o JWT
    private final TokenService tokenService;
    // Injete o AuthenticationManager para autenticar o usuário
    private final AuthenticationManager authenticationManager;

    @Autowired
    public AuthController(AutenticarRepository autenticarRepository,
                          PasswordEncoder passwordEncoder,
                          TokenService tokenService,
                          AuthenticationManager authenticationManager) {
        this.autenticarRepository = autenticarRepository;
        this.passwordEncoder = passwordEncoder;
        this.tokenService = tokenService;
        this.authenticationManager = authenticationManager;
    }

    // --- Endpoint de Registro (Mantido se necessário) ---
    // Se você já tem um endpoint de registro em outro lugar ou não precisa mais dele aqui, pode remover.
    // Este é o mesmo endpoint que tínhamos antes, mas agora a senha será criptografada.
    @PostMapping("/register")
    @Operation(summary = "Registrar Novo Usuário", description = "Cria um novo registro na tabela AUTENTICAR.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Usuário registrado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Dados de registro inválidos"),
            @ApiResponse(responseCode = "409", description = "Nome de usuário já existente"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor")
    })
    public ResponseEntity<?> registerUser(@Valid @RequestBody RegistroUsuarioDto registroDto) {
        log.info("Tentativa de registro de novo usuário: {}", registroDto.getUsuario());
        Optional<Autenticar> existingUser = autenticarRepository.findByUsuario(registroDto.getUsuario());
        if (existingUser.isPresent()) {
            log.warn("Tentativa de registro com usuário existente: {}", registroDto.getUsuario());
            return ResponseEntity.status(HttpStatus.CONFLICT).body("Nome de usuário já existe.");
        }

        try {
            Autenticar novoUsuario = new Autenticar();
            novoUsuario.setUsuario(registroDto.getUsuario());
            // !! Criptografa a senha antes de salvar !!
            novoUsuario.setSenha(passwordEncoder.encode(registroDto.getSenha()));

            Autenticar usuarioSalvo = autenticarRepository.save(novoUsuario);
            log.info("Usuário {} registrado com sucesso com ID: {}", usuarioSalvo.getUsuario(), usuarioSalvo.getId());

            return ResponseEntity.status(HttpStatus.CREATED).body("Usuário registrado com sucesso! ID: " + usuarioSalvo.getId());
        } catch (Exception e) {
            log.error("Erro ao registrar usuário {}: {}", registroDto.getUsuario(), e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Erro interno ao registrar usuário.");
        }
    }

    // --- NOVO Endpoint de Login para JWT ---
    @PostMapping("/login")
    @Operation(summary = "Autenticar Usuário e Gerar Token JWT", description = "Recebe credenciais, autentica o usuário e retorna um token JWT em caso de sucesso.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Autenticação bem-sucedida, token JWT retornado"),
            @ApiResponse(responseCode = "401", description = "Credenciais inválidas"),
            @ApiResponse(responseCode = "500", description = "Erro interno no servidor durante a autenticação")
    })
    public ResponseEntity<LoginResponseDto> authenticateUser(@Valid @RequestBody LoginRequestDto loginRequest) {
        log.info("Tentativa de autenticação para usuário: {}", loginRequest.getUsuario());
        try {
            // Autentica o usuário usando o AuthenticationManager
            // Ele usará o AuthenticationProvider configurado (com seu UserDetailsService e PasswordEncoder)
            // para verificar as credenciais. Se inválidas, lança AuthenticationException.
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            loginRequest.getUsuario(),
                            loginRequest.getSenha()
                    )
            );

            // Se a autenticação for bem-sucedida, obtém os detalhes do usuário autenticado
            // O objeto 'principal' geralmente é o UserDetails retornado pelo UserDetailsService
            var userDetails = (org.springframework.security.core.userdetails.UserDetails) authentication.getPrincipal();

            // Gera o token JWT para o usuário autenticado
            String jwtToken = tokenService.generateToken(userDetails);
            log.info("Token JWT gerado com sucesso para usuário: {}", userDetails.getUsername());

            // Retorna o token na resposta
            return ResponseEntity.ok(new LoginResponseDto(jwtToken));

        } catch (org.springframework.security.core.AuthenticationException e) {
            // Captura exceções de autenticação (ex: BadCredentialsException)
            log.warn("Falha na autenticação para usuário {}: {}", loginRequest.getUsuario(), e.getMessage());
            // Retorna 401 com uma mensagem no corpo (o frontend espera JSON)
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(new LoginResponseDto("Credenciais inválidas"));
        } catch (Exception e) {
            // Captura outros erros inesperados durante o processo
            log.error("Erro interno durante a autenticação para usuário {}: {}", loginRequest.getUsuario(), e.getMessage(), e);
            // Retorna 500 com uma mensagem no corpo (o frontend espera JSON)
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(new LoginResponseDto("Erro interno no servidor"));
        }
    }
    // --- Fim do NOVO Endpoint de Login ---
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\agenda\AgendaRequestDto.java   |   package br.com.fiap.dto.agenda   |   class AgendaRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.agenda;

import jakarta.validation.constraints.FutureOrPresent;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class AgendaRequestDto implements Serializable {
    private static final long serialVersionUID = 1L;

    // ID Omitido para criação/atualização

    @NotNull(message = "Data do agendamento é obrigatória")
    @FutureOrPresent(message = "Data do agendamento não pode ser no passado") // Ou só @NotNull se permitir passado
    private LocalDate dataAgendamento;

    @Size(max = 400, message = "Observação pode ter no máximo 400 caracteres") // DDL: VARCHAR2(400)
    private String observacao; // Renomeado de obsAgenda
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\agenda\AgendaResponseDto.java   |   package br.com.fiap.dto.agenda   |   class AgendaResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.agenda;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class AgendaResponseDto implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long id; // ID incluído na resposta
    private LocalDate dataAgendamento;
    private String observacao;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\cliente\ClienteInfoDTO.java   |   package br.com.fiap.dto.cliente   |   class ClienteInfoDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/main/java/br/com/fiap/dto/cliente/ClienteInfoDTO.java
package br.com.fiap.dto.cliente;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
public class ClienteInfoDTO {
    private Long idCli;
    private Long idEndereco; // Essencial para identificar unicamente o cliente
    private String nome;
    private String sobrenome;
    private String numeroDocumento;

    public ClienteInfoDTO(Long idCli, Long idEndereco, String nome, String sobrenome, String numeroDocumento) {
        this.idCli = idCli;
        this.idEndereco = idEndereco;
        this.nome = nome;
        this.sobrenome = sobrenome;
        this.numeroDocumento = numeroDocumento;
    }

    public String getNomeCompleto() {
        return (nome != null ? nome : "") + " " + (sobrenome != null ? sobrenome : "");
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\cliente\ClienteRequestDto.java   |   package br.com.fiap.dto.cliente   |   class ClienteRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.cliente;

import br.com.fiap.dto.contato.ContatoRequestDto; // Usa Request DTO aninhado
import br.com.fiap.dto.endereco.EnderecoRequestDto; // Usa Request DTO aninhado
import jakarta.validation.Valid;
import jakarta.validation.constraints.*; // Importa todas as validações
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class ClienteRequestDto implements Serializable {
    private static final long serialVersionUID = 1L;

    // IDs (idCli, enderecoId) Omitidos

    @NotBlank(message = "Tipo do cliente é obrigatório")
    @Size(max = 2, message = "Tipo do cliente deve ter no máximo 2 caracteres") // DDL: VARCHAR2(2)
    private String tipoCliente;

    @NotBlank(message = "Nome é obrigatório")
    @Size(max = 50) // DDL: VARCHAR2(50)
    private String nome;

    @NotBlank(message = "Sobrenome é obrigatório")
    @Size(max = 50) // DDL: VARCHAR2(50)
    private String sobrenome;

    @NotBlank(message = "Sexo é obrigatório")
    @Size(max = 2) // DDL: VARCHAR2(2)
    private String sexo;

    @NotBlank(message = "Tipo do documento é obrigatório")
    @Size(max = 10) // DDL: VARCHAR2(10)
    private String tipoDocumento;

    @NotBlank(message = "Número do documento é obrigatório")
    @Size(max = 20) // DDL: VARCHAR2(20)
    private String numeroDocumento; // Considerar adicionar @Pattern se houver formato específico

    @NotNull(message = "Data de nascimento é obrigatória")
    @Past(message = "Data de nascimento deve ser no passado") // DDL: DATE not null
    private LocalDate dataNascimento;

    @NotBlank(message = "Atividade profissional é obrigatória")
    @Size(max = 50) // DDL: VARCHAR2(50)
    private String atividadeProfissional;

    @NotNull(message = "Endereço é obrigatório")
    @Valid // Valida o DTO aninhado
    private EnderecoRequestDto endereco; // <-- Tipo Corrigido

    @NotNull(message = "Contato é obrigatório")
    @Valid // Valida o DTO aninhado
    private ContatoRequestDto contato; // <-- Tipo Corrigido

    // === Campos para Autenticação (Opcional) ===
    private String usuarioAutenticacao; // Nome de usuário para login
    private String senhaAutenticacao;   // Senha para login
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\cliente\ClienteResponseDto.java   |   package br.com.fiap.dto.cliente   |   class ClienteResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.cliente;

import br.com.fiap.dto.contato.ContatoResponseDto; // Usa Response DTO aninhado
import br.com.fiap.dto.endereco.EnderecoResponseDto; // Usa Response DTO aninhado
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class ClienteResponseDto implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long idCli; // Parte principal da chave composta
    // O ID do endereço está dentro do EnderecoResponseDto

    private String tipoCliente;
    private String nome;
    private String sobrenome;
    private String sexo;
    private String tipoDocumento;
    private String numeroDocumento;
    private LocalDate dataNascimento;
    private String atividadeProfissional;

    private EnderecoResponseDto endereco; // <-- Tipo Corrigido
    private ContatoResponseDto contato;   // <-- Tipo Corrigido

    // Poderia ter um DTO resumido de Autenticar se necessário
    // private AutenticarResumoDto autenticar;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\contato\ContatoRequestDto.java   |   package br.com.fiap.dto.contato   |   class ContatoRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.contato;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;

@Getter @Setter @NoArgsConstructor
public class ContatoRequestDto implements Serializable {
    private static final long serialVersionUID = 1L;

    // ID (codigo) Omitido

    @NotBlank(message = "Celular é obrigatório")
    @Size(max = 20) // DDL: VARCHAR2(20)
    private String celular;

    @NotBlank(message = "Email é obrigatório")
    @Email(message = "Formato de email inválido")
    @Size(max = 50) // DDL: VARCHAR2(50)
    private String email;

    @NotBlank(message = "Nome do contato é obrigatório")
    @Size(max = 100) // DDL: VARCHAR2(100)
    private String contato; // Nome do campo no DTO
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\contato\ContatoResponseDto.java   |   package br.com.fiap.dto.contato   |   class ContatoResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.contato;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;

@Getter @Setter @NoArgsConstructor
public class ContatoResponseDto implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long codigo; // ID incluído na resposta
    private String celular;
    private String email;
    private String contato;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\endereco\EnderecoRequestDto.java   |   package br.com.fiap.dto.endereco   |   class EnderecoRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.endereco;

import com.fasterxml.jackson.annotation.JsonProperty; // Para mapear JSON ViaCEP se necessário
import jakarta.validation.constraints.*; // Importa todas as validações
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;

@Getter @Setter @NoArgsConstructor
public class EnderecoRequestDto implements Serializable {
    private static final long serialVersionUID = 1L;

    // ID (codigo) Omitido

    @NotNull(message = "Número do endereço é obrigatório")
    @Positive(message = "Número deve ser positivo")
    private Integer numero; // DDL: NUMBER not null

    @NotBlank(message = "CEP é obrigatório")
    @Pattern(regexp = "\\d{5}-?\\d{3}", message = "CEP inválido. Formato: 00000-000 ou 00000000")
    @Size(max = 10) // DDL: VARCHAR2(10) not null
    private String cep;

    @NotBlank(message = "Logradouro é obrigatório")
    @Size(max = 100) // DDL: VARCHAR2(100) not null
    private String logradouro;

    @NotBlank(message = "Cidade é obrigatória")
    @Size(max = 100) // DDL: VARCHAR2(100) not null
    @JsonProperty("localidade") // Mantém compatibilidade com ViaCEP se usar Jackson
    private String cidade;

    @NotBlank(message = "Bairro é obrigatório")
    @Size(max = 100) // DDL: VARCHAR2(100) not null
    private String bairro;

    @NotBlank(message = "Estado é obrigatório")
    @Size(max = 50) // DDL: VARCHAR2(50) not null
    @JsonProperty("uf") // Mantém compatibilidade com ViaCEP se usar Jackson
    private String estado;

    @Size(max = 100) // DDL: VARCHAR2(100) nullable
    private String complemento;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\endereco\EnderecoResponseDto.java   |   package br.com.fiap.dto.endereco   |   class EnderecoResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.endereco;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;

@Getter @Setter @NoArgsConstructor
public class EnderecoResponseDto implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long codigo; // ID incluído na resposta
    private Integer numero; // Usar Integer para consistência, ou int se preferir
    private String cep;
    private String logradouro;
    @JsonProperty("localidade")
    private String cidade;
    private String bairro;
    @JsonProperty("uf")
    private String estado;
    private String complemento;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\oficina\ItemPecaServicoDto.java   |   package br.com.fiap.dto.oficina   |   class ItemPecaServicoDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.dto.oficina
package br.com.fiap.dto.oficina;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor // Lombok gera o construtor com todos os argumentos
public class ItemPecaServicoDto {

    @NotNull(message = "ID da peça é obrigatório")
    private Long pecaId;

    // Estes campos são opcionais no DTO de *request* para orçamento,
    // mas podem ser preenchidos na *resposta* do histórico
    private String descricaoPeca;
    private String fabricantePeca;

    @NotNull(message = "Quantidade da peça é obrigatória")
    @Min(value = 1, message = "Quantidade deve ser pelo menos 1")
    private Integer quantidade;

    // NENHUM CONSTRUTOR MANUAL AQUI, deixe o Lombok cuidar disso com @AllArgsConstructor
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\oficina\OficinaRequestDto.java   |   package br.com.fiap.dto.oficina   |   class OficinaRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.oficina;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
// Poderia adicionar @Pattern para horasTrabalhadas se souber o formato exato
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class OficinaRequestDto implements Serializable {
    private static final long serialVersionUID = 1L;

    // ID Omitido

    @NotNull(message = "Data da oficina é obrigatória")
    @PastOrPresent(message = "Data da oficina não pode ser no futuro") // DDL: DATE not null
    private LocalDate dataOficina;

    @NotBlank(message = "Descrição do problema é obrigatória")
    @Size(max = 500) // DDL: VARCHAR2(500) not null
    private String descricaoProblema;

    @NotBlank(message = "Diagnóstico é obrigatório")
    @Size(max = 4000) // DDL: VARCHAR2(4000 char) not null
    private String diagnostico;

    @NotBlank(message = "Partes afetadas são obrigatórias")
    @Size(max = 500) // DDL: VARCHAR2(500) not null
    private String partesAfetadas;

    @NotBlank(message = "Horas trabalhadas são obrigatórias")
    @Size(max = 5, message = "Horas trabalhadas devem ter no máximo 5 caracteres") // DDL: VARCHAR2(5) not null
    // @Pattern(regexp = "\\d+", message = "Horas trabalhadas devem conter apenas números") // Exemplo, ajustar regex se necessário
    private String horasTrabalhadas; // Mapeado como String devido ao DDL
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\oficina\OficinaResponseDto.java   |   package br.com.fiap.dto.oficina   |   class OficinaResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.oficina;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class OficinaResponseDto implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long id; // ID incluído
    private LocalDate dataOficina;
    private String descricaoProblema;
    private String diagnostico;
    private String partesAfetadas;
    private String horasTrabalhadas; // Mantido como String
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\oficina\ServicoHistoricoResponseDto.java   |   package br.com.fiap.dto.oficina   |   class ServicoHistoricoResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.dto.oficina (ou br.com.fiap.dto.relatorio)

package br.com.fiap.dto.oficina; // Ou br.com.fiap.dto.relatorio

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.LocalDate;
import java.util.List;

@Getter
@Setter
@NoArgsConstructor
public class ServicoHistoricoResponseDto {
    private Long idOficina; // ID da Oficina (serviço)
    private LocalDate dataOficina;
    private String descricaoProblema;
    private String diagnostico;
    private String partesAfetadas;
    private String horasTrabalhadas;
    private List<ItemPecaServicoDto> pecasUtilizadas; // Reutiliza o DTO existente

    // Construtor pode ser útil
    public ServicoHistoricoResponseDto(Long idOficina, LocalDate dataOficina, String descricaoProblema, String diagnostico, String partesAfetadas, String horasTrabalhadas, List<ItemPecaServicoDto> pecasUtilizadas) {
        this.idOficina = idOficina;
        this.dataOficina = dataOficina;
        this.descricaoProblema = descricaoProblema;
        this.diagnostico = diagnostico;
        this.partesAfetadas = partesAfetadas;
        this.horasTrabalhadas = horasTrabalhadas;
        this.pecasUtilizadas = pecasUtilizadas;
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\orcamento\OrcamentoComServicoRequestDto.java   |   package br.com.fiap.dto.orcamento   |   class OrcamentoComServicoRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Em br.com.fiap.dto.orcamento
package br.com.fiap.dto.orcamento;

import br.com.fiap.dto.oficina.ItemPecaServicoDto; // Import do DTO acima
import jakarta.validation.Valid;
import jakarta.validation.constraints.FutureOrPresent;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import jakarta.validation.constraints.PositiveOrZero;
import jakarta.validation.constraints.Positive;

import lombok.Getter;
import lombok.Setter;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;

@Getter
@Setter
public class OrcamentoComServicoRequestDto {

    // --- Detalhes do Serviço da Oficina ---
    @NotNull(message = "Data do serviço da oficina é obrigatória")
    private LocalDate dataOficina; // Pode ser a mesma da dataOrcamento

    @NotBlank(message = "Descrição do problema é obrigatória")
    @Size(max = 500, message = "Descrição do problema pode ter no máximo 500 caracteres")
    private String descricaoProblema;

    @Size(max = 4000, message = "Diagnóstico pode ter no máximo 4000 caracteres")
    private String diagnostico; // Pode ser preenchido pela IA ou manualmente

    @NotBlank(message = "Partes afetadas são obrigatórias")
    @Size(max = 500, message = "Partes afetadas podem ter no máximo 500 caracteres")
    private String partesAfetadas;

    @NotBlank(message = "Horas trabalhadas na oficina são obrigatórias")
    @Size(max = 5, message = "Horas trabalhadas na oficina devem ter no máximo 5 caracteres")
    private String horasTrabalhadasOficina; // Ex: "2.5" ou "2:30" - backend precisará parsear

    @Valid // Valida a lista de itens
    private List<ItemPecaServicoDto> pecasUtilizadas;

    // --- Detalhes do Orçamento ---
    @NotNull(message = "Data do orçamento é obrigatória")
    @FutureOrPresent(message = "Data do orçamento não pode ser no passado, apenas presente ou futuro.")
    private LocalDate dataOrcamento;

    @NotNull(message = "Valor da mão de obra (taxa fixa/adicional) é obrigatório")
    @PositiveOrZero(message = "Valor da mão de obra não pode ser negativo")
    private BigDecimal valorMaoDeObraAdicional; // Uma taxa fixa, se houver

    @NotNull(message = "Valor da hora para orçamento é obrigatório")
    @Positive(message = "Valor da hora deve ser positivo")
    private BigDecimal valorHoraOrcamento;

    @NotNull(message = "Quantidade de horas para orçamento é obrigatória")
    @Positive(message = "Quantidade de horas deve ser positiva")
    private Integer quantidadeHorasOrcamento;

    // --- IDs para Associações (Opcional, mas útil para o frontend) ---
    private Long clienteId;
    private Long clienteEnderecoId; // Necessário devido à chave composta de Clientes
    private Long veiculoId;

    // ID da Oficina, caso o orçamento seja para um serviço já existente e queira apenas adicionar o orçamento
    private Long oficinaExistenteId;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\orcamento\OrcamentoRequestDto.java   |   package br.com.fiap.dto.orcamento   |   class OrcamentoRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.orcamento;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Positive;
import jakarta.validation.constraints.PositiveOrZero; // Para valores que podem ser zero
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class OrcamentoRequestDto implements Serializable {
    private static final long serialVersionUID = 1L;

    // ID Omitido

    @NotNull(message = "Data do orçamento é obrigatória")
    @PastOrPresent(message = "Data do orçamento não pode ser futura") // DDL: DATE not null
    private LocalDate dataOrcamento;

    @NotNull(message = "Valor da mão de obra é obrigatório")
    @PositiveOrZero(message = "Valor da mão de obra não pode ser negativo") // DDL: NUMBER not null
    private BigDecimal maoDeObra;

    @NotNull(message = "Valor por hora é obrigatório")
    @Positive(message = "Valor por hora deve ser positivo") // DDL: NUMBER not null
    private BigDecimal valorHora;

    @NotNull(message = "Quantidade de horas é obrigatória")
    @Positive(message = "Quantidade de horas deve ser positiva") // DDL: NUMBER not null
    private Integer quantidadeHoras;

    @NotNull(message = "Valor total é obrigatório")
    @PositiveOrZero(message = "Valor total não pode ser negativo") // DDL: NUMBER not null
    private BigDecimal valorTotal; // Este valor pode ser calculado no backend também
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\orcamento\OrcamentoResponseDto.java   |   package br.com.fiap.dto.orcamento   |   class OrcamentoResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.orcamento;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class OrcamentoResponseDto implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long id; // ID incluído
    private LocalDate dataOrcamento;
    private BigDecimal maoDeObra;
    private BigDecimal valorHora;
    private Integer quantidadeHoras;
    private BigDecimal valorTotal;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\pagamento\PagamentoRequestDto.java   |   package br.com.fiap.dto.pagamento   |   class PagamentoRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.pagamento; // Pacote correto

import jakarta.validation.constraints.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class PagamentoRequestDto {

    @NotNull(message = "Data do pagamento é obrigatória")
    private LocalDate dataPagamento;

    @NotBlank(message = "Tipo de pagamento é obrigatório")
    @Size(max = 20, message = "Tipo de pagamento não pode exceder 20 caracteres")
    private String tipoPagamento;

    @NotNull(message = "Percentual de desconto é obrigatório")
    @DecimalMin(value = "0.0", message = "Desconto não pode ser negativo")
    @DecimalMax(value = "100.0", message = "Desconto não pode ser maior que 100")
    private BigDecimal descontoPercentual; // Recebe o %

    @NotNull(message = "Total de parcelas é obrigatório")
    @Min(value = 1, message = "Deve haver pelo menos 1 parcela")
    private Integer totalParcelas; // Recebe como número

    @NotNull(message = "Valor do serviço é obrigatório")
    @DecimalMin(value = "0.01", message = "Valor do serviço deve ser positivo")
    private BigDecimal valorServico; // Necessário para cálculo

    // IDs opcionais para relacionamentos (ajuste se necessário)
    private Long clienteId;
    private Long orcamentoId;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\pagamento\PagamentoResponseDto.java   |   package br.com.fiap.dto.pagamento   |   class PagamentoResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.pagamento; // Pacote correto

import java.math.BigDecimal;
import java.time.LocalDate;
import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class PagamentoResponseDto {

    private Long id;
    private LocalDate dataPagamento;
    private String tipoPagamento;
    private BigDecimal desconto;       // O percentual armazenado na entidade
    private String totalParcelas;    // Como String (igual entidade)
    private BigDecimal valorParcelas;   // Valor calculado
    private BigDecimal totalComDesconto; // Valor calculado
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\pecas\PecasRequestDto.java   |   package br.com.fiap.dto.pecas   |   class PecasRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.pecas;

import jakarta.validation.constraints.*; // Importa todas as validações
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class PecasRequestDto implements Serializable {
    private static final long serialVersionUID = 1L;

    // ID Omitido

    @NotBlank(message = "Tipo do veículo é obrigatório")
    @Size(max = 10) // DDL: VARCHAR2(10) not null
    private String tipoVeiculo;

    @NotBlank(message = "Fabricante é obrigatório")
    @Size(max = 50) // DDL: VARCHAR2(50) not null
    private String fabricante;

    @NotBlank(message = "Descrição da peça é obrigatória")
    @Size(max = 50) // DDL: DESCRICA_PECA VARCHAR2(50) not null
    private String descricao;

    @NotNull(message = "Data da compra é obrigatória")
    @PastOrPresent(message = "Data da compra não pode ser futura") // DDL: DATE not null
    private LocalDate dataCompra;

    @NotNull(message = "Preço é obrigatório")
    @Positive(message = "Preço deve ser positivo") // DDL: NUMBER not null
    private BigDecimal preco;

    @NotNull(message = "Desconto é obrigatório")
    @PositiveOrZero(message = "Desconto não pode ser negativo") // DDL: NUMBER not null
    private BigDecimal desconto;

    @NotNull(message = "Total com desconto é obrigatório")
    @PositiveOrZero(message = "Total com desconto não pode ser negativo") // DDL: NUMBER not null
    private BigDecimal totalDesconto;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\pecas\PecasResponseDto.java   |   package br.com.fiap.dto.pecas   |   class PecasResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.pecas;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class PecasResponseDto implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long id; // ID incluído
    private String tipoVeiculo;
    private String fabricante;
    private String descricao;
    private LocalDate dataCompra;
    private BigDecimal preco;
    private BigDecimal desconto;
    private BigDecimal totalDesconto;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\relatorio\ClienteRelatorioCompletoDTO.java   |   package br.com.fiap.dto.relatorio   |   class ClienteRelatorioCompletoDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// --- Arquivo: src/main/java/br/com/fiap/dto/relatorio/ClienteRelatorioCompletoDTO.java ---
package br.com.fiap.dto.relatorio;

import br.com.fiap.dto.agenda.AgendaResponseDto; // Ou um DTO mais simples
import br.com.fiap.dto.cliente.ClienteResponseDto;
import br.com.fiap.dto.orcamento.OrcamentoResponseDto;
import br.com.fiap.dto.pagamento.PagamentoResponseDto;
import br.com.fiap.dto.veiculo.VeiculoResponseDto;
// Importe DTOs específicos para Oficina e Peças se criá-los, ou use os existentes
import br.com.fiap.dto.oficina.OficinaResponseDto; // Exemplo
import br.com.fiap.dto.pecas.PecasResponseDto;     // Exemplo

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.io.Serializable;
import java.util.List;

@Getter
@Setter
@NoArgsConstructor
public class ClienteRelatorioCompletoDTO implements Serializable {
    private static final long serialVersionUID = 1L;

    private ClienteResponseDto cliente; // Dados básicos do cliente
    private List<VeiculoResponseDto> veiculos; // Lista de veículos do cliente
    private List<AgendaSimplificadoDTO> agendamentos; // Histórico de agendamentos (DTO simplificado)
    private List<OficinaServicoDTO> servicosOficina; // Serviços realizados (DTO com peças talvez?)
    private List<OrcamentoResponseDto> orcamentos; // Orçamentos associados ao cliente
    private List<PagamentoResponseDto> pagamentos; // Pagamentos associados ao cliente
    private long totalAgendamentos; // Contagem para o gráfico

    // --- Sub-DTOs Simplificados (Exemplos) ---
    // Você pode criar esses DTOs em seus respectivos pacotes ou aqui mesmo

    @Getter @Setter @NoArgsConstructor
    public static class AgendaSimplificadoDTO implements Serializable {
        private Long id;
        private String dataAgendamento; // Formatada
        private String observacao;
        private String veiculoPlaca; // Adicionar a placa para contexto
    }

    @Getter @Setter @NoArgsConstructor
    public static class OficinaServicoDTO implements Serializable {
        private Long idOficina;
        private String dataOficina; // Formatada
        private String descricaoProblema;
        private String diagnostico;
        private String partesAfetadas;
        private String horasTrabalhadas;
        private String veiculoPlaca; // Adicionar a placa
        private List<PecaUtilizadaDTO> pecasUtilizadas; // Lista de peças
    }

    @Getter @Setter @NoArgsConstructor
    public static class PecaUtilizadaDTO implements Serializable {
        private Long idPeca;
        private String descricaoPeca;
        private String fabricante;
        // Adicionar quantidade se a tabela de junção tiver
    }

}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\relatorio\ContagemMensalDTO.java   |   package br.com.fiap.dto.relatorio   |   class ContagemMensalDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/main/java/br/com/fiap/dto/relatorio/ContagemMensalDTO.java
package br.com.fiap.dto.relatorio;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor // Necessário para a query JPQL construir o objeto
public class ContagemMensalDTO {
    private String mesAno; // Formato "YYYY-MM"
    private Long quantidade; // Contagem de agendamentos no mês/ano
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\relatorio\ContagemMensalResultadoNativo.java   |   package br.com.fiap.dto.relatorio   |   class ContagemMensalResultadoNativo
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/main/java/br/com/fiap/dto/relatorio/ContagemMensalResultadoNativo.java
package br.com.fiap.dto.relatorio;

// Interface para mapear o resultado da query nativa
public interface ContagemMensalResultadoNativo {
    String getMesAno();      // Nome do método DEVE corresponder ao alias da coluna na query nativa (case-insensitive)
    Long getQuantidade(); // Nome do método DEVE corresponder ao alias da coluna na query nativa (case-insensitive)
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\relatorio\EstatisticasPagamentosDto.java   |   package br.com.fiap.dto.relatorio   |   class EstatisticasPagamentosDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.relatorio;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.math.BigDecimal;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class EstatisticasPagamentosDto {
    private Long totalOperacoes;
    private BigDecimal valorTotalArrecadado;
    private BigDecimal ticketMedio;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\relatorio\EvolucaoMensalPagamentoNativo.java   |   package br.com.fiap.dto.relatorio   |   class EvolucaoMensalPagamentoNativo
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.relatorio;

import java.math.BigDecimal;

public interface EvolucaoMensalPagamentoNativo {
    String getMesAno();
    BigDecimal getValorTotal();
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\relatorio\EvolucaoMensalValorDto.java   |   package br.com.fiap.dto.relatorio   |   class EvolucaoMensalValorDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.relatorio;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.math.BigDecimal;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class EvolucaoMensalValorDto {
    private String mesAno; // Formato "YYYY-MM"
    private BigDecimal valorTotal;
    // private Long quantidade; // Opcional, se quiser mostrar contagem também
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\relatorio\HistoricoAgendamentoClienteDTO.java   |   package br.com.fiap.dto.relatorio   |   class HistoricoAgendamentoClienteDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/main/java/br/com/fiap/dto/relatorio/HistoricoAgendamentoClienteDTO.java
package br.com.fiap.dto.relatorio;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.LocalDate;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor // Necessário para a query JPQL
public class HistoricoAgendamentoClienteDTO {
    private LocalDate dataAgendamento;
    private String observacao;
    private String veiculoPlaca; // Placa do veículo associado ao agendamento
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\relatorio\PagamentoPorTipoDto.java   |   package br.com.fiap.dto.relatorio   |   class PagamentoPorTipoDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.relatorio;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.math.BigDecimal;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class PagamentoPorTipoDto {
    private String tipoPagamento;
    private Long quantidade;
    private BigDecimal valorTotal;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\relatorio\ServicoAgendadoDTO.java   |   package br.com.fiap.dto.relatorio   |   class ServicoAgendadoDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/main/java/br/com/fiap/dto/relatorio/ServicoAgendadoDTO.java
package br.com.fiap.dto.relatorio;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.LocalDate;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor // Necessário para a query JPQL com 'new'
public class ServicoAgendadoDTO {
    private Long agendaId;                    // ID do agendamento
    private LocalDate dataAgendamento;        // Data do agendamento
    private String agendaObservacao;          // Observação vinda da Agenda
    private String veiculoPlaca;              // Placa do Veiculo (pode ser null)
    private String oficinaDescricaoProblema;  // Descrição vinda da Oficina (pode ser null)
    private String oficinaDiagnostico;        // Diagnóstico vindo da Oficina (pode ser null)
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\security\LoginRequestDto.java   |   package br.com.fiap.dto.security   |   class LoginRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.security;

import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class LoginRequestDto {

    @NotBlank(message = "Nome de usuário é obrigatório")
    private String usuario;

    @NotBlank(message = "Senha é obrigatória")
    private String senha;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\security\LoginResponseDto.java   |   package br.com.fiap.dto.security   |   class LoginResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.security;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class LoginResponseDto {
    private String token; // O token JWT retornado
    // Você pode adicionar outras informações aqui se necessário, como nome do usuário, papéis, etc.
    // private String username;
    // private List<String> roles;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\security\RegistroUsuarioDto.java   |   package br.com.fiap.dto.security   |   class RegistroUsuarioDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.security;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class RegistroUsuarioDto {

    @NotBlank(message = "Nome de usuário é obrigatório")
    @Size(max = 100, message = "Nome de usuário deve ter no máximo 100 caracteres")
    private String usuario;

    @NotBlank(message = "Senha é obrigatória")
    @Size(max = 100, message = "Senha deve ter no máximo 100 caracteres") // Note: this is max for the *input* password. BCrypt hash will be longer.
    private String senha;

    // Opcional: Adicionar campos para ID do Cliente se o registro de usuário for acoplado à criação do cliente.
    // private Long clienteId;
    // private Long clienteEnderecoId;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\veiculo\VeiculoRequestDto.java   |   package br.com.fiap.dto.veiculo   |   class VeiculoRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.veiculo;

import jakarta.validation.constraints.*; // Importa todas as validações
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class VeiculoRequestDto implements Serializable {
    private static final long serialVersionUID = 1L;

    // ID Omitido

    @NotBlank(message = "Tipo do veículo é obrigatório")
    @Size(max = 15) // DDL: VARCHAR2(15) not null
    private String tipoVeiculo;

    @NotBlank(message = "Renavam é obrigatório")
    @Size(max = 13) // DDL: VARCHAR2(13) not null
    // Adicionar @Pattern se houver formato específico para Renavam
    private String renavam;

    @NotBlank(message = "Placa é obrigatória")
    @Size(max = 7) // DDL: VARCHAR2(7) not null
    // Adicionar @Pattern para formato de placa (ex: Mercosul ou antiga)
    private String placa;

    @NotBlank(message = "Modelo é obrigatório")
    @Size(max = 100) // DDL: VARCHAR2(100) not null
    private String modelo;

    @NotBlank(message = "Proprietário é obrigatório")
    @Size(max = 50) // DDL: VARCHAR2(50) not null
    private String proprietario;

    @NotBlank(message = "Montadora é obrigatória")
    @Size(max = 100) // DDL: VARCHAR2(100) not null
    private String montadora;

    @NotBlank(message = "Cor é obrigatória")
    @Size(max = 50) // DDL: VARCHAR2(50) not null
    private String cor;

    @NotBlank(message = "Motor é obrigatório")
    @Size(max = 50) // DDL: VARCHAR2(50) not null
    private String motor;

    @NotNull(message = "Ano de fabricação é obrigatório")
    @PastOrPresent(message = "Ano de fabricação não pode ser futuro") // DDL: DATE not null
    private LocalDate anoFabricacao; // Mapeado como LocalDate
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\dto\veiculo\VeiculoResponseDto.java   |   package br.com.fiap.dto.veiculo   |   class VeiculoResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.dto.veiculo;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import java.io.Serializable;
import java.time.LocalDate;

@Getter @Setter @NoArgsConstructor
public class VeiculoResponseDto implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long id; // ID incluído
    private String tipoVeiculo;
    private String renavam;
    private String placa;
    private String modelo;
    private String proprietario;
    private String montadora;
    private String cor;
    private String motor;
    private LocalDate anoFabricacao; // Mantido como LocalDate
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\exception\AgendaNotFoundException.java   |   package br.com.fiap.exception   |   class AgendaNotFoundException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;


@ResponseStatus(HttpStatus.NOT_FOUND)
public class AgendaNotFoundException extends RuntimeException{

    public AgendaNotFoundException(String message) {
        super(message);
    }


    public AgendaNotFoundException(String message, Throwable cause) {
        super(message, cause); // Chama o construtor de RuntimeException que aceita mensagem e causa
    }


}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\exception\AssociacaoNotFoundException.java   |   package br.com.fiap.exception   |   class AssociacaoNotFoundException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// --- src/main/java/br/com/fiap/exception/AssociacaoNotFoundException.java ---
package br.com.fiap.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND) // Retorna 404 Not Found
public class AssociacaoNotFoundException extends RuntimeException {
    public AssociacaoNotFoundException(String message) {
        super(message);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\exception\AutenticarNotFoundException.java   |   package br.com.fiap.exception   |   class AutenticarNotFoundException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.exception;

public class AutenticarNotFoundException extends RuntimeException{

    public AutenticarNotFoundException(String message) {
        super(message);
    }

    public AutenticarNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\exception\ClientesNotFoundException.java   |   package br.com.fiap.exception   |   class ClientesNotFoundException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.exception;

public class ClientesNotFoundException extends RuntimeException{

    public ClientesNotFoundException(String message){
        super(message);
    }

    public ClientesNotFoundException(String message, Throwable cause){
        super(message, cause);
    }

}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\exception\ContatoNotFoundException.java   |   package br.com.fiap.exception   |   class ContatoNotFoundException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class ContatoNotFoundException extends RuntimeException {

    public ContatoNotFoundException(String message) {
        super(message);
    }

    public ContatoNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\exception\EnderecoNotFoundException.java   |   package br.com.fiap.exception   |   class EnderecoNotFoundException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class EnderecoNotFoundException extends RuntimeException{

    public EnderecoNotFoundException(String message) {
        super(message);
    }

    public EnderecoNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\exception\OficinaNotFoundException.java   |   package br.com.fiap.exception   |   class OficinaNotFoundException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class OficinaNotFoundException extends RuntimeException{

    public OficinaNotFoundException(String message) {
        super(message);
    }

    public OficinaNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\exception\OrcamentoNotFoundException.java   |   package br.com.fiap.exception   |   class OrcamentoNotFoundException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class OrcamentoNotFoundException extends RuntimeException {

    public OrcamentoNotFoundException(String message) {
        super(message);
    }

    public OrcamentoNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\exception\PagamentoNotFoundException.java   |   package br.com.fiap.exception   |   class PagamentoNotFoundException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND) // Faz o Spring retornar HTTP 404 automaticamente quando essa exceção é lançada do controller
public class PagamentoNotFoundException extends RuntimeException {

    public PagamentoNotFoundException(String message) {
        super(message);
    }

    public PagamentoNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\exception\PecasNotFoundException.java   |   package br.com.fiap.exception   |   class PecasNotFoundException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class PecasNotFoundException extends RuntimeException{

    public PecasNotFoundException(String message) {
        super(message);
    }

    public PecasNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\exception\VeiculoNotFoundException.java   |   package br.com.fiap.exception   |   class VeiculoNotFoundException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class VeiculoNotFoundException extends RuntimeException {

    public VeiculoNotFoundException(String message) {
        super(message);
    }

    public VeiculoNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\mapper\AgendaMapper.java   |   package br.com.fiap.mapper   |   class AgendaMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mapper;

import br.com.fiap.dto.agenda.AgendaRequestDto;
import br.com.fiap.dto.agenda.AgendaResponseDto;
import br.com.fiap.model.Agenda;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
// import org.mapstruct.factory.Mappers; // Remova se usar componentModel="spring"

@Mapper(componentModel = "spring") // Usa injeção do Spring
public interface AgendaMapper {

    // AgendaMapper INSTANCE = Mappers.getMapper(AgendaMapper.class); // Remova se usar componentModel="spring"

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "agendaOficinas", ignore = true) // <<< ADICIONADO PARA IGNORAR
    @Mapping(target = "agendaVeiculos", ignore = true) // <<< ADICIONADO PARA IGNORAR
    Agenda toEntity(AgendaRequestDto dto);

    AgendaResponseDto toResponseDto(Agenda entity);
    // Se AgendaResponseDto também não tiver agendaOficinas/agendaVeiculos,
    // o MapStruct não reclamará aqui. Se tivesse, precisaríamos ignorar também ou mapear.

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "agendaOficinas", ignore = true) // <<< ADICIONADO PARA IGNORAR
    @Mapping(target = "agendaVeiculos", ignore = true) // <<< ADICIONADO PARA IGNORAR
    void updateEntityFromDto(AgendaRequestDto dto, @MappingTarget Agenda entity);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\mapper\ClienteMapper.java   |   package br.com.fiap.mapper   |   class ClienteMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// --- src/main/java/br/com/fiap/mapper/ClienteMapper.java ---
package br.com.fiap.mapper;

import br.com.fiap.dto.cliente.ClienteRequestDto;
import br.com.fiap.dto.cliente.ClienteResponseDto;
import br.com.fiap.model.Clientes;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Mappings;

// Declara que este mapper usa outros mappers (para Endereco e Contato)
@Mapper(componentModel = "spring", uses = {EnderecoMapper.class, ContatoMapper.class})
public interface ClienteMapper {

    // Mapeamento DTO -> Entidade (Criação)
    // Ignora o ID composto ('id') pois será gerenciado pelo JPA/@MapsId e Sequence
    // Mapeia os DTOs aninhados de endereco e contato usando os mappers injetados
    @Mappings({
            @Mapping(target = "id", ignore = true), // Ignora o @EmbeddedId
            @Mapping(target = "endereco", source = "endereco"), // Usa EnderecoMapper
            @Mapping(target = "contato", source = "contato"),   // Usa ContatoMapper
            @Mapping(target = "autenticar", ignore = true) // Ignora autenticar por enquanto
    })
    Clientes toEntity(ClienteRequestDto dto);

    // Mapeamento Entidade -> DTO (Resposta)
    // Mapeia a parte idCli da chave composta para o campo idCli do DTO
    // Mapeia as entidades aninhadas Endereco e Contato para seus DTOs de resposta
    @Mappings({
            @Mapping(target = "idCli", source = "id.idCli"), // Pega o idCli de dentro do ClienteId
            @Mapping(target = "endereco", source = "endereco"), // Usa EnderecoMapper
            @Mapping(target = "contato", source = "contato")    // Usa ContatoMapper
            // Mapear autenticar se houver um DTO para ele
    })
    ClienteResponseDto toResponseDto(Clientes entity);

    // Mapeamento DTO -> Entidade (Atualização)
    // Ignora o ID composto ('id') pois não deve ser alterado
    // Mapeia os DTOs aninhados (a lógica de salvar/atualizar Endereco/Contato fica no Service)
    // Atualiza os campos simples do cliente
    @Mappings({
            @Mapping(target = "id", ignore = true),
            @Mapping(target = "endereco", ignore = true), // Endereço é atualizado separadamente no Service
            @Mapping(target = "contato", ignore = true),  // Contato é atualizado separadamente no Service
            @Mapping(target = "autenticar", ignore = true) // Ignora autenticar
    })
    void updateEntityFromDto(ClienteRequestDto dto, @MappingTarget Clientes entity);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\mapper\ContatoMapper.java   |   package br.com.fiap.mapper   |   class ContatoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// --- src/main/java/br/com/fiap/mapper/ContatoMapper.java ---
package br.com.fiap.mapper;

import br.com.fiap.dto.contato.ContatoRequestDto;
import br.com.fiap.dto.contato.ContatoResponseDto;
import br.com.fiap.model.Contato;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

@Mapper(componentModel = "spring")
public interface ContatoMapper {

    @Mapping(target = "codigo", ignore = true) // Ignora ID na criação
    Contato toEntity(ContatoRequestDto dto);

    ContatoResponseDto toResponseDto(Contato entity);

    @Mapping(target = "codigo", ignore = true) // Ignora ID na atualização
    void updateEntityFromDto(ContatoRequestDto dto, @MappingTarget Contato entity);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\mapper\EnderecoMapper.java   |   package br.com.fiap.mapper   |   class EnderecoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// --- src/main/java/br/com/fiap/mapper/EnderecoMapper.java ---
package br.com.fiap.mapper;

import br.com.fiap.dto.endereco.EnderecoRequestDto;
import br.com.fiap.dto.endereco.EnderecoResponseDto;
import br.com.fiap.model.Endereco;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

@Mapper(componentModel = "spring")
public interface EnderecoMapper {

    @Mapping(target = "codigo", ignore = true) // Ignora ID na criação
    Endereco toEntity(EnderecoRequestDto dto);

    EnderecoResponseDto toResponseDto(Endereco entity);

    @Mapping(target = "codigo", ignore = true) // Ignora ID na atualização
    void updateEntityFromDto(EnderecoRequestDto dto, @MappingTarget Endereco entity);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\mapper\OficinaMapper.java   |   package br.com.fiap.mapper   |   class OficinaMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// br/com/fiap/mapper/OficinaMapper.java
package br.com.fiap.mapper;

import br.com.fiap.dto.oficina.OficinaRequestDto; // Usado para CRUD simples de Oficina
import br.com.fiap.dto.oficina.OficinaResponseDto;
import br.com.fiap.dto.orcamento.OrcamentoComServicoRequestDto; // Novo DTO
import br.com.fiap.model.Oficina;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Mappings;

@Mapper(componentModel = "spring")
public interface OficinaMapper {

    @Mappings({
            @Mapping(target = "id", ignore = true),
            // Mapeia os campos correspondentes do DTO complexo para a entidade Oficina
            @Mapping(source = "dataOficina", target = "dataOficina"),
            @Mapping(source = "descricaoProblema", target = "descricaoProblema"),
            @Mapping(source = "diagnostico", target = "diagnostico"),
            @Mapping(source = "partesAfetadas", target = "partesAfetadas"),
            @Mapping(source = "horasTrabalhadasOficina", target = "horasTrabalhadas"),
            // Ignora coleções de relacionamento e campos não presentes no DTO parcial
            @Mapping(target = "agendaOficinas", ignore = true),
            @Mapping(target = "oficinaVeiculos", ignore = true),
            @Mapping(target = "oficinaPecas", ignore = true), // Será preenchido no serviço
            @Mapping(target = "oficinaOrcamentos", ignore = true)
    })
    Oficina fromOrcamentoComServicoDto(OrcamentoComServicoRequestDto dto);

    // Métodos existentes para CRUD simples de Oficina (se houver)
    @Mappings({
            @Mapping(target = "id", ignore = true),
            @Mapping(target = "agendaOficinas", ignore = true),
            @Mapping(target = "oficinaVeiculos", ignore = true),
            @Mapping(target = "oficinaPecas", ignore = true),
            @Mapping(target = "oficinaOrcamentos", ignore = true)
    })
    Oficina toEntity(OficinaRequestDto dto);

    OficinaResponseDto toResponseDto(Oficina entity);

    @Mappings({
            @Mapping(target = "id", ignore = true),
            @Mapping(target = "agendaOficinas", ignore = true),
            @Mapping(target = "oficinaVeiculos", ignore = true),
            @Mapping(target = "oficinaPecas", ignore = true),
            @Mapping(target = "oficinaOrcamentos", ignore = true)
    })
    void updateEntityFromDto(OficinaRequestDto dto, @MappingTarget Oficina entity);

    // Novo método para atualizar a partir do DTO complexo
    @Mappings({
            @Mapping(target = "id", ignore = true),
            @Mapping(source = "dataOficina", target = "dataOficina"),
            @Mapping(source = "descricaoProblema", target = "descricaoProblema"),
            @Mapping(source = "diagnostico", target = "diagnostico"),
            @Mapping(source = "partesAfetadas", target = "partesAfetadas"),
            @Mapping(source = "horasTrabalhadasOficina", target = "horasTrabalhadas"),
            @Mapping(target = "agendaOficinas", ignore = true),
            @Mapping(target = "oficinaVeiculos", ignore = true),
            @Mapping(target = "oficinaPecas", ignore = true),
            @Mapping(target = "oficinaOrcamentos", ignore = true)
    })
    void updateOficinaFromOrcamentoComServicoDto(OrcamentoComServicoRequestDto dto, @MappingTarget Oficina entity);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\mapper\OrcamentoMapper.java   |   package br.com.fiap.mapper   |   class OrcamentoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// br/com/fiap/mapper/OrcamentoMapper.java
package br.com.fiap.mapper;

import br.com.fiap.dto.orcamento.OrcamentoRequestDto; // Usado para CRUD simples de Orcamento
import br.com.fiap.dto.orcamento.OrcamentoResponseDto;
import br.com.fiap.dto.orcamento.OrcamentoComServicoRequestDto; // Novo DTO
import br.com.fiap.model.Orcamento;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Mappings;

@Mapper(componentModel = "spring")
public interface OrcamentoMapper {

    @Mappings({
            @Mapping(target = "id", ignore = true),
            // Mapeia os campos correspondentes do DTO complexo para a entidade Orcamento
            @Mapping(source = "dataOrcamento", target = "dataOrcamento"),
            @Mapping(source = "valorMaoDeObraAdicional", target = "maoDeObra"),
            @Mapping(source = "valorHoraOrcamento", target = "valorHora"),
            @Mapping(source = "quantidadeHorasOrcamento", target = "quantidadeHoras"),
            @Mapping(target = "valorTotal", ignore = true), // Calculado no serviço
            @Mapping(target = "clienteOrcamentos", ignore = true),
            @Mapping(target = "oficinaOrcamentos", ignore = true), // Será preenchido no serviço
            @Mapping(target = "pagamentoOrcamentos", ignore = true)
    })
    Orcamento fromOrcamentoComServicoDto(OrcamentoComServicoRequestDto dto);

    // Métodos existentes para CRUD simples de Orcamento (se houver)
    @Mappings({
            @Mapping(target = "id", ignore = true),
            @Mapping(target = "clienteOrcamentos", ignore = true),
            @Mapping(target = "oficinaOrcamentos", ignore = true),
            @Mapping(target = "pagamentoOrcamentos", ignore = true)
    })
    Orcamento toEntity(OrcamentoRequestDto dto); // Para CRUD simples de orçamento

    OrcamentoResponseDto toResponseDto(Orcamento entity);

    @Mappings({
            @Mapping(target = "id", ignore = true),
            @Mapping(target = "clienteOrcamentos", ignore = true),
            @Mapping(target = "oficinaOrcamentos", ignore = true),
            @Mapping(target = "pagamentoOrcamentos", ignore = true)
    })
    void updateEntityFromDto(OrcamentoRequestDto dto, @MappingTarget Orcamento entity); // Para CRUD simples

    // Novo método para atualizar a partir do DTO complexo
    @Mappings({
            @Mapping(target = "id", ignore = true),
            @Mapping(source = "dataOrcamento", target = "dataOrcamento"),
            @Mapping(source = "valorMaoDeObraAdicional", target = "maoDeObra"),
            @Mapping(source = "valorHoraOrcamento", target = "valorHora"),
            @Mapping(source = "quantidadeHorasOrcamento", target = "quantidadeHoras"),
            @Mapping(target = "valorTotal", ignore = true),
            @Mapping(target = "clienteOrcamentos", ignore = true),
            @Mapping(target = "oficinaOrcamentos", ignore = true),
            @Mapping(target = "pagamentoOrcamentos", ignore = true)
    })
    void updateOrcamentoFromOrcamentoComServicoDto(OrcamentoComServicoRequestDto dto, @MappingTarget Orcamento entity);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\mapper\PagamentoMapper.java   |   package br.com.fiap.mapper   |   class PagamentoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mapper;

import br.com.fiap.dto.pagamento.PagamentoRequestDto;
import br.com.fiap.dto.pagamento.PagamentoResponseDto;
import br.com.fiap.model.Pagamento;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Mappings;

@Mapper(componentModel = "spring")
public interface PagamentoMapper {

    @Mappings({
            @Mapping(target = "id", ignore = true),
            @Mapping(source = "descontoPercentual", target = "desconto"), // Mapeia % do DTO para 'desconto' na entidade
            @Mapping(source = "totalParcelas", target = "totalParcelas"),   // MapStruct converte Integer (DTO) para String (Entidade)
            @Mapping(target = "valorParcelas", ignore = true),          // Calculado no Service
            @Mapping(target = "totalComDesconto", ignore = true),       // Calculado no Service
            @Mapping(target = "clientePagamentos", ignore = true),
            @Mapping(target = "pagamentoOrcamentos", ignore = true)
    })
    Pagamento toEntity(PagamentoRequestDto dto);

    // O toResponseDto geralmente não precisa de mappings explícitos se os nomes dos campos
    // na entidade (após os cálculos no service) e no DTO de resposta forem iguais.
    PagamentoResponseDto toResponseDto(Pagamento entity);

    @Mappings({
            @Mapping(target = "id", ignore = true),
            @Mapping(source = "descontoPercentual", target = "desconto"),
            @Mapping(source = "totalParcelas", target = "totalParcelas"),
            @Mapping(target = "valorParcelas", ignore = true),
            @Mapping(target = "totalComDesconto", ignore = true),
            @Mapping(target = "clientePagamentos", ignore = true),
            @Mapping(target = "pagamentoOrcamentos", ignore = true)
    })
    void updateEntityFromDto(PagamentoRequestDto dto, @MappingTarget Pagamento entity);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\mapper\PecasMapper.java   |   package br.com.fiap.mapper   |   class PecasMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// --- src/main/java/br/com/fiap/mapper/PecasMapper.java ---
package br.com.fiap.mapper;

import br.com.fiap.dto.pecas.PecasRequestDto;
import br.com.fiap.dto.pecas.PecasResponseDto;
import br.com.fiap.model.Pecas;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Mappings;

@Mapper(componentModel = "spring")
public interface PecasMapper {

    @Mappings({
            @Mapping(target = "id", ignore = true),
            @Mapping(target = "oficinaPecas", ignore = true), // Ignora relacionamentos
            @Mapping(target = "pecaVeiculos", ignore = true)
    })
    Pecas toEntity(PecasRequestDto dto);

    PecasResponseDto toResponseDto(Pecas entity);

    @Mappings({
            @Mapping(target = "id", ignore = true),
            @Mapping(target = "oficinaPecas", ignore = true),
            @Mapping(target = "pecaVeiculos", ignore = true)
    })
    void updateEntityFromDto(PecasRequestDto dto, @MappingTarget Pecas entity);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\mapper\VeiculoMapper.java   |   package br.com.fiap.mapper   |   class VeiculoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// --- src/main/java/br/com/fiap/mapper/VeiculoMapper.java ---
package br.com.fiap.mapper;

import br.com.fiap.dto.veiculo.VeiculoRequestDto;
import br.com.fiap.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.model.Veiculo;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Mappings;

@Mapper(componentModel = "spring")
public interface VeiculoMapper {

    @Mappings({
            @Mapping(target = "id", ignore = true),
            @Mapping(target = "agendaVeiculos", ignore = true), // Ignora relacionamentos
            @Mapping(target = "clienteVeiculos", ignore = true),
            @Mapping(target = "oficinaVeiculos", ignore = true),
            @Mapping(target = "pecaVeiculos", ignore = true)
    })
    Veiculo toEntity(VeiculoRequestDto dto);

    VeiculoResponseDto toResponseDto(Veiculo entity);

    @Mappings({
            @Mapping(target = "id", ignore = true),
            @Mapping(target = "agendaVeiculos", ignore = true),
            @Mapping(target = "clienteVeiculos", ignore = true),
            @Mapping(target = "oficinaVeiculos", ignore = true),
            @Mapping(target = "pecaVeiculos", ignore = true)
    })
    void updateEntityFromDto(VeiculoRequestDto dto, @MappingTarget Veiculo entity);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\model\Agenda.java   |   package br.com.fiap.model   |   class Agenda
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/main/java/br/com/fiap/model/Agenda.java
package br.com.fiap.model;

import br.com.fiap.model.relacionamentos.AgendaOficina; // Importar se usar
import br.com.fiap.model.relacionamentos.AgendaVeiculo; // <<< Importar AgendaVeiculo
import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDate;
import java.io.Serializable;
import java.util.ArrayList; // <<< Importar ArrayList
import java.util.List;      // <<< Importar List

@Entity
@Table(name = "AGENDAR")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "id")
@ToString(exclude = {"agendaOficinas", "agendaVeiculos"}) // Excluir coleções do toString
public class Agenda implements Serializable {

	private static final long serialVersionUID = 1L;

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "agenda_seq_gen")
	@SequenceGenerator(name = "agenda_seq_gen", sequenceName = "AGENDAR_ID_AGE_SEQ", allocationSize = 1)
	@Column(name = "ID_AGE")
	private Long id;

	@Column(name = "DATA_AGENDAMENTO", nullable = false)
	private LocalDate dataAgendamento;

	@Column(name = "OBS_AGENDAMENTO", length = 400, nullable = true)
	private String observacao;

	// === RELACIONAMENTOS DESCOMENTADOS ===
	// Relacionamento com Oficina (via tabela AO)
	@OneToMany(mappedBy = "agenda", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY) // <<< DESCOMENTAR ANOTAÇÃO
	private List<AgendaOficina> agendaOficinas = new ArrayList<>(); // <<< DESCOMENTAR ATRIBUTO

	// Relacionamento com Veiculo (via tabela AV) - PRECISA ESTAR DESCOMENTADO
	@OneToMany(mappedBy = "agenda", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<AgendaVeiculo> agendaVeiculos = new ArrayList<>();
	// ====================================
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\model\Clientes.java   |   package br.com.fiap.model   |   class Clientes
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.model;
import br.com.fiap.model.autenticar.Autenticar;
import br.com.fiap.model.relacionamentos.ClienteId;
import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDate; // Importa LocalDate para datas

@Entity
@Table(name = "CLIENTES") // Nome exato da tabela no DDL

// --- Lombok ---
@Getter
@Setter
@NoArgsConstructor // Construtor padrão obrigatório para JPA
@AllArgsConstructor // Construtor com todos os campos (opcional, mas útil)
@ToString(exclude = {"endereco", "contato", "autenticar"}) // Excluir relacionamentos LAZY
// --------------
public class Clientes {

	@EmbeddedId
	private ClienteId id = new ClienteId(); // <<< ADICIONE = new ClienteId(); AQUI

	// --- Relacionamento com Endereco (Obrigatório e parte da PK) ---
	@ManyToOne(fetch = FetchType.LAZY, optional = false) // Relacionamento com Endereco. optional=false porque a FK não pode ser nula
	@MapsId("enderecoId") // Diz que o atributo 'enderecoId' DENTRO do 'id' (@EmbeddedId) deve usar o ID desta entidade Endereco
	@JoinColumn(name = "ENDERECOS_ID_END", nullable = false) // Nome exato da coluna FK no DDL. Não pode ser nulo.
	private Endereco endereco;
	// -----------------------------------------------------------

	// --- Demais Colunas Mapeadas Exatamente como no DDL ---
	@Column(name = "TIPO_CLIENTE", length = 2, nullable = false)
	private String tipoCliente;

	@Column(name = "NOME", length = 50, nullable = false)
	private String nome;

	@Column(name = "SOBRENOME", length = 50, nullable = false)
	private String sobrenome;

	@Column(name = "SEXO", length = 2, nullable = false)
	private String sexo;

	@Column(name = "TIPO_DOCUMENTO", length = 10, nullable = false)
	private String tipoDocumento;

	@Column(name = "NUMERO_DOCUMENTO", length = 20, nullable = false, unique = true) // Ajustado unique=true pois geralmente documentos são únicos
	private String numeroDocumento;

	@Column(name = "DATA_NASCIMENTO", nullable = false) // Nome exato da coluna no DDL
	private LocalDate dataNascimento; // Tipo LocalDate para coluna DATE

	@Column(name = "ATIVIDADE_PROFISSIONAL", length = 50, nullable = false)
	private String atividadeProfissional;

	// --- Relacionamentos Opcionais (FKs permitem NULO no DDL) ---
	@ManyToOne(fetch = FetchType.LAZY) // Pode ser ManyToOne ou OneToOne dependendo da regra de negócio
	@JoinColumn(name = "CONTATOS_ID_CONT", nullable = true) // Nome exato da FK, permite nulo
	private Contato contato;

	@OneToOne(fetch = FetchType.LAZY) // Geralmente autenticação é 1-para-1
	@JoinColumn(name = "AUTENTICAR_ID_AUT", nullable = true) // Nome exato da FK, permite nulo
	private Autenticar autenticar; // Assume que existe uma entidade Autenticar mapeada para TB_AUTENTICAR
	// ---------------------------------------------------------

	// --- equals() e hashCode() baseados no ID composto ---
	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		Clientes clientes = (Clientes) o;
		// Só são iguais se o ID composto não for nulo e for igual ao do outro objeto.
		return id != null && id.equals(clientes.id);
	}

	@Override
	public int hashCode() {
		// Se o ID não for nulo, usa o hashCode dele, senão usa um valor baseado na classe.
		return id != null ? id.hashCode() : getClass().hashCode();
	}
	// ------------------------------------------------------

	// NOTA: Não usamos @GeneratedValue aqui porque a trigger CLIENTES_ID_CLI_TRG
	// no banco de dados já cuida de gerar o ID_CLI usando a sequence CLIENTES_ID_CLI_SEQ.
	// O JPA pegará o valor gerado pelo banco após a inserção.
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\model\Contato.java   |   package br.com.fiap.model   |   class Contato
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.model;

import jakarta.persistence.*;   // Importações JPA
import lombok.*;                // Lombok
import java.io.Serializable;

@Entity // Marca como Entidade JPA
@Table(name = "CONTATOS") // Mapeia para a tabela TB_CONTATOS

// --- Lombok ---
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "codigo")
@ToString
//---------------
public class Contato implements Serializable {

	private static final long serialVersionUID = 1L;

	@Id // Chave Primária
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "contato_seq_gen")
	@SequenceGenerator(name = "contato_seq_gen", sequenceName = "CONTATOS_ID_CONT_SEQ", allocationSize = 1) // Usa a sequence do DDL
	@Column(name = "ID_CONT") // Mapeia para a coluna ID_CONT
	private Long codigo;

	@Column(name = "CELULAR", length = 20, nullable = false) // Mapeia para CELULAR
	private String celular;

	@Column(name = "EMAIL", length = 50, nullable = false) // Mapeia para EMAIL
	private String email;

	@Column(name = "CONTATO", length = 100, nullable = false) // Mapeia para CONTATO (Nome do campo Java e da coluna são diferentes aqui, mas ok)
	private String contato; // O nome do campo Java é 'contato', a coluna é 'CONTATO'

	// Getters, Setters, Construtores, equals, hashCode, toString gerados pelo Lombok
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\model\Endereco.java   |   package br.com.fiap.model   |   class Endereco
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.model;

import com.google.gson.annotations.SerializedName; // Mantida para ViaCEP/Gson
import jakarta.persistence.*;                      // Importações JPA
import lombok.*;                                   // Lombok

import java.io.Serializable; // Necessário se for parte de chave composta ou relacionamento complexo

@Entity // Marca como Entidade JPA
@Table(name = "ENDERECOS") // Mapeia para a tabela TB_ENDERECOS

// --- Lombok ---
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "codigo") // Baseia equals/hashCode no ID
@ToString
//---------------
public class Endereco implements Serializable { // Implementar Serializable é uma boa prática para entidades

	private static final long serialVersionUID = 1L;

	@Id // Chave Primária
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "endereco_seq_gen")
	@SequenceGenerator(name = "endereco_seq_gen", sequenceName = "ENDERECOS_ID_END_SEQ", allocationSize = 1) // Usa a sequence do DDL
	@Column(name = "ID_END") // Mapeia para a coluna ID_END
	private Long codigo; // Seu campo 'codigo' mapeia para ID_END

	@Column(name = "NUMERO", nullable = false) // Mapeia para a coluna NUMERO
	private int numero; // Mantido como int, pois no DDL é NUMBER not null

	@Column(name = "CEP", length = 10, nullable = false) // Mapeia para CEP
	private String cep;

	@Column(name = "LOGRADOURO", length = 100, nullable = false) // Mapeia para LOGRADOURO
	private String logradouro;

	@Column(name = "CIDADE", length = 100, nullable = false) // Mapeia para CIDADE
	@SerializedName("localidade") // <-- ANOTAÇÃO GSON MANTIDA!
	private String cidade;

	@Column(name = "BAIRRO", length = 100, nullable = false) // Mapeia para BAIRRO
	private String bairro;

	@Column(name = "ESTADO", length = 50, nullable = false) // Mapeia para ESTADO
	@SerializedName("uf") // <-- ANOTAÇÃO GSON MANTIDA!
	private String estado;

	@Column(name = "COMPLEMENTO", length = 100, nullable = true) // Mapeia para COMPLEMENTO (permite nulo)
	private String complemento;

	// Getters, Setters, Construtores, equals, hashCode, toString gerados pelo Lombok
	// Comentário original removido pois o ID agora é gerenciado pelo JPA/Banco
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\model\Oficina.java   |   package br.com.fiap.model   |   class Oficina
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.model;

import br.com.fiap.model.relacionamentos.AgendaOficina;
import br.com.fiap.model.relacionamentos.OficinaOrcamento;
import br.com.fiap.model.relacionamentos.OficinaPeca;
import br.com.fiap.model.relacionamentos.OficinaVeiculo;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;
import java.time.LocalDate;
import java.util.ArrayList; // Para inicializar listas
import java.util.List;       // Para coleções de relacionamentos

@Entity
@Table(name = "OFICINAS") // Nome exato da tabela no DDL

// --- Lombok ---
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "id")
// Excluir coleções LAZY do toString para evitar erros
@ToString(exclude = {"agendaOficinas", "oficinaVeiculos", "oficinaPecas", "oficinaOrcamentos"})
// --------------
public class Oficina implements Serializable {

	private static final long serialVersionUID = 1L;

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "oficina_seq_gen")
	@SequenceGenerator(name = "oficina_seq_gen", sequenceName = "OFICINAS_ID_OFIC_SEQ", allocationSize = 1)
	@Column(name = "ID_OFIC")
	private Long id; // Renomeado de 'codigo'

	@Column(name = "DATA_OFICINA", nullable = false)
	private LocalDate dataOficina; // Alterado para LocalDate, nome para camelCase

	@Column(name = "DESCRICAO_PROBLEMA", length = 500, nullable = false)
	private String descricaoProblema;

	@Column(name = "DIAGNOSTICO", length = 4000, nullable = false)
	private String diagnostico;

	@Column(name = "PARTES_AFETADAS", length = 500, nullable = false)
	private String partesAfetadas;

	// --- ATENÇÃO: HORAS_TRABALHADAS é VARCHAR2 no DDL ---
	@Column(name = "HORAS_TRABALHADAS", length = 5, nullable = false)
	private String horasTrabalhadas; // Mapeado como String para corresponder ao DDL.
	// Idealmente, esta coluna deveria ser NUMBER no banco.
	// Você precisará converter para número na sua lógica de negócio.
	// ----------------------------------------------------

	// === RELACIONAMENTOS INDIRETOS (Via Tabelas de Junção) ===
	// Removidos os campos diretos: private Agenda agenda; private Veiculo veiculo; private Pecas peca;
	// Adicionados relacionamentos @OneToMany para as ENTIDADES DE JUNÇÃO (que precisam ser criadas)

	// Relacionamento com Agendamentos (via Tabela AO -> Entidade AgendaOficina)
	@OneToMany(mappedBy = "oficina", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<AgendaOficina> agendaOficinas = new ArrayList<>(); // Assume entidade AgendaOficina

	// Relacionamento com Veículos (via Tabela OV -> Entidade OficinaVeiculo)
	@OneToMany(mappedBy = "oficina", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<OficinaVeiculo> oficinaVeiculos = new ArrayList<>(); // Assume entidade OficinaVeiculo

	// Relacionamento com Peças (via Tabela OFP -> Entidade OficinaPeca)
	@OneToMany(mappedBy = "oficina", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<OficinaPeca> oficinaPecas = new ArrayList<>(); // Assume entidade OficinaPeca

	// Relacionamento com Orçamentos (via Tabela OFO -> Entidade OficinaOrcamento)
	@OneToMany(mappedBy = "oficina", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<OficinaOrcamento> oficinaOrcamentos = new ArrayList<>(); // Assume entidade OficinaOrcamento

	// ===========================================================

	// Getters, Setters, Construtores, equals, hashCode, toString gerados pelo Lombok
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\model\Orcamento.java   |   package br.com.fiap.model   |   class Orcamento
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.model;

import br.com.fiap.model.relacionamentos.ClienteOrcamento;
import br.com.fiap.model.relacionamentos.OficinaOrcamento;
import br.com.fiap.model.relacionamentos.PagamentoOrcamento;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;
import java.math.BigDecimal; // Usar BigDecimal para valores monetários/precisos
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "ORCAMENTOS") // Nome exato da tabela no DDL

// --- Lombok ---
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "id")
// Excluir coleções LAZY do toString
@ToString(exclude = {"clienteOrcamentos", "oficinaOrcamentos", "pagamentoOrcamentos"})
// --------------
public class Orcamento implements Serializable {

	private static final long serialVersionUID = 1L;

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "orcamento_seq_gen")
	@SequenceGenerator(name = "orcamento_seq_gen", sequenceName = "ORCAMENTOS_ID_ORC_SEQ", allocationSize = 1)
	@Column(name = "ID_ORC")
	private Long id; // Renomeado de 'codigo'

	@Column(name = "DATA_ORCAMENTO", nullable = false)
	private LocalDate dataOrcamento; // Alterado para LocalDate

	// Usando BigDecimal para precisão monetária/decimal
	@Column(name = "VALOR_MAODEOBRA", nullable = false, precision = 10, scale = 2) // Definir precisão e escala conforme necessário
	private BigDecimal maoDeObra; // Alterado para BigDecimal

	@Column(name = "VALOR_HORA", nullable = false, precision = 10, scale = 2)
	private BigDecimal valorHora; // Alterado para BigDecimal

	@Column(name = "QUANTIDADE_HORAS", nullable = false)
	private Integer quantidadeHoras; // Alterado para Integer (compatível com NUMBER)

	@Column(name = "VALOR_TOTAL", nullable = false, precision = 10, scale = 2)
	private BigDecimal valorTotal; // Alterado para BigDecimal

	// === RELACIONAMENTOS INDIRETOS (Via Tabelas de Junção) ===
	// Removidos os campos diretos: private Oficina oficina; private Pecas pecas;
	// O campo 'pecas' foi removido pois não há FK ou tabela de junção direta Orcamento<->Pecas no DDL.
	// Adicionados relacionamentos @OneToMany para as ENTIDADES DE JUNÇÃO (que precisam ser criadas)

	// Relacionamento com Clientes (via Tabela CO -> Entidade ClienteOrcamento)
	@OneToMany(mappedBy = "orcamento", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<ClienteOrcamento> clienteOrcamentos = new ArrayList<>(); // Assume entidade ClienteOrcamento

	// Relacionamento com Oficinas (via Tabela OFO -> Entidade OficinaOrcamento)
	@OneToMany(mappedBy = "orcamento", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<OficinaOrcamento> oficinaOrcamentos = new ArrayList<>(); // Assume entidade OficinaOrcamento

	// Relacionamento com Pagamentos (via Tabela PAO -> Entidade PagamentoOrcamento)
	@OneToMany(mappedBy = "orcamento", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<PagamentoOrcamento> pagamentoOrcamentos = new ArrayList<>(); // Assume entidade PagamentoOrcamento

	// ===========================================================

	// Getters, Setters, Construtores, equals, hashCode, toString gerados pelo Lombok
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\model\Pagamento.java   |   package br.com.fiap.model   |   class Pagamento
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.model;

import br.com.fiap.model.relacionamentos.ClientePagamento;
import br.com.fiap.model.relacionamentos.PagamentoOrcamento;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;
import java.math.BigDecimal; // Usar BigDecimal para valores monetários/precisos
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "PAGAMENTOS") // Nome exato da tabela no DDL

// --- Lombok ---
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "id")
// Excluir coleções LAZY do toString
@ToString(exclude = {"clientePagamentos", "pagamentoOrcamentos"})
// --------------
public class Pagamento implements Serializable {

	private static final long serialVersionUID = 1L;

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "pagamento_seq_gen")
	@SequenceGenerator(name = "pagamento_seq_gen", sequenceName = "PAGAMENTOS_ID_PAG_SEQ", allocationSize = 1)
	@Column(name = "ID_PAG")
	private Long id; // Renomeado de 'codigo'

	@Column(name = "DATA_PAGAMENTO", nullable = false)
	private LocalDate dataPagamento; // Alterado para LocalDate

	@Column(name = "TIPO_PAGAMENTO", length = 20, nullable = false)
	private String tipoPagamento;

	// Usando BigDecimal para precisão monetária/decimal
	@Column(name = "DESCONTO", nullable = false, precision = 10, scale = 2) // Definir precisão/escala
	private BigDecimal desconto; // Alterado para BigDecimal

	// --- ATENÇÃO: TOTAL_PARCELAS é VARCHAR2 no DDL ---
	@Column(name = "TOTAL_PARCELAS", length = 5, nullable = false)
	private String totalParcelas; // Mapeado como String para corresponder ao DDL.
	// O campo original era 'parcelamento' (int). Renomeado e tipo alterado.
	// Idealmente, esta coluna deveria ser NUMBER no banco.
	// Você precisará converter para número na sua lógica de negócio.
	// ----------------------------------------------------

	@Column(name = "VALOR_PARCELAS", nullable = false, precision = 10, scale = 2)
	private BigDecimal valorParcelas; // Alterado para BigDecimal

	@Column(name = "TOTAL_PAGAMENTO_DESCONTO", nullable = false, precision = 10, scale = 2)
	private BigDecimal totalComDesconto; // Alterado para BigDecimal e nome do campo ajustado

	// === RELACIONAMENTOS INDIRETOS (Via Tabelas de Junção) ===
	// Removidos os campos diretos: private Orcamento orcamento; private Pecas pecas;
	// O campo 'pecas' foi removido pois não há FK ou tabela de junção Pagamento<->Pecas no DDL.
	// Adicionados relacionamentos @OneToMany para as ENTIDADES DE JUNÇÃO (que precisam ser criadas)

	// Relacionamento com Clientes (via Tabela CP -> Entidade ClientePagamento)
	@OneToMany(mappedBy = "pagamento", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<ClientePagamento> clientePagamentos = new ArrayList<>(); // Assume entidade ClientePagamento

	// Relacionamento com Orcamentos (via Tabela PAO -> Entidade PagamentoOrcamento)
	@OneToMany(mappedBy = "pagamento", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<PagamentoOrcamento> pagamentoOrcamentos = new ArrayList<>(); // Assume entidade PagamentoOrcamento

	// ===========================================================

	// Getters, Setters, Construtores, equals, hashCode, toString gerados pelo Lombok
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\model\Pecas.java   |   package br.com.fiap.model   |   class Pecas
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.model;

import br.com.fiap.model.relacionamentos.OficinaPeca;
import br.com.fiap.model.relacionamentos.PecaVeiculo;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;
import java.math.BigDecimal; // Para valores monetários/precisos
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "PECAS") // Nome exato da tabela no DDL

// --- Lombok ---
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "id")
// Excluir coleções LAZY do toString
@ToString(exclude = {"oficinaPecas", "pecaVeiculos"})
// --------------
public class Pecas implements Serializable {

	private static final long serialVersionUID = 1L;

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "pecas_seq_gen")
	@SequenceGenerator(name = "pecas_seq_gen", sequenceName = "PECAS_ID_PEC_SEQ", allocationSize = 1)
	@Column(name = "ID_PEC")
	private Long id; // Renomeado de 'codigo'

	@Column(name = "TIPO_VEICULO", length = 10, nullable = false)
	private String tipoVeiculo;

	@Column(name = "FABRICANTE", length = 50, nullable = false)
	private String fabricante;

	// Atenção: Nome da coluna no DDL parece ser "DESCRICA_PECA"
	@Column(name = "DESCRICA_PECA", length = 50, nullable = false)
	private String descricao; // Campo Java 'descricao' mapeado para 'DESCRICA_PECA'

	@Column(name = "DATA_COMPRA", nullable = false)
	private LocalDate dataCompra; // Alterado para LocalDate

	// Usando BigDecimal para precisão
	@Column(name = "PRECO", nullable = false, precision = 10, scale = 2)
	private BigDecimal preco; // Alterado para BigDecimal

	@Column(name = "DESCONTO", nullable = false, precision = 10, scale = 2)
	private BigDecimal desconto; // Alterado para BigDecimal

	@Column(name = "TOTAL_DESCONTO", nullable = false, precision = 10, scale = 2)
	private BigDecimal totalDesconto; // Alterado para BigDecimal

	// === RELACIONAMENTOS INDIRETOS (Via Tabelas de Junção) ===
	// Adicionados relacionamentos @OneToMany para as ENTIDADES DE JUNÇÃO (que precisam ser criadas)

	// Relacionamento com Oficinas (via Tabela OFP -> Entidade OficinaPeca)
	@OneToMany(mappedBy = "peca", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<OficinaPeca> oficinaPecas = new ArrayList<>(); // Assume entidade OficinaPeca com campo 'peca'

	// Relacionamento com Veículos (via Tabela PV -> Entidade PecaVeiculo)
	@OneToMany(mappedBy = "peca", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<PecaVeiculo> pecaVeiculos = new ArrayList<>(); // Assume entidade PecaVeiculo com campo 'peca'

	// ===========================================================

	// Getters, Setters, Construtores, equals, hashCode, toString gerados pelo Lombok
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\model\Veiculo.java   |   package br.com.fiap.model   |   class Veiculo
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.model;

import br.com.fiap.model.relacionamentos.AgendaVeiculo;
import br.com.fiap.model.relacionamentos.ClienteVeiculo;
import br.com.fiap.model.relacionamentos.OficinaVeiculo;
import br.com.fiap.model.relacionamentos.PecaVeiculo;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;
import java.time.LocalDate; // Usar LocalDate para mapear DATE
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "VEICULOS") // Nome exato da tabela no DDL

// --- Lombok ---
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "id")
// Excluir coleções LAZY do toString
@ToString(exclude = {"agendaVeiculos", "clienteVeiculos", "oficinaVeiculos", "pecaVeiculos"})
// --------------
public class Veiculo implements Serializable {

	private static final long serialVersionUID = 1L;

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "veiculo_seq_gen")
	@SequenceGenerator(name = "veiculo_seq_gen", sequenceName = "VEICULOS_ID_VEI_SEQ", allocationSize = 1)
	@Column(name = "ID_VEI") // Mapeia para ID_VEI (conforme DDL)
	private Long id; // Renomeado de 'codigo'

	@Column(name = "TIPO_VEICULO", length = 15, nullable = false)
	private String tipoVeiculo;

	@Column(name = "RENAVAM", length = 13, nullable = false, unique = true) // Renavam geralmente é único
	private String renavam;

	@Column(name = "PLACA", length = 7, nullable = false, unique = true) // Placa geralmente é única
	private String placa;

	@Column(name = "MODELO", length = 100, nullable = false)
	private String modelo;

	@Column(name = "PROPRIETARIO", length = 50, nullable = false) // Mapeado conforme DDL
	private String proprietario;

	@Column(name = "MONTADORA", length = 100, nullable = false)
	private String montadora;

	@Column(name = "COR", length = 50, nullable = false)
	private String cor;

	@Column(name = "MOTOR", length = 50, nullable = false)
	private String motor;

	// --- ATENÇÃO: ANO_FABRICACAO é DATE no DDL ---
	@Column(name = "ANO_FABRICACAO", nullable = false)
	private LocalDate anoFabricacao; // Mapeado como LocalDate para corresponder ao tipo DATE do DDL.
	// Se você realmente só precisa do ano, talvez fosse melhor a coluna ser NUMBER no banco
	// e o tipo aqui ser Integer. Usar DATE para armazenar só o ano é incomum.
	// -------------------------------------------

	// === RELACIONAMENTOS INDIRETOS (Via Tabelas de Junção) ===
	// Adicionados relacionamentos @OneToMany para as ENTIDADES DE JUNÇÃO (que precisam ser criadas)

	// Relacionamento com Agendamentos (via Tabela AV -> Entidade AgendaVeiculo)
	@OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<AgendaVeiculo> agendaVeiculos = new ArrayList<>(); // Assume entidade AgendaVeiculo

	// Relacionamento com Clientes (via Tabela CV -> Entidade ClienteVeiculo)
	@OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<ClienteVeiculo> clienteVeiculos = new ArrayList<>(); // Assume entidade ClienteVeiculo

	// Relacionamento com Oficinas (via Tabela OV -> Entidade OficinaVeiculo)
	@OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<OficinaVeiculo> oficinaVeiculos = new ArrayList<>(); // Assume entidade OficinaVeiculo

	// Relacionamento com Peças (via Tabela PV -> Entidade PecaVeiculo)
	@OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
	private List<PecaVeiculo> pecaVeiculos = new ArrayList<>(); // Assume entidade PecaVeiculo

	// ===========================================================

	// Getters, Setters, Construtores, equals, hashCode, toString gerados pelo Lombok
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\model\autenticar\Autenticar.java   |   package br.com.fiap.model.autenticar   |   class Autenticar
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.model.autenticar;

import jakarta.persistence.*;   // Importações JPA
import lombok.*;                // Importações Lombok
import java.io.Serializable;    // Para implementar Serializable

@Entity // Marca como Entidade JPA
@Table(name = "AUTENTICAR") // Nome exato da tabela no DDL

// --- Lombok ---
@Getter
@Setter
@NoArgsConstructor // Construtor padrão (obrigatório para JPA)
@AllArgsConstructor // Construtor com todos os campos (útil)
@EqualsAndHashCode(of = "id") // equals e hashCode baseados apenas no campo 'id'
@ToString(exclude = "senha") // Exclui o campo senha do toString padrão por segurança
// --------------
public class Autenticar implements Serializable { // Boa prática implementar Serializable

    private static final long serialVersionUID = 1L; // Boa prática para Serializable

    @Id // Marca como chave primária
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "autenticar_seq_gen") // Geração via Sequence
    @SequenceGenerator(name = "autenticar_seq_gen", sequenceName = "AUTENTICAR_ID_AUT_SEQ", allocationSize = 1) // Configura a sequence do DDL
    @Column(name = "ID_AUT") // Mapeia para a coluna ID_AUT do banco
    private Long id; // Renomeado de 'codigoAutenticacao' para 'id' para simplicidade (ou poderia ser 'idAut')

    @Column(name = "USUARIO", length = 100, nullable = false, unique = true) // Mapeia para USUARIO, com constraints do DDL
    private String usuario;

    @Column(name = "SENHA", length = 100, nullable = false) // Mapeia para SENHA
    private String senha; // <-- Novamente, ATENÇÃO À SEGURANÇA!

    // === MÉTODOS MANUAIS REMOVIDOS ===
    // Os métodos getCodigoAutenticacao(), setCodigoAutenticacao(), getUsuario(), setUsuario(),
    // getSenha(), setSenha(), construtores padrão e completo, equals(), hashCode() e toString()
    // foram removidos pois agora são gerados automaticamente pelas anotações do Lombok
    // (@Getter, @Setter, @NoArgsConstructor, @AllArgsConstructor, @EqualsAndHashCode, @ToString).

    // ==================================
    // !!! ALERTA DE SEGURANÇA !!!
    // ==================================
    // Reitero: Armazenar senhas diretamente como texto no banco é INSEGURO.
    // Em aplicações reais, use Spring Security (ou similar) para aplicar HASHING (ex: BCrypt)
    // na senha ANTES de salvá-la. O campo 'senha' armazenaria o HASH.
    // ==================================
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\model\relacionamentos\AgendaOficina.java   |   package br.com.fiap.model.relacionamentos   |   class AgendaOficina
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.model.relacionamentos; // Ou subpacote

import br.com.fiap.model.Agenda;
import br.com.fiap.model.Oficina;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;

@Entity
@Table(name = "AO")
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @EqualsAndHashCode(of = "id") @ToString
public class AgendaOficina implements Serializable {
    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "ao_seq_gen")
    @SequenceGenerator(name = "ao_seq_gen", sequenceName = "AO_ID_AO_SEQ", allocationSize = 1)
    @Column(name = "ID_AO")
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "AGENDAR_ID_AGE", nullable = false)
    private Agenda agenda;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "OFICINAS_ID_OFIC", nullable = false)
    private Oficina oficina;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\model\relacionamentos\AgendaVeiculo.java   |   package br.com.fiap.model.relacionamentos   |   class AgendaVeiculo
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.model.relacionamentos; // Ou um subpacote como br.com.fiap.model.join

import br.com.fiap.model.Agenda;
import br.com.fiap.model.Veiculo;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;

@Entity
@Table(name = "AV") // Nome exato da tabela de junção no DDL

// --- Lombok ---
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "id")
@ToString
//---------------
public class AgendaVeiculo implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "av_seq_gen")
    @SequenceGenerator(name = "av_seq_gen", sequenceName = "AV_ID_AV_SEQ", allocationSize = 1)
    @Column(name = "ID_AV") // Mapeia para a PK da tabela AV
    private Long id;

    // Relacionamento ManyToOne com Agenda
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "AGENDAR_ID_AGE", nullable = false) // Mapeia para a FK AGENDAR_ID_AGE
    private Agenda agenda;

    // Relacionamento ManyToOne com Veiculo
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "T_VEICULOS_ID_VEI", nullable = false) // Mapeia para a FK T_VEICULOS_ID_VEI
    private Veiculo veiculo;

    // Getters, Setters, etc., gerados pelo Lombok
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\model\relacionamentos\ClienteId.java   |   package br.com.fiap.model.relacionamentos   |   class ClienteId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.model.relacionamentos;

import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.*;
import java.io.Serializable;

@Embeddable // Marca como classe de ID embutível
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode // Essencial para chaves compostas
public class ClienteId implements Serializable {

    private static final long serialVersionUID = 1L; // Boa prática

    @Column(name = "ID_CLI") // Mapeia EXATAMENTE para a coluna ID_CLI da tabela TB_CLIENTES
    private Long idCli; // Parte 1 da chave primária

    // A segunda parte da chave (ENDERECOS_ID_END) será mapeada via @MapsId na entidade Clientes
    // Não precisa de @Column aqui, pois seu valor virá do relacionamento com Endereco.
    private Long enderecoId; // Parte 2 da chave primária
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\model\relacionamentos\ClienteOrcamento.java   |   package br.com.fiap.model.relacionamentos   |   class ClienteOrcamento
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.model.relacionamentos; // Ou subpacote

import br.com.fiap.model.Clientes;
import br.com.fiap.model.Orcamento;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;

@Entity
@Table(name = "CO")
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @EqualsAndHashCode(of = "id") @ToString
public class ClienteOrcamento implements Serializable {
    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "co_seq_gen")
    @SequenceGenerator(name = "co_seq_gen", sequenceName = "CO_ID_CO_SEQ", allocationSize = 1)
    @Column(name = "ID_CO")
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumns({ // Usa @JoinColumns (plural) para FK composta de Cliente
            @JoinColumn(name = "CLIENTES_ID_CLI", referencedColumnName = "ID_CLI", nullable = false),
            @JoinColumn(name = "CLIENTES_ENDERECOS_ID_END", referencedColumnName = "ENDERECOS_ID_END", nullable = false)
    })
    private Clientes cliente;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "ORCAMENTOS_ID_ORC", nullable = false)
    private Orcamento orcamento;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\model\relacionamentos\ClientePagamento.java   |   package br.com.fiap.model.relacionamentos   |   class ClientePagamento
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.model.relacionamentos; // Ou subpacote

import br.com.fiap.model.Clientes;
import br.com.fiap.model.Pagamento;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;

@Entity
@Table(name = "CP")
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @EqualsAndHashCode(of = "id") @ToString
public class ClientePagamento implements Serializable {
    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "cp_seq_gen")
    @SequenceGenerator(name = "cp_seq_gen", sequenceName = "CP_ID_CP_SEQ", allocationSize = 1)
    @Column(name = "ID_CP")
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumns({ // Usa @JoinColumns (plural) para FK composta de Cliente
            @JoinColumn(name = "CLIENTES_ID_CLI", referencedColumnName = "ID_CLI", nullable = false),
            @JoinColumn(name = "CLIENTES_ENDERECOS_ID_END", referencedColumnName = "ENDERECOS_ID_END", nullable = false)
    })
    private Clientes cliente;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "PAGAMENTOS_ID_PAG", nullable = false)
    private Pagamento pagamento;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\model\relacionamentos\ClienteVeiculo.java   |   package br.com.fiap.model.relacionamentos   |   class ClienteVeiculo
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.model.relacionamentos;

import br.com.fiap.model.Clientes;
import br.com.fiap.model.Veiculo;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;

@Entity
@Table(name = "CV") // Nome da tabela de junção

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "id")
@ToString
public class ClienteVeiculo implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "cv_seq_gen")
    @SequenceGenerator(name = "cv_seq_gen", sequenceName = "CV_ID_CV_SEQ", allocationSize = 1)
    @Column(name = "ID_CV") // PK da tabela CV
    private Long id;

    // Relacionamento ManyToOne com Cliente (usando Chave Composta)
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumns({ // Usa @JoinColumns (plural) para FK composta
            @JoinColumn(name = "CLIENTES_ID_CLI", referencedColumnName = "ID_CLI", nullable = false), // Parte 1 da FK/PK
            @JoinColumn(name = "CLIENTES_ENDERECOS_ID_END", referencedColumnName = "ENDERECOS_ID_END", nullable = false) // Parte 2 da FK/PK
    })
    private Clientes cliente;

    // Relacionamento ManyToOne com Veiculo (chave simples)
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "T_VEICULOS_ID_VEI", nullable = false) // FK para VEICULOS
    private Veiculo veiculo;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\model\relacionamentos\OficinaOrcamento.java   |   package br.com.fiap.model.relacionamentos   |   class OficinaOrcamento
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.model.relacionamentos; // Ou subpacote

import br.com.fiap.model.Oficina;
import br.com.fiap.model.Orcamento;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;

@Entity
@Table(name = "OFO")
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @EqualsAndHashCode(of = "id") @ToString
public class OficinaOrcamento implements Serializable {
    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "ofo_seq_gen")
    @SequenceGenerator(name = "ofo_seq_gen", sequenceName = "OFO_ID_OFO_SEQ", allocationSize = 1)
    @Column(name = "ID_OFO")
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "OFICINAS_ID_OFIC", nullable = false)
    private Oficina oficina;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "ORCAMENTOS_ID_ORC", nullable = false)
    private Orcamento orcamento;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\model\relacionamentos\OficinaPeca.java   |   package br.com.fiap.model.relacionamentos   |   class OficinaPeca
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.model.relacionamentos;

import br.com.fiap.model.Oficina;
import br.com.fiap.model.Pecas;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;

@Entity
@Table(name = "OFP") // Nome da tabela de junção

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "id")
@ToString
public class OficinaPeca implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "ofp_seq_gen")
    // !!! Atenção ao nome da sequence no DDL: OFP_ID_OPE_SEQ !!!
    @SequenceGenerator(name = "ofp_seq_gen", sequenceName = "OFP_ID_OPE_SEQ", allocationSize = 1)
    @Column(name = "ID_OPE") // PK da tabela OFP
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "OFICINAS_ID_OFIC", nullable = false) // FK para OFICINAS
    private Oficina oficina;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "PECAS_ID_PEC", nullable = false) // FK para PECAS
    private Pecas peca;

    @Column(name = "QUANTIDADE", nullable = false)
    private Integer quantidade;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\model\relacionamentos\OficinaVeiculo.java   |   package br.com.fiap.model.relacionamentos   |   class OficinaVeiculo
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.model.relacionamentos; // Ou subpacote

import br.com.fiap.model.Oficina;
import br.com.fiap.model.Veiculo;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;

@Entity
@Table(name = "OV")
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @EqualsAndHashCode(of = "id") @ToString
public class OficinaVeiculo implements Serializable {
    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "ov_seq_gen")
    @SequenceGenerator(name = "ov_seq_gen", sequenceName = "OV_ID_OV_SEQ", allocationSize = 1)
    @Column(name = "ID_OV")
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "OFICINAS_ID_OFIC", nullable = false)
    private Oficina oficina;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "T_VEICULOS_ID_VEI", nullable = false)
    private Veiculo veiculo;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\model\relacionamentos\PagamentoOrcamento.java   |   package br.com.fiap.model.relacionamentos   |   class PagamentoOrcamento
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.model.relacionamentos; // Ou subpacote

import br.com.fiap.model.Orcamento;
import br.com.fiap.model.Pagamento;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;

@Entity
@Table(name = "PAO")
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @EqualsAndHashCode(of = "id") @ToString
public class PagamentoOrcamento implements Serializable {
    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "pao_seq_gen")
    @SequenceGenerator(name = "pao_seq_gen", sequenceName = "PAO_ID_PAO_SEQ", allocationSize = 1)
    @Column(name = "ID_PAO")
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "PAGAMENTOS_ID_PAG", nullable = false)
    private Pagamento pagamento;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "ORCAMENTOS_ID_ORC", nullable = false)
    private Orcamento orcamento;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\model\relacionamentos\PecaVeiculo.java   |   package br.com.fiap.model.relacionamentos   |   class PecaVeiculo
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.model.relacionamentos; // Ou subpacote

import br.com.fiap.model.Pecas;
import br.com.fiap.model.Veiculo;
import jakarta.persistence.*;
import lombok.*;
import java.io.Serializable;

@Entity
@Table(name = "PV")
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @EqualsAndHashCode(of = "id") @ToString
public class PecaVeiculo implements Serializable {
    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "pv_seq_gen")
    @SequenceGenerator(name = "pv_seq_gen", sequenceName = "PV_ID_PV_SEQ", allocationSize = 1)
    @Column(name = "ID_PV")
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "PECAS_ID_PEC", nullable = false)
    private Pecas peca;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "T_VEICULOS_ID_VEI", nullable = false)
    private Veiculo veiculo;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\repository\AgendaRepository.java   |   package br.com.fiap.repository   |   class AgendaRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/main/java/br/com/fiap/repository/AgendaRepository.java
package br.com.fiap.repository;

import br.com.fiap.dto.relatorio.ContagemMensalResultadoNativo;
import br.com.fiap.dto.relatorio.HistoricoAgendamentoClienteDTO;
import br.com.fiap.dto.relatorio.ServicoAgendadoDTO;
import br.com.fiap.model.Agenda;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import java.time.LocalDate;
import java.util.List;

public interface AgendaRepository extends JpaRepository<Agenda, Long>, JpaSpecificationExecutor<Agenda> {

    Page<Agenda> findByObservacaoContainingIgnoreCase(String observacao, Pageable pageable);

    // Query Nativa não é afetada por comentários Java
    @Query(value = "SELECT TO_CHAR(a.DATA_AGENDAMENTO, 'YYYY-MM') as mesAno, COUNT(a.ID_AGE) as quantidade FROM AGENDAR a GROUP BY TO_CHAR(a.DATA_AGENDAMENTO, 'YYYY-MM') ORDER BY mesAno DESC", nativeQuery = true)
    List<ContagemMensalResultadoNativo> countAgendamentosByMonthNative();

    // Query JPQL para Histórico (sem comentários internos)
    @Query("""
           SELECT new br.com.fiap.dto.relatorio.HistoricoAgendamentoClienteDTO(
               a.dataAgendamento,
               a.observacao,
               v.placa
           )
           FROM Agenda a
           JOIN a.agendaVeiculos av
           JOIN av.veiculo v
           JOIN v.clienteVeiculos cv
           WHERE cv.cliente.id.idCli = :idCliente AND cv.cliente.id.enderecoId = :idEndereco
           ORDER BY a.dataAgendamento DESC
           """)
    List<HistoricoAgendamentoClienteDTO> findHistoricoAgendamentosByClienteId(
            @Param("idCliente") Long idCliente,
            @Param("idEndereco") Long idEndereco
    );

    /**
     * Busca uma página de serviços agendados a partir de uma data inicial,
     * incluindo informações do veículo e diagnóstico da oficina, se disponíveis.
     *
     * @param dataInicio Data inicial para a busca (inclusive). Se null, busca todos os agendamentos.
     * @param pageable   Informações de paginação e ordenação.
     * @return Uma página (Page) de ServicoAgendadoDTO.
     */
    // Query JPQL para Serviços Agendados (sem comentários internos)
    @Query("""
            SELECT new br.com.fiap.dto.relatorio.ServicoAgendadoDTO(
                a.id,
                a.dataAgendamento,
                a.observacao,
                v.placa,
                o.descricaoProblema,
                o.diagnostico
            )
            FROM Agenda a
            LEFT JOIN a.agendaVeiculos av LEFT JOIN av.veiculo v
            LEFT JOIN a.agendaOficinas ao LEFT JOIN ao.oficina o
            WHERE (:dataInicio IS NULL OR a.dataAgendamento >= :dataInicio)
            """)
    Page<ServicoAgendadoDTO> findServicosAgendados(
            @Param("dataInicio") LocalDate dataInicio,
            Pageable pageable
    );
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\repository\AutenticarRepository.java   |   package br.com.fiap.repository   |   class AutenticarRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.repository;

import br.com.fiap.model.autenticar.Autenticar;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional; // Importe Optional

public interface AutenticarRepository extends JpaRepository<Autenticar, Long> {

    // Adicionar este método para buscar um usuário pelo nome de usuário
    Optional<Autenticar> findByUsuario(String usuario);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\repository\ClientesRepository.java   |   package br.com.fiap.repository   |   class ClientesRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/main/java/br/com/fiap/repository/ClientesRepository.java
package br.com.fiap.repository;

import br.com.fiap.model.Clientes;
import br.com.fiap.model.relacionamentos.ClienteId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor; // <<< ADICIONAR IMPORT

// Adicionar JpaSpecificationExecutor para permitir buscas com Specification
public interface ClientesRepository extends JpaRepository<Clientes, ClienteId>, JpaSpecificationExecutor<Clientes> {
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\repository\ContatoRepository.java   |   package br.com.fiap.repository   |   class ContatoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.repository;

import br.com.fiap.model.Contato;
import org.springframework.data.jpa.repository.JpaRepository;

public interface ContatoRepository extends JpaRepository<Contato, Long> {
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\repository\EnderecoRepository.java   |   package br.com.fiap.repository   |   class EnderecoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.repository;

import br.com.fiap.model.Endereco;
import org.springframework.data.jpa.repository.JpaRepository;

public interface EnderecoRepository extends JpaRepository<Endereco, Long> {
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\repository\OficinaRepository.java   |   package br.com.fiap.repository   |   class OficinaRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.repository;

import br.com.fiap.model.Oficina;
import org.springframework.data.jpa.repository.JpaRepository;

public interface OficinaRepository extends JpaRepository<Oficina, Long> {
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\repository\OrcamentoRepository.java   |   package br.com.fiap.repository   |   class OrcamentoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.repository;

import br.com.fiap.model.Orcamento;
import org.springframework.data.jpa.repository.JpaRepository;

public interface OrcamentoRepository extends JpaRepository<Orcamento, Long> {
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\repository\PagamentoRepository.java   |   package br.com.fiap.repository   |   class PagamentoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// br/com/fiap/repository/PagamentoRepository.java
package br.com.fiap.repository;

import br.com.fiap.dto.relatorio.PagamentoPorTipoDto;
import br.com.fiap.model.Pagamento;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;

@Repository
public interface PagamentoRepository extends JpaRepository<Pagamento, Long>, JpaSpecificationExecutor<Pagamento> {

    // Query para Estatísticas Gerais
    @Query("SELECT COUNT(p.id) as totalOperacoes, " +
            "SUM(p.totalComDesconto) as valorTotalArrecadado, " +
            "AVG(p.totalComDesconto) as ticketMedio " +
            "FROM Pagamento p WHERE p.dataPagamento BETWEEN :dataInicio AND :dataFim")
    List<Object[]> getEstatisticasPagamentos(@Param("dataInicio") LocalDate dataInicio, @Param("dataFim") LocalDate dataFim);


    // Query para Pagamentos por Tipo
    @Query("SELECT new br.com.fiap.dto.relatorio.PagamentoPorTipoDto(p.tipoPagamento, COUNT(p.id), SUM(p.totalComDesconto)) " +
            "FROM Pagamento p WHERE p.dataPagamento BETWEEN :dataInicio AND :dataFim " +
            "GROUP BY p.tipoPagamento ORDER BY SUM(p.totalComDesconto) DESC")
    List<PagamentoPorTipoDto> findPagamentosAgrupadosPorTipo(@Param("dataInicio") LocalDate dataInicio, @Param("dataFim") LocalDate dataFim);

    // Query para Evolução Mensal do Valor
    // Oracle TO_CHAR para extrair 'YYYY-MM'
    @Query(value = "SELECT TO_CHAR(p.data_pagamento, 'YYYY-MM') as mesAno, SUM(p.total_pagamento_desconto) as valorTotal " +
            "FROM PAGAMENTOS p WHERE p.data_pagamento BETWEEN :dataInicio AND :dataFim " +
            "GROUP BY TO_CHAR(p.data_pagamento, 'YYYY-MM') ORDER BY mesAno ASC", nativeQuery = true)
    List<Object[]> findEvolucaoMensalValorPagamentosNativo(@Param("dataInicio") LocalDate dataInicio, @Param("dataFim") LocalDate dataFim); // <<< CORRETO: Retorna List<Object[]>
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\repository\PecasRepository.java   |   package br.com.fiap.repository   |   class PecasRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.repository;

import br.com.fiap.model.Pecas;
import org.springframework.data.jpa.repository.JpaRepository;

public interface PecasRepository extends JpaRepository<Pecas, Long> {
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\repository\VeiculoRepository.java   |   package br.com.fiap.repository   |   class VeiculoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/main/java/br/com/fiap/repository/VeiculoRepository.java
package br.com.fiap.repository;

import br.com.fiap.model.Veiculo;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor; // <<< ADICIONAR IMPORT

// Adicionar JpaSpecificationExecutor para permitir buscas dinâmicas
public interface VeiculoRepository extends JpaRepository<Veiculo, Long>, JpaSpecificationExecutor<Veiculo> {
    // Nenhum método novo precisa ser definido aqui para a busca com Specification
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\repository\relacionamentos\AgendaOficinaRepository.java   |   package br.com.fiap.repository.relacionamentos   |   class AgendaOficinaRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.repository.relacionamentos;

import br.com.fiap.model.relacionamentos.AgendaOficina;
import org.springframework.data.jpa.repository.JpaRepository;

public interface AgendaOficinaRepository extends JpaRepository<AgendaOficina, Long> {
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\repository\relacionamentos\AgendaVeiculoRepository.java   |   package br.com.fiap.repository.relacionamentos   |   class AgendaVeiculoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// --- src/main/java/br/com/fiap/repository/relacionamentos/AgendaVeiculoRepository.java ---
package br.com.fiap.repository.relacionamentos;

import br.com.fiap.model.relacionamentos.AgendaVeiculo;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List; // Importar List
import java.util.Optional; // Importar Optional

// Repositório para a entidade de junção AV
public interface AgendaVeiculoRepository extends JpaRepository<AgendaVeiculo, Long> {

    /**
     * Verifica se uma associação específica já existe pelos IDs das entidades relacionadas.
     * @param agendaId ID da Agenda
     * @param veiculoId ID do Veiculo
     * @return true se a associação existe, false caso contrário.
     */
    boolean existsByAgendaIdAndVeiculoId(Long agendaId, Long veiculoId);

    /**
     * Busca uma associação específica (Optional) pelos IDs das entidades relacionadas.
     * @param agendaId ID da Agenda
     * @param veiculoId ID do Veiculo
     * @return Optional contendo a associação se encontrada, Optional vazio caso contrário.
     */
    Optional<AgendaVeiculo> findByAgendaIdAndVeiculoId(Long agendaId, Long veiculoId);

    /**
     * Busca todas as associações (AgendaVeiculo) para um determinado ID de agenda.
     * Necessário para os métodos deleteById e findVeiculosByAgendaId em AgendaServiceImpl.
     * @param agendaId O ID da Agenda cujas associações devem ser buscadas.
     * @return Uma lista de entidades AgendaVeiculo.
     */
    List<AgendaVeiculo> findByAgendaId(Long agendaId); // <<< MÉTODO QUE ESTAVA FALTANDO

    List<AgendaVeiculo> findByVeiculoIdIn(List<Long> veiculoIds);

}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\repository\relacionamentos\ClienteOrcamentoRepository.java   |   package br.com.fiap.repository.relacionamentos   |   class ClienteOrcamentoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// br/com/fiap/repository/relacionamentos/ClienteOrcamentoRepository.java
package br.com.fiap.repository.relacionamentos;

import br.com.fiap.model.relacionamentos.ClienteId;
import br.com.fiap.model.relacionamentos.ClienteOrcamento;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

public interface ClienteOrcamentoRepository extends JpaRepository<ClienteOrcamento, Long> {

    List<ClienteOrcamento> findByCliente_Id(ClienteId clienteId);

    // <<< NOVO MÉTODO ADICIONADO >>>
    List<ClienteOrcamento> findByOrcamentoId(Long orcamentoId);

    // Opcional:
    // void deleteByOrcamentoId(Long orcamentoId);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\repository\relacionamentos\ClientePagamentoRepository.java   |   package br.com.fiap.repository.relacionamentos   |   class ClientePagamentoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// --- Arquivo: src/main/java/br/com/fiap/repository/relacionamentos/ClientePagamentoRepository.java ---
package br.com.fiap.repository.relacionamentos;

import br.com.fiap.model.relacionamentos.ClienteId; // Importar ClienteId
import br.com.fiap.model.relacionamentos.ClientePagamento;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List; // Importar List

public interface ClientePagamentoRepository extends JpaRepository<ClientePagamento, Long> {

    // <<< NOVO MÉTODO ADICIONADO >>>
    List<ClientePagamento> findByCliente_Id(ClienteId clienteId);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\repository\relacionamentos\ClienteVeiculoRepository.java   |   package br.com.fiap.repository.relacionamentos   |   class ClienteVeiculoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// --- Arquivo: src/main/java/br/com/fiap/repository/relacionamentos/ClienteVeiculoRepository.java ---
package br.com.fiap.repository.relacionamentos;

import br.com.fiap.model.relacionamentos.ClienteId; // Importar ClienteId
import br.com.fiap.model.relacionamentos.ClienteVeiculo;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List; // Importar List

public interface ClienteVeiculoRepository extends JpaRepository<ClienteVeiculo, Long> {

    // <<< NOVO MÉTODO ADICIONADO >>>
    // Busca todas as associações ClienteVeiculo baseadas no ID composto do Cliente.
    // Spring Data JPA entende "cliente" (o nome do campo na entidade ClienteVeiculo)
    // e "id" (o nome do campo @EmbeddedId na entidade Clientes).
    List<ClienteVeiculo> findByCliente_Id(ClienteId clienteId);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\repository\relacionamentos\OficinaOrcamentoRepository.java   |   package br.com.fiap.repository.relacionamentos   |   class OficinaOrcamentoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// br/com/fiap/repository/relacionamentos/OficinaOrcamentoRepository.java
package br.com.fiap.repository.relacionamentos;

import br.com.fiap.model.relacionamentos.OficinaOrcamento;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List; // Adicionar este import

public interface OficinaOrcamentoRepository extends JpaRepository<OficinaOrcamento, Long> {

    // <<< NOVO MÉTODO ADICIONADO >>>
    List<OficinaOrcamento> findByOrcamentoId(Long orcamentoId);

    // Opcionalmente, você poderia adicionar um método para deletar diretamente,
    // mas buscar e depois deletar a lista é uma abordagem comum e segura.
    // @Modifying
    // @Query("DELETE FROM OficinaOrcamento oo WHERE oo.orcamento.id = :orcamentoId")
    // void deleteByOrcamentoId(@Param("orcamentoId") Long orcamentoId);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\repository\relacionamentos\OficinaPecaRepository.java   |   package br.com.fiap.repository.relacionamentos   |   class OficinaPecaRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.repository.relacionamentos;

import br.com.fiap.model.relacionamentos.OficinaPeca;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

public interface OficinaPecaRepository extends JpaRepository<OficinaPeca, Long> {

    List<OficinaPeca> findByOficinaId(Long oficinaId);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\repository\relacionamentos\OficinaVeiculoRepository.java   |   package br.com.fiap.repository.relacionamentos   |   class OficinaVeiculoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.repository.relacionamentos
package br.com.fiap.repository.relacionamentos;

import br.com.fiap.model.relacionamentos.OficinaVeiculo;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

public interface OficinaVeiculoRepository extends JpaRepository<OficinaVeiculo, Long> {

    List<OficinaVeiculo> findByVeiculoIdIn(List<Long> veiculoIds);

    // <<< NOVO MÉTODO ADICIONADO >>>
    List<OficinaVeiculo> findByVeiculoId(Long veiculoId);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\repository\relacionamentos\PagamentoOrcamentoRepository.java   |   package br.com.fiap.repository.relacionamentos   |   class PagamentoOrcamentoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// br/com/fiap/repository/relacionamentos/PagamentoOrcamentoRepository.java
package br.com.fiap.repository.relacionamentos;

import br.com.fiap.model.relacionamentos.PagamentoOrcamento;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List; // Adicionar este import

public interface PagamentoOrcamentoRepository extends JpaRepository<PagamentoOrcamento, Long> {

    // <<< NOVO MÉTODO ADICIONADO >>>
    List<PagamentoOrcamento> findByOrcamentoId(Long orcamentoId);

    // Opcional:
    // void deleteByOrcamentoId(Long orcamentoId);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\repository\relacionamentos\PecaVeiculoRepository.java   |   package br.com.fiap.repository.relacionamentos   |   class PecaVeiculoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.repository.relacionamentos;

import br.com.fiap.model.relacionamentos.PecaVeiculo;
import org.springframework.data.jpa.repository.JpaRepository;

public interface PecaVeiculoRepository extends JpaRepository<PecaVeiculo, Long> {
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\repository\specification\AgendaSpecification.java   |   package br.com.fiap.repository.specification   |   class AgendaSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// --- src/main/java/br/com/fiap/repository/specification/AgendaSpecification.java ---
package br.com.fiap.repository.specification;

import br.com.fiap.model.Agenda;
import org.springframework.data.jpa.domain.Specification;
import jakarta.persistence.criteria.Predicate;
import java.time.LocalDate;

public class AgendaSpecification {

    // Evita instanciação
    private AgendaSpecification() {}

    /**
     * Cria uma Specification para filtrar por data de agendamento >= dataInicio.
     */
    public static Specification<Agenda> dataAgendamentoMaiorOuIgualA(LocalDate dataInicio) {
        return (root, query, criteriaBuilder) ->
                criteriaBuilder.greaterThanOrEqualTo(root.get("dataAgendamento"), dataInicio);
        // "dataAgendamento" é o nome do campo na entidade Agenda
    }

    /**
     * Cria uma Specification para filtrar por data de agendamento <= dataFim.
     */
    public static Specification<Agenda> dataAgendamentoMenorOuIgualA(LocalDate dataFim) {
        return (root, query, criteriaBuilder) ->
                criteriaBuilder.lessThanOrEqualTo(root.get("dataAgendamento"), dataFim);
    }

    /**
     * Cria uma Specification para filtrar por observacao contendo (ignorando case).
     */
    public static Specification<Agenda> observacaoContem(String observacao) {
        return (root, query, criteriaBuilder) ->
                criteriaBuilder.like(criteriaBuilder.lower(root.get("observacao")), "%" + observacao.toLowerCase() + "%");
        // "observacao" é o nome do campo na entidade Agenda
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\repository\specification\ClienteSpecification.java   |   package br.com.fiap.repository.specification   |   class ClienteSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/main/java/br/com/fiap/repository/specification/ClienteSpecification.java
package br.com.fiap.repository.specification;

import br.com.fiap.model.Clientes;
import org.springframework.data.jpa.domain.Specification;
import jakarta.persistence.criteria.Predicate;

public class ClienteSpecification {

    private ClienteSpecification() {} // Evita instanciação

    public static Specification<Clientes> nomeContains(String nome) {
        return (root, query, cb) -> {
            if (nome == null || nome.isBlank()) {
                return cb.conjunction();
            }
            Predicate nomeMatch = cb.like(cb.lower(root.get("nome")), "%" + nome.toLowerCase() + "%");
            Predicate sobrenomeMatch = cb.like(cb.lower(root.get("sobrenome")), "%" + nome.toLowerCase() + "%");
            return cb.or(nomeMatch, sobrenomeMatch);
        };
    }

    public static Specification<Clientes> numeroDocumentoEquals(String documento) {
        return (root, query, cb) -> {
            if (documento == null || documento.isBlank()) {
                return cb.conjunction();
            }
            return cb.equal(root.get("numeroDocumento"), documento);
        };
    }

    public static Specification<Clientes> idCliEquals(Long idCli) {
        return (root, query, cb) -> {
            if (idCli == null || idCli <= 0) {
                return cb.conjunction();
            }
            // Acessa o campo 'idCli' dentro do 'id' (EmbeddedId)
            return cb.equal(root.get("id").get("idCli"), idCli);
        };
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\repository\specification\PagamentoSpecification.java   |   package br.com.fiap.repository.specification   |   class PagamentoSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.repository.specification;

import br.com.fiap.model.Pagamento;
import br.com.fiap.model.relacionamentos.ClientePagamento; // Para join com Cliente
import br.com.fiap.model.relacionamentos.PagamentoOrcamento; // Para join com Orcamento
import jakarta.persistence.criteria.*; // Import para Criteria API (Join, Predicate, etc)
import org.springframework.data.jpa.domain.Specification;
import org.springframework.util.StringUtils; // Helper do Spring para verificar strings

import java.math.BigDecimal;
import java.time.LocalDate;

public class PagamentoSpecification {

    // Construtor privado para evitar instanciação
    private PagamentoSpecification() {}

    /**
     * Cria Specification para filtrar por data de pagamento >= dataInicio.
     */
    public static Specification<Pagamento> dataPagamentoMaiorOuIgualA(LocalDate dataInicio) {
        return (root, query, criteriaBuilder) ->
                criteriaBuilder.greaterThanOrEqualTo(root.get("dataPagamento"), dataInicio);
        // "dataPagamento" é o nome do campo na entidade Pagamento
    }

    /**
     * Cria Specification para filtrar por data de pagamento <= dataFim.
     */
    public static Specification<Pagamento> dataPagamentoMenorOuIgualA(LocalDate dataFim) {
        return (root, query, criteriaBuilder) ->
                criteriaBuilder.lessThanOrEqualTo(root.get("dataPagamento"), dataFim);
    }

    /**
     * Cria Specification para filtrar por tipo de pagamento (ignorando case).
     */
    public static Specification<Pagamento> tipoPagamentoIgual(String tipo) {
        return (root, query, criteriaBuilder) ->
                // Usar hasText para verificar se não é nulo ou vazio/branco
                StringUtils.hasText(tipo) ?
                        criteriaBuilder.equal(criteriaBuilder.lower(root.get("tipoPagamento")), tipo.toLowerCase())
                        : criteriaBuilder.conjunction(); // Retorna um predicado "verdadeiro" se tipo for nulo/vazio
    }

    /**
     * Cria Specification para filtrar por totalComDesconto >= valorMin.
     */
    public static Specification<Pagamento> totalComDescontoMaiorOuIgualA(BigDecimal valorMin) {
        return (root, query, criteriaBuilder) ->
                criteriaBuilder.greaterThanOrEqualTo(root.get("totalComDesconto"), valorMin);
    }

    /**
     * Cria Specification para filtrar por totalComDesconto <= valorMax.
     */
    public static Specification<Pagamento> totalComDescontoMenorOuIgualA(BigDecimal valorMax) {
        return (root, query, criteriaBuilder) ->
                criteriaBuilder.lessThanOrEqualTo(root.get("totalComDesconto"), valorMax);
    }

    /**
     * Cria Specification para filtrar pagamentos associados a um Cliente específico.
     * Requer um JOIN com a entidade de relacionamento ClientePagamento.
     */
    public static Specification<Pagamento> associadoAoCliente(Long clienteId) {
        return (root, query, criteriaBuilder) -> {
            // Evita joins desnecessários se o critério não for aplicado
            query.distinct(true); // Garante resultados distintos caso um pagamento esteja ligado múltiplas vezes (improvável aqui, mas boa prática)
            // Faz o JOIN da entidade Pagamento (root) para a coleção clientePagamentos
            // e depois para a entidade Cliente dentro de ClientePagamento
            Join<Pagamento, ClientePagamento> clientePagamentoJoin = root.join("clientePagamentos", JoinType.INNER);
            // Filtra pelo ID do cliente (considerando a chave composta)
            // Assumindo que ClientePagamento tem um campo 'cliente' e Cliente tem 'id.idCli'
            return criteriaBuilder.equal(clientePagamentoJoin.get("cliente").get("id").get("idCli"), clienteId);
            // Ajuste os nomes "cliente", "id", "idCli" conforme sua entidade Cliente e ClientePagamento
        };
    }

    /**
     * Cria Specification para filtrar pagamentos associados a um Orcamento específico.
     * Requer um JOIN com a entidade de relacionamento PagamentoOrcamento.
     */
    public static Specification<Pagamento> associadoAoOrcamento(Long orcamentoId) {
        return (root, query, criteriaBuilder) -> {
            query.distinct(true);
            Join<Pagamento, PagamentoOrcamento> pagamentoOrcamentoJoin = root.join("pagamentoOrcamentos", JoinType.INNER);
            // Filtra pelo ID do orçamento
            // Assumindo que PagamentoOrcamento tem um campo 'orcamento' e Orcamento tem 'id'
            return criteriaBuilder.equal(pagamentoOrcamentoJoin.get("orcamento").get("id"), orcamentoId);
            // Ajuste os nomes "orcamento", "id" conforme sua entidade Orcamento e PagamentoOrcamento
        };
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\repository\specification\VeiculoSpecification.java   |   package br.com.fiap.repository.specification   |   class VeiculoSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/main/java/br/com/fiap/repository/specification/VeiculoSpecification.java
package br.com.fiap.repository.specification;

import br.com.fiap.model.Veiculo;
import org.springframework.data.jpa.domain.Specification;
import jakarta.persistence.criteria.Predicate;

public class VeiculoSpecification {

    private VeiculoSpecification() {} // Construtor privado para evitar instanciação

    // Busca case-insensitive por parte da placa
    public static Specification<Veiculo> placaContains(String placa) {
        return (root, query, cb) -> {
            if (placa == null || placa.isBlank()) return cb.conjunction(); // Ignora se vazio
            return cb.like(cb.lower(root.get("placa")), "%" + placa.toLowerCase() + "%");
        };
    }

    // Busca case-insensitive por parte do modelo
    public static Specification<Veiculo> modeloContains(String modelo) {
        return (root, query, cb) -> {
            if (modelo == null || modelo.isBlank()) return cb.conjunction();
            return cb.like(cb.lower(root.get("modelo")), "%" + modelo.toLowerCase() + "%");
        };
    }

    // Busca case-insensitive por parte do proprietário
    public static Specification<Veiculo> proprietarioContains(String proprietario) {
        return (root, query, cb) -> {
            if (proprietario == null || proprietario.isBlank()) return cb.conjunction();
            return cb.like(cb.lower(root.get("proprietario")), "%" + proprietario.toLowerCase() + "%");
        };
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\service\agenda\AgendaService.java   |   package br.com.fiap.service.agenda   |   class AgendaService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// --- src/main/java/br/com/fiap/service/agenda/AgendaService.java ---
package br.com.fiap.service.agenda;

import br.com.fiap.dto.agenda.AgendaRequestDto;
import br.com.fiap.dto.agenda.AgendaResponseDto;
import br.com.fiap.dto.veiculo.VeiculoResponseDto;
import org.springframework.data.domain.Page; // Importar Page
import org.springframework.data.domain.Pageable; // Importar Pageable
import java.time.LocalDate;
import java.util.List;

public interface AgendaService {

    // Novo método com paginação e filtro
    Page<AgendaResponseDto> findWithFilters(LocalDate dataInicio, LocalDate dataFim, String observacao, Pageable pageable);

    AgendaResponseDto findById(Long id);
    AgendaResponseDto create(AgendaRequestDto agendaDto);
    AgendaResponseDto update(Long id, AgendaRequestDto agendaDto);
    void deleteById(Long id);

    // Métodos para Gerenciar Relacionamento com Veiculo
    void associarVeiculo(Long agendaId, Long veiculoId);
    void desassociarVeiculo(Long agendaId, Long veiculoId);
    List<VeiculoResponseDto> findVeiculosByAgendaId(Long agendaId);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\service\agenda\AgendaServiceImpl.java   |   package br.com.fiap.service.agenda   |   class AgendaServiceImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// --- src/main/java/br/com/fiap/service/agenda/AgendaServiceImpl.java ---
package br.com.fiap.service.agenda;

// TODOS OS IMPORTS NECESSÁRIOS (como na resposta anterior)
import br.com.fiap.dto.agenda.AgendaRequestDto;
import br.com.fiap.dto.agenda.AgendaResponseDto;
import br.com.fiap.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.exception.AgendaNotFoundException;
import br.com.fiap.exception.VeiculoNotFoundException;
import br.com.fiap.exception.AssociacaoNotFoundException; // Ou AgendaNotFoundException
import br.com.fiap.mapper.AgendaMapper;
import br.com.fiap.mapper.VeiculoMapper;
import br.com.fiap.model.Agenda;
import br.com.fiap.model.Veiculo;
import br.com.fiap.model.relacionamentos.AgendaVeiculo;
import br.com.fiap.repository.AgendaRepository;
import br.com.fiap.repository.VeiculoRepository;
import br.com.fiap.repository.relacionamentos.AgendaVeiculoRepository;
import br.com.fiap.repository.specification.AgendaSpecification;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.time.LocalDate;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class AgendaServiceImpl implements AgendaService { // Chave de abertura da classe

    private static final Logger log = LoggerFactory.getLogger(AgendaServiceImpl.class);
    private final AgendaRepository agendaRepository;
    private final AgendaMapper agendaMapper;
    private final VeiculoRepository veiculoRepository;
    private final AgendaVeiculoRepository agendaVeiculoRepository;
    private final VeiculoMapper veiculoMapper;

    @Autowired
    public AgendaServiceImpl(AgendaRepository agendaRepository,
                             AgendaMapper agendaMapper,
                             VeiculoRepository veiculoRepository,
                             AgendaVeiculoRepository agendaVeiculoRepository,
                             VeiculoMapper veiculoMapper
    ) {
        this.agendaRepository = agendaRepository;
        this.agendaMapper = agendaMapper;
        this.veiculoRepository = veiculoRepository;
        this.agendaVeiculoRepository = agendaVeiculoRepository;
        this.veiculoMapper = veiculoMapper;
    }

    @Override
    @Transactional(readOnly = true)
    public Page<AgendaResponseDto> findWithFilters(LocalDate dataInicio, LocalDate dataFim, String observacao, Pageable pageable) {
        // ... (código do método findWithFilters - sem alterações)
        log.info("Buscando agendas com filtros: dataInicio={}, dataFim={}, observacao='{}', pageable={}",
                dataInicio, dataFim, observacao, pageable);
        Specification<Agenda> spec = Specification.where(null);
        if (dataInicio != null) {
            spec = spec.and(AgendaSpecification.dataAgendamentoMaiorOuIgualA(dataInicio));
        }
        if (dataFim != null) {
            spec = spec.and(AgendaSpecification.dataAgendamentoMenorOuIgualA(dataFim));
        }
        if (observacao != null && !observacao.isBlank()) {
            spec = spec.and(AgendaSpecification.observacaoContem(observacao));
        }
        Page<Agenda> paginaAgenda = agendaRepository.findAll(spec, pageable);
        log.info("Encontradas {} agendas na página {}/{}", paginaAgenda.getNumberOfElements(), pageable.getPageNumber(), paginaAgenda.getTotalPages());
        return paginaAgenda.map(agendaMapper::toResponseDto);
    }

    @Override
    @Transactional(readOnly = true)
    public AgendaResponseDto findById(Long id) {
        // ... (código do método findById - sem alterações)
        log.info("Buscando agenda por ID: {}", id);
        Agenda agenda = agendaRepository.findById(id)
                .orElseThrow(() -> new AgendaNotFoundException("Agenda não encontrada com ID: " + id));
        return agendaMapper.toResponseDto(agenda);
    }

    @Override
    @Transactional
    public AgendaResponseDto create(AgendaRequestDto agendaDto) {
        // ... (código do método create - sem alterações)
        log.info("Criando nova agenda para data: {}", agendaDto.getDataAgendamento());
        try {
            Agenda agenda = agendaMapper.toEntity(agendaDto);
            Agenda savedAgenda = agendaRepository.save(agenda);
            log.info("Agenda criada com sucesso com ID: {}", savedAgenda.getId());
            return agendaMapper.toResponseDto(savedAgenda);
        } catch (Exception e) {
            log.error("Erro ao salvar nova agenda: {}", e.getMessage(), e);
            throw new RuntimeException("Falha ao criar agenda", e);
        }
    }

    @Override
    @Transactional
    public AgendaResponseDto update(Long id, AgendaRequestDto agendaDto) {
        // ... (código do método update - sem alterações)
        log.info("Atualizando agenda com ID: {}", id);
        Agenda existingAgenda = agendaRepository.findById(id)
                .orElseThrow(() -> new AgendaNotFoundException("Agenda não encontrada para atualização com ID: " + id));
        agendaMapper.updateEntityFromDto(agendaDto, existingAgenda);
        Agenda updatedAgenda = agendaRepository.save(existingAgenda);
        log.info("Agenda atualizada com sucesso com ID: {}", updatedAgenda.getId());
        return agendaMapper.toResponseDto(updatedAgenda);
    }

    @Override
    @Transactional
    public void deleteById(Long id) {
        // ... (código do método deleteById - sem alterações)
        log.info("Deletando agenda com ID: {}", id);
        if (!agendaRepository.existsById(id)) {
            throw new AgendaNotFoundException("Agenda não encontrada para exclusão com ID: " + id);
        }
        try {
            List<AgendaVeiculo> associacoes = agendaVeiculoRepository.findByAgendaId(id);
            if (!associacoes.isEmpty()) {
                agendaVeiculoRepository.deleteAllInBatch(associacoes);
                log.info("Removidas {} associações da tabela AV para Agenda ID {}.", associacoes.size(), id);
            }
            agendaRepository.deleteById(id);
            log.info("Agenda ID {} deletada com sucesso.", id);
        } catch (DataIntegrityViolationException e) {
            log.error("Erro de integridade ao deletar agenda ID {}: Verifique outras dependências.", id, e);
            throw new RuntimeException("Não é possível deletar a agenda pois ela está associada a outros registros.", e);
        } catch (Exception e) {
            log.error("Erro ao deletar agenda com ID {}: {}", id, e.getMessage(), e);
            throw new RuntimeException("Falha ao deletar agenda com ID: " + id, e);
        }
    }

    @Override
    @Transactional
    public void associarVeiculo(Long agendaId, Long veiculoId) { // Chave de abertura do método
        // ... (código do método associarVeiculo - sem alterações)
        log.info("Associando veículo ID {} à agenda ID {}", veiculoId, agendaId);
        Agenda agenda = agendaRepository.findById(agendaId)
                .orElseThrow(() -> new AgendaNotFoundException("Agenda não encontrada com ID: " + agendaId));
        Veiculo veiculo = veiculoRepository.findById(veiculoId)
                .orElseThrow(() -> new VeiculoNotFoundException("Veículo não encontrado com ID: " + veiculoId));
        if (agendaVeiculoRepository.existsByAgendaIdAndVeiculoId(agendaId, veiculoId)) {
            log.warn("Associação entre Agenda ID {} e Veículo ID {} já existe.", agendaId, veiculoId);
            return;
        }
        AgendaVeiculo novaAssociacao = new AgendaVeiculo();
        novaAssociacao.setAgenda(agenda);
        novaAssociacao.setVeiculo(veiculo);
        try {
            agendaVeiculoRepository.save(novaAssociacao);
            log.info("Veículo ID {} associado à Agenda ID {} com sucesso.", veiculoId, agendaId);
        } catch (Exception e) {
            log.error("Erro ao salvar associação entre Agenda {} e Veículo {}: {}", agendaId, veiculoId, e.getMessage(), e);
            throw new RuntimeException("Falha ao associar veículo à agenda.", e);
        }
    } // Chave de fechamento do método associarVeiculo

    @Override
    @Transactional
    public void desassociarVeiculo(Long agendaId, Long veiculoId) { // Chave de abertura do método
        // ... (código do método desassociarVeiculo - sem alterações)
        log.info("Desassociando veículo ID {} da agenda ID {}", veiculoId, agendaId);
        AgendaVeiculo associacao = agendaVeiculoRepository.findByAgendaIdAndVeiculoId(agendaId, veiculoId)
                .orElseThrow(() -> new AssociacaoNotFoundException( // Ou AgendaNotFoundException
                        String.format("Associação entre Agenda ID %d e Veículo ID %d não encontrada.", agendaId, veiculoId))
                );
        try {
            agendaVeiculoRepository.delete(associacao);
            log.info("Veículo ID {} desassociado da Agenda ID {} com sucesso.", veiculoId, agendaId);
        } catch (Exception e) {
            log.error("Erro ao deletar associação entre Agenda {} e Veículo {}: {}", agendaId, veiculoId, e.getMessage(), e);
            throw new RuntimeException("Falha ao desassociar veículo da agenda.", e);
        }
    } // Chave de fechamento do método desassociarVeiculo

    @Override
    @Transactional(readOnly = true)
    public List<VeiculoResponseDto> findVeiculosByAgendaId(Long agendaId) { // Chave de abertura do método
        // ... (código do método findVeiculosByAgendaId - sem alterações)
        log.info("Buscando veículos para agenda ID {}", agendaId);
        if (!agendaRepository.existsById(agendaId)) {
            throw new AgendaNotFoundException("Agenda não encontrada com ID: " + agendaId);
        }
        List<AgendaVeiculo> associacoes = agendaVeiculoRepository.findByAgendaId(agendaId);
        if (associacoes.isEmpty()) {
            log.info("Nenhum veículo associado à Agenda ID {}.", agendaId);
            return Collections.emptyList();
        }
        List<Veiculo> veiculos = associacoes.stream()
                .map(AgendaVeiculo::getVeiculo)
                .collect(Collectors.toList());
        log.info("Retornando {} veículos para a agenda {}", veiculos.size(), agendaId);
        return veiculos.stream()
                .map(veiculoMapper::toResponseDto)
                .collect(Collectors.toList());
    } // Chave de fechamento do método findVeiculosByAgendaId

} // <<<===== CERTIFIQUE-SE DE QUE ESTA CHAVE FINAL EXISTE NO SEU ARQUIVO!

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\service\cep\CepService.java   |   package br.com.fiap.service.cep   |   class CepService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.service.cep;

import br.com.fiap.model.Endereco;
import org.slf4j.Logger; // Usar SLF4J para logging (padrão Spring)
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired; // Para injeção
import org.springframework.stereotype.Service; // Marca como um Service Bean
import org.springframework.web.client.HttpClientErrorException; // Exceção do RestTemplate
import org.springframework.web.client.RestTemplate; // Cliente HTTP do Spring

@Service // 1. Marca esta classe como um Bean de Serviço do Spring
public class CepService {

    private static final Logger log = LoggerFactory.getLogger(CepService.class);
    private static final String VIACEP_URL = "https://viacep.com.br/ws/{cep}/json/"; // Usa placeholder {cep}

    // 2. Injeta o Bean RestTemplate que configuramos anteriormente
    private final RestTemplate restTemplate;

    @Autowired
    public CepService(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    /**
     * Busca um endereço na API ViaCEP dado um CEP.
     *
     * @param cep O CEP a ser buscado (apenas números).
     * @return Um objeto Endereco preenchido ou null se não encontrado ou erro.
     */
    public Endereco buscarEnderecoPorCep(String cep) {
        // Remove caracteres não numéricos do CEP, se houver
        String cepNumerico = cep != null ? cep.replaceAll("[^0-9]", "") : "";
        if (cepNumerico.length() != 8) {
            log.warn("CEP inválido fornecido: {}", cep);
            return null; // Retorna null ou lança exceção de CEP inválido
        }

        log.info("Buscando endereço para o CEP: {}", cepNumerico);
        try {
            // 3. Usa restTemplate.getForObject para fazer a chamada GET
            // O Spring (com Jackson) automaticamente converte o JSON de resposta para o objeto Endereco
            Endereco endereco = restTemplate.getForObject(VIACEP_URL, Endereco.class, cepNumerico);

            // ViaCEP retorna um objeto com campos nulos se o CEP não existe,
            // mas às vezes retorna um {"erro": true}. A verificação do logradouro é uma forma.
            if (endereco != null && endereco.getLogradouro() != null) {
                log.info("Endereço encontrado para CEP {}: {}", cepNumerico, endereco.getLogradouro());
                // Importante: Como este Endereco veio da API, ele NÃO tem um ID do seu banco.
                // Ele precisará ser salvo (persistido) separadamente se for um novo endereço.
                endereco.setCodigo(null); // Garante que não tem ID ao vir da API externa
                return endereco;
            } else {
                log.warn("CEP {} não encontrado na base do ViaCEP.", cepNumerico);
                return null;
            }
        } catch (HttpClientErrorException e) {
            // Erros como 404, 400 etc.
            log.error("Erro HTTP ao buscar CEP {}: {} - {}", cepNumerico, e.getStatusCode(), e.getResponseBodyAsString());
            return null;
        } catch (Exception e) {
            // Outros erros (rede, parsing, etc.)
            log.error("Erro inesperado ao buscar CEP {}: {}", cepNumerico, e.getMessage());
            return null;
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\service\clientes\ClienteService.java   |   package br.com.fiap.service.clientes   |   class ClienteService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.service.clientes;

// ... outros imports ...
import br.com.fiap.dto.cliente.ClienteRequestDto;
import br.com.fiap.dto.cliente.ClienteResponseDto;
import br.com.fiap.dto.veiculo.VeiculoResponseDto; // <<< IMPORTAR DTO DO VEÍCULO
import br.com.fiap.model.relacionamentos.ClienteId;
import br.com.fiap.dto.cliente.ClienteInfoDTO;
import java.util.List;

public interface ClienteService {
    List<ClienteResponseDto> findAll();
    ClienteResponseDto findById(ClienteId id);

    // <<< NOVA ASSINATURA ADICIONADA/MODIFICADA >>>
    ClienteResponseDto create(ClienteRequestDto clienteDto, Long autenticarId); // Adicionado o parâmetro autenticarId

    ClienteResponseDto update(ClienteId id, ClienteRequestDto clienteDto);
    void deleteById(ClienteId id);
    List<ClienteInfoDTO> buscarClientes(String nome, String documento, Long idCliente);
    List<VeiculoResponseDto> findVeiculosByClienteId(ClienteId clienteId);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\service\clientes\ClienteServiceImpl.java   |   package br.com.fiap.service.clientes   |   class ClienteServiceImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.service.clientes
package br.com.fiap.service.clientes;

import br.com.fiap.dto.cliente.ClienteInfoDTO;
import br.com.fiap.dto.cliente.ClienteRequestDto;
import br.com.fiap.dto.cliente.ClienteResponseDto;
import br.com.fiap.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.exception.ClientesNotFoundException;
import br.com.fiap.exception.AutenticarNotFoundException; // Importe esta exceção
import br.com.fiap.mapper.ClienteMapper;
import br.com.fiap.mapper.ContatoMapper;
import br.com.fiap.mapper.EnderecoMapper;
import br.com.fiap.mapper.VeiculoMapper;
import br.com.fiap.model.Clientes;
import br.com.fiap.model.Contato;
import br.com.fiap.model.Endereco;
import br.com.fiap.model.autenticar.Autenticar; // Importe a entidade Autenticar
// Remova o import de Veiculo se não for usado diretamente aqui
// import br.com.fiap.model.Veiculo;
import br.com.fiap.model.relacionamentos.ClienteId;
import br.com.fiap.model.relacionamentos.ClienteVeiculo;
import br.com.fiap.repository.AutenticarRepository; // Mantenha se usar Autenticar
import br.com.fiap.repository.ClientesRepository;
import br.com.fiap.repository.ContatoRepository;
import br.com.fiap.repository.EnderecoRepository;
import br.com.fiap.repository.relacionamentos.ClienteVeiculoRepository;
import br.com.fiap.repository.specification.ClienteSpecification;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class ClienteServiceImpl implements ClienteService {

    private static final Logger log = LoggerFactory.getLogger(ClienteServiceImpl.class);

    // Campos marcados como 'final' - boa prática com injeção via construtor
    private final ClientesRepository clienteRepository;
    private final EnderecoRepository enderecoRepository;
    private final ContatoRepository contatoRepository;
    private final AutenticarRepository autenticarRepository; // Mantenha se usar Autenticar
    private final ClienteMapper clienteMapper;
    private final EnderecoMapper enderecoMapper;
    private final ContatoMapper contatoMapper;
    private final ClienteVeiculoRepository clienteVeiculoRepository;
    private final VeiculoMapper veiculoMapper;

    @Autowired
    public ClienteServiceImpl(ClientesRepository clientesRepository, EnderecoRepository enderecoRepository,
                              ContatoRepository contatoRepository, AutenticarRepository autenticarRepository,
                              ClienteMapper clienteMapper, EnderecoMapper enderecoMapper, ContatoMapper contatoMapper,
                              ClienteVeiculoRepository clienteVeiculoRepository,
                              VeiculoMapper veiculoMapper) {
        // Certifique-se que TODAS as atribuições estão aqui e corretas
        this.clienteRepository = clientesRepository;
        this.enderecoRepository = enderecoRepository;
        this.contatoRepository = contatoRepository;
        this.autenticarRepository = autenticarRepository;
        this.clienteMapper = clienteMapper;
        this.enderecoMapper = enderecoMapper;
        this.contatoMapper = contatoMapper;
        this.clienteVeiculoRepository = clienteVeiculoRepository;
        this.veiculoMapper = veiculoMapper;
        // Não precisamos injetar PasswordEncoder aqui para a lógica de vincular Autenticar
    }

    @Override
    @Transactional(readOnly = true)
    public List<ClienteResponseDto> findAll() {
        log.info("Buscando todos os clientes");
        List<Clientes> clientes = clienteRepository.findAll();
        return clientes.stream()
                .map(clienteMapper::toResponseDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public ClienteResponseDto findById(ClienteId id) {
        log.info("Buscando cliente por ID: {}", id);
        // Chama o método auxiliar privado
        Clientes cliente = findClienteByIdOrElseThrow(id);
        return clienteMapper.toResponseDto(cliente);
    }

    // --- Método CREATE Modificado para receber autenticarId ---
    // IMPORTANTE: Você precisará atualizar a interface ClienteService para incluir esta assinatura de método
    @Override
    @Transactional
    public ClienteResponseDto create(ClienteRequestDto clienteDto, Long autenticarId) {
        log.info("Criando novo cliente: {} (possivelmente associado a autenticarId: {})", clienteDto.getNome(), autenticarId);
        try {
            // Salvar Endereço
            Endereco enderecoEntity = enderecoMapper.toEntity(clienteDto.getEndereco());
            Endereco savedEndereco = enderecoRepository.save(enderecoEntity);
            log.info("Endereço criado/salvo com ID: {}", savedEndereco.getCodigo());

            // Salvar Contato
            Contato contatoEntity = contatoMapper.toEntity(clienteDto.getContato());
            Contato savedContato = contatoRepository.save(contatoEntity);
            log.info("Contato criado/salvo com ID: {}", savedContato.getCodigo());

            // --- Lógica para Associar com Autenticar Existente ---
            Autenticar autenticarEntity = null;
            if (autenticarId != null) {
                log.debug("Buscando entidade Autenticar com ID: {}", autenticarId);
                autenticarEntity = autenticarRepository.findById(autenticarId)
                        .orElseThrow(() -> new AutenticarNotFoundException("Credencial de autenticação não encontrada com ID: " + autenticarId));
                log.info("Credencial de autenticação ID {} encontrada.", autenticarId);
            }
            // ==================================================


            // Mapear Cliente e Associar Endereço, Contato e Autenticar
            Clientes clienteEntity = clienteMapper.toEntity(clienteDto);
            clienteEntity.setEndereco(savedEndereco);
            clienteEntity.setContato(savedContato);
            clienteEntity.setAutenticar(autenticarEntity); // Associa a entidade Autenticar (será null se autenticarId for null)

            // Inicializar ID composto se necessário (@MapsId cuida do enderecoId)
            if (clienteEntity.getId() == null) {
                clienteEntity.setId(new ClienteId());
            }
            // O ID do cliente (ID_CLI) será gerado pela trigger/sequence do banco após o save

            Clientes savedCliente = clienteRepository.save(clienteEntity);
            log.info("Cliente criado com ID_CLI: {}, ID_ENDERECO: {}{}",
                    savedCliente.getId().getIdCli(),
                    savedCliente.getId().getEnderecoId(),
                    autenticarId != null ? " e associado ao Autenticar ID: " + autenticarId : "");


            return clienteMapper.toResponseDto(savedCliente);
        } catch (AutenticarNotFoundException e) {
            // Relança a exceção específica para ser tratada no Controller/GlobalExceptionHandler
            log.warn("Erro ao criar cliente: Credencial de autenticação não encontrada. {}", e.getMessage());
            throw e;
        }
        catch (Exception e) {
            log.error("Erro ao criar cliente: {}", e.getMessage(), e);
            throw new RuntimeException("Falha ao criar cliente: " + e.getMessage(), e);
        }
    }
    // --- Fim do Método CREATE Modificado ---


    @Override
    @Transactional
    public ClienteResponseDto update(ClienteId id, ClienteRequestDto clienteDto) {
        log.info("Atualizando cliente com ID: {}", id);
        // Chama o método auxiliar privado
        Clientes existingCliente = findClienteByIdOrElseThrow(id);

        // Atualiza Endereço
        if (clienteDto.getEndereco() != null && existingCliente.getEndereco() != null) {
            log.info("Atualizando endereço ID {} para cliente ID {}", existingCliente.getEndereco().getCodigo(), id);
            enderecoMapper.updateEntityFromDto(clienteDto.getEndereco(), existingCliente.getEndereco());
        } else if (clienteDto.getEndereco() != null && existingCliente.getEndereco() == null) {
            log.warn("Tentando atualizar endereço para cliente ID {}, mas o cliente não possui endereço associado. Ignorando.", id);
            // Você pode optar por criar um novo endereço aqui ou lançar um erro/aviso.
            // Por segurança, vamos ignorar por enquanto.
        }

        // Atualiza Contato
        if (clienteDto.getContato() != null && existingCliente.getContato() != null) {
            log.info("Atualizando contato ID {} para cliente ID {}", existingCliente.getContato().getCodigo(), id);
            contatoMapper.updateEntityFromDto(clienteDto.getContato(), existingCliente.getContato());
        } else if (clienteDto.getContato() != null && existingCliente.getContato() == null) {
            log.warn("Tentando atualizar contato para cliente ID {}, mas o cliente não possui contato associado. Ignorando.", id);
            // Mesma lógica do endereço. Ignorando por segurança.
        }

        // Atualiza dados do cliente (não de Autenticar via este DTO)
        clienteMapper.updateEntityFromDto(clienteDto, existingCliente);

        // Salva o cliente (JPA/Hibernate gerencia as atualizações em cascata se configurado)
        Clientes updatedCliente = clienteRepository.save(existingCliente);
        log.info("Cliente atualizado com ID: {}", updatedCliente.getId());
        return clienteMapper.toResponseDto(updatedCliente);
    }

    @Override
    @Transactional
    public void deleteById(ClienteId id) {
        log.warn("Tentando deletar cliente com ID: {}", id);
        // Chama o método auxiliar privado
        Clientes cliente = findClienteByIdOrElseThrow(id);

        // --- Lógica de verificação e remoção de dependências ---
        // É CRUCIAL remover associações em tabelas de junção ou entidades filhas
        // ANTES de tentar deletar a entidade pai (Clientes), para evitar
        // DataIntegrityViolationException.

        // Exemplo: Remover associações Cliente-Veículo (tabela CV)
        List<ClienteVeiculo> clienteVeiculos = clienteVeiculoRepository.findByCliente_Id(id);
        if (!clienteVeiculos.isEmpty()) {
            log.info("Removendo {} associações Cliente-Veículo para Cliente ID: {}", clienteVeiculos.size(), id);
            clienteVeiculoRepository.deleteAllInBatch(clienteVeiculos); // Mais eficiente para listas
            // Ou loop e delete individual: clienteVeiculos.forEach(clienteVeiculoRepository::delete);
        }

        // TODO: Adicionar lógica similar para outras tabelas de junção que referenciam CLIENTES:
        // - ClienteOrcamento (tabela CO) -> use clienteOrcamentoRepository.findByCliente_Id(id)
        // - ClientePagamento (tabela CP) -> use clientePagamentoRepository.findByCliente_Id(id)
        // Certifique-se de ter os métodos findByCliente_Id(...) nos respectivos repositórios de relacionamento.

        // TODO: Decidir o que fazer com Endereco e Contato associados.
        // Eles se tornam "órfãos" se o Cliente for deletado e não houver outros Clientes
        // usando o mesmo Endereco/Contato. A exclusão em cascata no relacionamento
        // @ManyToOne ou @OneToOne pode ser perigosa se outras entidades referenciam
        // o mesmo Endereco/Contato. A abordagem atual (não deletar automaticamente)
        // é mais segura, mas pode deixar dados não utilizados no BD.
        // Se Endereco/Contato só existem por causa deste Cliente, considere deletar
        // manualmente AQUI ou configurar CascadeType.ALL/REMOVE no relacionamento
        // E usar orphanRemoval = true SE TIVER CERTEZA que só este Cliente referencia.

        // TODO: Decidir o que fazer com o registro em AUTENTICAR associado.
        // Se o usuário de autenticação só serve para este cliente, você pode querer
        // deletar o registro em AUTENTICAR. Mas se o mesmo usuário puder ser
        // associado a múltiplos Clientes (menos comum, mas possível), ou se
        // você quiser manter o histórico de logins, NÃO delete o registro em AUTENTICAR.
        // Se for para deletar:
        // if (cliente.getAutenticar() != null) {
        //     log.info("Removendo registro de autenticação associado (ID: {})", cliente.getAutenticar().getId());
        //     autenticarRepository.delete(cliente.getAutenticar());
        // }

        // --- Fim da lógica de verificação/remoção de dependências ---


        try {
            // Agora, e somente agora, delete o cliente
            clienteRepository.delete(cliente);
            log.info("Cliente ID {} deletado com sucesso.", id);
        } catch (DataIntegrityViolationException e) {
            log.error("Erro de integridade ao deletar cliente ID {}: {}", id, e.getMessage());
            // Relança com uma mensagem mais amigável indicando o problema de dependência
            throw new RuntimeException("Não é possível excluir o cliente pois ele possui registros associados (veículos, orçamentos, pagamentos etc.). Verifique e remova as associações primeiro.", e);
        } catch (Exception e) {
            log.error("Erro inesperado ao deletar cliente ID {}: {}", id, e.getMessage(), e);
            throw new RuntimeException("Falha ao deletar cliente.", e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public List<ClienteInfoDTO> buscarClientes(String nome, String documento, Long idCliente) {
        log.info("Buscando clientes com critérios: nome='{}', documento='{}', idCliente={}", nome, documento, idCliente);
        Specification<Clientes> spec = Specification.where(null);

        if (nome != null && !nome.isBlank()) spec = spec.and(ClienteSpecification.nomeContains(nome));
        if (documento != null && !documento.isBlank()) spec = spec.and(ClienteSpecification.numeroDocumentoEquals(documento));
        if (idCliente != null && idCliente > 0) spec = spec.and(ClienteSpecification.idCliEquals(idCliente));

        if ((nome == null || nome.isBlank()) && (documento == null || documento.isBlank()) && (idCliente == null || idCliente <= 0)) {
            log.warn("Busca de clientes chamada sem critérios válidos.");
            return List.of();
        }

        List<Clientes> clientesEncontrados = clienteRepository.findAll(spec);
        log.info("Encontrados {} clientes para os critérios.", clientesEncontrados.size());

        return clientesEncontrados.stream()
                .map(cliente -> new ClienteInfoDTO(
                        cliente.getId().getIdCli(),
                        cliente.getEndereco().getCodigo(), // Pega o ID do objeto Endereco associado
                        cliente.getNome(),
                        cliente.getSobrenome(),
                        cliente.getNumeroDocumento()
                ))
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<VeiculoResponseDto> findVeiculosByClienteId(ClienteId clienteId) {
        log.info("Buscando veículos para o cliente ID: {}", clienteId);
        // Chama o método auxiliar privado
        if (!clienteRepository.existsById(clienteId)) {
            throw new ClientesNotFoundException("Cliente não encontrado com ID: " + clienteId + " ao buscar veículos.");
        }

        List<ClienteVeiculo> associacoes = clienteVeiculoRepository.findByCliente_Id(clienteId);
        if (associacoes.isEmpty()) {
            log.info("Nenhum veículo encontrado para o cliente ID: {}", clienteId);
            return Collections.emptyList();
        }

        List<VeiculoResponseDto> veiculosDto = associacoes.stream()
                .map(ClienteVeiculo::getVeiculo)
                .map(veiculoMapper::toResponseDto)
                .collect(Collectors.toList());

        log.info("Encontrados {} veículos para o cliente ID: {}", veiculosDto.size(), clienteId);
        return veiculosDto;
    }

    // --- MÉTODO AUXILIAR PRIVADO ---
    // Garante que está DENTRO da classe ClienteServiceImpl
    private Clientes findClienteByIdOrElseThrow(ClienteId id) {
        if (id == null || id.getIdCli() == null || id.getEnderecoId() == null) {
            throw new IllegalArgumentException("ID do Cliente (composto) não pode ser nulo ou incompleto.");
        }
        // Busca pelo ID composto ou lança ClientesNotFoundException
        return clienteRepository.findById(id)
                .orElseThrow(() -> new ClientesNotFoundException("Cliente não encontrado com ID: " + id));
    }
    // --- FIM DO MÉTODO AUXILIAR ---

} // <<< FIM DA CLASSE ClienteServiceImpl

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\service\ia\GoogleGeminiService.java   |   package br.com.fiap.service.ia   |   class GoogleGeminiService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// ===========================================================================
// 1. Interface (Arquivo: src/main/java/br/com/fiap/service/ia/GoogleGeminiService.java)
// ===========================================================================
package br.com.fiap.service.ia;

/**
 * Interface definindo o contrato para serviços que geram diagnósticos via API Google Gemini.
 */
public interface GoogleGeminiService { // <<< Interface Renomeada

    /**
     * Gera um diagnóstico sugerido com base na descrição do problema.
     * @param descricaoProblema A descrição fornecida pelo usuário.
     * @return Uma string com o diagnóstico sugerido pela IA, ou uma mensagem de erro/padrão.
     */
    String gerarDiagnostico(String descricaoProblema);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\service\ia\GoogleGeminiServiceImpl.java   |   package br.com.fiap.service.ia   |   class GoogleGeminiServiceImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.service.ia;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.ai.chat.client.ChatClient; // Importar ChatClient
import org.springframework.ai.chat.model.ChatResponse; // Para pegar a resposta
import org.springframework.ai.chat.prompt.Prompt;     // Para criar o prompt
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class GoogleGeminiServiceImpl implements GoogleGeminiService {

    private static final Logger log = LoggerFactory.getLogger(GoogleGeminiServiceImpl.class);
    private final ChatClient chatClient;

    @Autowired
    public GoogleGeminiServiceImpl(ChatClient.Builder chatClientBuilder) {
        this.chatClient = chatClientBuilder.build();
        log.info("ChatClient do Spring AI (Vertex AI/Gemini) inicializado.");
    }

    @Override
    public String gerarDiagnostico(String descricaoProblema) {
        log.info("Chamando IA (Vertex AI/Gemini) via Spring AI ChatClient para: '{}'", descricaoProblema);

        String promptTexto = String.format(
                "Aja como um mecânico experiente. Gere um possível diagnóstico técnico conciso (max 1-2 frases), liste as prováveis partes afetadas (max 3-4 itens em lista simples) e estime um número de horas de trabalho (apenas o número, ex: '2.5') para um veículo com o seguinte problema descrito pelo cliente: \"%s\"",
                descricaoProblema
        );

        try {
            Prompt prompt = new Prompt(promptTexto);
            ChatResponse response = chatClient.prompt(prompt).call().chatResponse();

            // --- CORREÇÃO APLICADA AQUI ---
            // Pega o conteúdo da resposta usando getText()
            String diagnosticoGerado = response.getResult().getOutput().getText();
            // -----------------------------

            if (diagnosticoGerado == null || diagnosticoGerado.isBlank()) {
                log.warn("Resposta da IA via Spring AI veio vazia ou nula.");
                return "Não foi possível gerar um diagnóstico (resposta vazia da IA).";
            }

            log.info("Diagnóstico Spring AI recebido com sucesso.");
            // Limita tamanho
            return diagnosticoGerado.substring(0, Math.min(diagnosticoGerado.length(), 4000));

        } catch (Exception e) {
            log.error("Erro ao chamar IA via Spring AI: {}", e.getMessage(), e);
            return "Erro ao se comunicar com o serviço de IA.";
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\service\oficina\OficinaService.java   |   package br.com.fiap.service.oficina   |   class OficinaService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.service.oficina
package br.com.fiap.service.oficina;

import br.com.fiap.dto.oficina.OficinaRequestDto;
import br.com.fiap.dto.oficina.OficinaResponseDto;
import br.com.fiap.dto.oficina.ItemPecaServicoDto;
import br.com.fiap.dto.oficina.ServicoHistoricoResponseDto; // <<< IMPORTAR NOVO DTO
import br.com.fiap.model.Oficina;
import java.util.List;

public interface OficinaService {
    List<OficinaResponseDto> findAll();
    OficinaResponseDto findById(Long id);
    OficinaResponseDto create(OficinaRequestDto oficinaDto);
    OficinaResponseDto update(Long id, OficinaRequestDto oficinaDto);
    void deleteById(Long id);
    Oficina salvarOficinaComPecas(Oficina oficinaParcialmenteMapeada, List<ItemPecaServicoDto> pecasDto);
    Oficina atualizarOficinaComPecas(Long oficinaId, Oficina oficinaParcialmenteMapeada, List<ItemPecaServicoDto> pecasDto);

    // <<< NOVA ASSINATURA ADICIONADA >>>
    List<ServicoHistoricoResponseDto> findServicosByVeiculoId(Long veiculoId);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\service\oficina\OficinaServiceImpl.java   |   package br.com.fiap.service.oficina   |   class OficinaServiceImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.service.oficina
package br.com.fiap.service.oficina;

import br.com.fiap.dto.oficina.OficinaRequestDto;
import br.com.fiap.dto.oficina.OficinaResponseDto;
import br.com.fiap.dto.oficina.ItemPecaServicoDto;
import br.com.fiap.dto.oficina.ServicoHistoricoResponseDto;
import br.com.fiap.exception.OficinaNotFoundException;
import br.com.fiap.exception.PecasNotFoundException;
import br.com.fiap.exception.VeiculoNotFoundException;
import br.com.fiap.mapper.OficinaMapper;
import br.com.fiap.model.Oficina;
import br.com.fiap.model.Pecas;
import br.com.fiap.model.relacionamentos.OficinaPeca;
import br.com.fiap.model.relacionamentos.OficinaVeiculo;
import br.com.fiap.repository.OficinaRepository;
import br.com.fiap.repository.PecasRepository;
import br.com.fiap.repository.VeiculoRepository;
import br.com.fiap.repository.relacionamentos.OficinaPecaRepository;
import br.com.fiap.repository.relacionamentos.OficinaVeiculoRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class OficinaServiceImpl implements OficinaService {

    private static final Logger log = LoggerFactory.getLogger(OficinaServiceImpl.class);

    // Marcar campos como final é boa prática com injeção via construtor
    private final OficinaRepository oficinaRepository;
    private final OficinaMapper oficinaMapper;
    private final PecasRepository pecasRepository;
    private final OficinaPecaRepository oficinaPecaRepository;
    private final VeiculoRepository veiculoRepository;
    private final OficinaVeiculoRepository oficinaVeiculoRepository;

    @Autowired
    public OficinaServiceImpl(OficinaRepository oficinaRepository,
                              OficinaMapper oficinaMapper,
                              PecasRepository pecasRepository,
                              OficinaPecaRepository oficinaPecaRepository,
                              VeiculoRepository veiculoRepository,
                              OficinaVeiculoRepository oficinaVeiculoRepository) {
        this.oficinaRepository = oficinaRepository;
        this.oficinaMapper = oficinaMapper;
        this.pecasRepository = pecasRepository;
        this.oficinaPecaRepository = oficinaPecaRepository;
        this.veiculoRepository = veiculoRepository;
        this.oficinaVeiculoRepository = oficinaVeiculoRepository;
    }

    // --- Implementação dos Métodos CRUD Simples ---
    @Override
    @Transactional(readOnly = true)
    public List<OficinaResponseDto> findAll() {
        log.info("Buscando todos os registros de oficina");
        return oficinaRepository.findAll().stream()
                .map(oficinaMapper::toResponseDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public OficinaResponseDto findById(Long id) {
        log.info("Buscando registro de oficina por ID: {}", id);
        Oficina oficina = findOficinaByIdOrElseThrow(id);
        return oficinaMapper.toResponseDto(oficina);
    }

    @Override
    @Transactional
    public OficinaResponseDto create(OficinaRequestDto oficinaDto) {
        log.info("Criando novo registro de oficina (via DTO simples)");
        try {
            Oficina oficina = oficinaMapper.toEntity(oficinaDto);
            // Aqui não há associação de peças, pois vem do DTO simples
            Oficina savedOficina = oficinaRepository.save(oficina);
            log.info("Registro de oficina criado com ID: {}", savedOficina.getId());
            return oficinaMapper.toResponseDto(savedOficina);
        } catch (Exception e) {
            log.error("Erro ao criar registro de oficina: {}", e.getMessage(), e);
            throw new RuntimeException("Falha ao criar registro de oficina", e);
        }
    }

    @Override
    @Transactional
    public OficinaResponseDto update(Long id, OficinaRequestDto oficinaDto) {
        log.info("Atualizando registro de oficina ID: {} (via DTO simples)", id);
        Oficina existingOficina = findOficinaByIdOrElseThrow(id);
        // Este mapper só atualiza os campos presentes no OficinaRequestDto
        oficinaMapper.updateEntityFromDto(oficinaDto, existingOficina);
        // Associações existentes (peças, veículos, etc.) não são alteradas aqui
        Oficina updatedOficina = oficinaRepository.save(existingOficina);
        log.info("Registro de oficina atualizado com ID: {}", updatedOficina.getId());
        return oficinaMapper.toResponseDto(updatedOficina);
    }

    @Override
    @Transactional
    public void deleteById(Long id) {
        log.warn("Tentando deletar registro de oficina ID: {}", id);
        Oficina oficina = findOficinaByIdOrElseThrow(id);
        try {
            // IMPORTANTE: Remover associações ANTES de deletar a oficina
            // para evitar erros de chave estrangeira.

            // Exemplo: Remover associações Oficina-Peça (OFP)
            if (oficina.getOficinaPecas() != null && !oficina.getOficinaPecas().isEmpty()) {
                log.info("Removendo {} associações Oficina-Peça para Oficina ID: {}", oficina.getOficinaPecas().size(), id);
                oficinaPecaRepository.deleteAllInBatch(oficina.getOficinaPecas()); // Mais eficiente
                oficina.getOficinaPecas().clear(); // Limpa a coleção na entidade gerenciada
            }
            // Exemplo: Remover associações Oficina-Veiculo (OV)
            if (oficina.getOficinaVeiculos() != null && !oficina.getOficinaVeiculos().isEmpty()) {
                log.info("Removendo {} associações Oficina-Veículo para Oficina ID: {}", oficina.getOficinaVeiculos().size(), id);
                oficinaVeiculoRepository.deleteAllInBatch(oficina.getOficinaVeiculos());
                oficina.getOficinaVeiculos().clear();
            }
            // Adicionar remoção para OficinaOrcamento (OFO) e AgendaOficina (AO) se necessário

            // Agora deleta a oficina
            oficinaRepository.delete(oficina);
            log.info("Registro de oficina deletado com ID: {}", id);
        } catch (DataIntegrityViolationException e) {
            log.error("Erro de integridade ao deletar oficina ID {}: {}", id, e.getMessage());
            throw new RuntimeException("Não é possível excluir o registro de oficina pois ele possui outras associações (orçamentos, agendamentos?). Verifique e remova as dependências.", e);
        } catch (Exception e) {
            log.error("Erro inesperado ao deletar oficina ID {}: {}", id, e.getMessage(), e);
            throw new RuntimeException("Falha ao deletar registro de oficina.", e);
        }
    }

    // --- Implementação dos Métodos para Salvar/Atualizar com Peças ---

    @Override
    @Transactional
    public Oficina salvarOficinaComPecas(Oficina oficinaEntidade, List<ItemPecaServicoDto> pecasDto) {
        log.info("Salvando novo registro de Oficina e associando peças.");
        // Garante que a lista de peças na entidade não é nula
        if (oficinaEntidade.getOficinaPecas() == null) {
            oficinaEntidade.setOficinaPecas(new ArrayList<>());
        }
        // Salva a Oficina primeiro para obter o ID, se for nova
        Oficina oficinaSalva = oficinaRepository.save(oficinaEntidade);
        log.debug("Oficina salva com ID: {}", oficinaSalva.getId());

        // Limpa associações antigas (se houver alguma por engano) antes de adicionar novas
        // Isso é mais relevante no 'atualizar', mas por segurança pode ficar aqui também.
        if (!oficinaSalva.getOficinaPecas().isEmpty()) {
            log.warn("Limpando {} associações de peças pré-existentes inesperadas para a nova Oficina ID {}", oficinaSalva.getOficinaPecas().size(), oficinaSalva.getId());
            oficinaPecaRepository.deleteAllInBatch(oficinaSalva.getOficinaPecas());
            oficinaSalva.getOficinaPecas().clear();
        }

        // Processa e salva as novas peças
        if (pecasDto != null && !pecasDto.isEmpty()) {
            log.debug("Processando {} peças para Oficina ID {}", pecasDto.size(), oficinaSalva.getId());
            for (ItemPecaServicoDto itemPecaDto : pecasDto) {
                Pecas peca = pecasRepository.findById(itemPecaDto.getPecaId())
                        .orElseThrow(() -> new PecasNotFoundException("Peça não encontrada com ID: " + itemPecaDto.getPecaId() + " ao salvar Oficina ID " + oficinaSalva.getId()));

                OficinaPeca oficinaPeca = new OficinaPeca();
                oficinaPeca.setOficina(oficinaSalva);
                oficinaPeca.setPeca(peca);
                oficinaPeca.setQuantidade(itemPecaDto.getQuantidade());

                // Salva a entidade de junção e adiciona à coleção gerenciada
                oficinaSalva.getOficinaPecas().add(oficinaPecaRepository.save(oficinaPeca));
                log.trace("Associada Peça ID {} (Qtd: {}) à Oficina ID {}", itemPecaDto.getPecaId(), itemPecaDto.getQuantidade(), oficinaSalva.getId());
            }
        }
        // O save final não é estritamente necessário por causa do contexto transacional,
        // mas pode ser útil para garantir que o objeto retornado esteja totalmente atualizado.
        // return oficinaRepository.save(oficinaSalva); // Ou só oficinaSalva
        return oficinaSalva;
    }

    // --- IMPLEMENTAÇÃO DO MÉTODO QUE FALTAVA ---
    @Override
    @Transactional
    public Oficina atualizarOficinaComPecas(Long oficinaId, Oficina oficinaParcialmenteMapeada, List<ItemPecaServicoDto> pecasDto) {
        log.info("Atualizando Oficina ID {} e associando/atualizando peças.", oficinaId);
        Oficina oficinaExistente = findOficinaByIdOrElseThrow(oficinaId);

        // Atualiza campos simples da Oficina vindos do DTO mapeado
        oficinaExistente.setDataOficina(oficinaParcialmenteMapeada.getDataOficina());
        oficinaExistente.setDescricaoProblema(oficinaParcialmenteMapeada.getDescricaoProblema());
        oficinaExistente.setDiagnostico(oficinaParcialmenteMapeada.getDiagnostico());
        oficinaExistente.setPartesAfetadas(oficinaParcialmenteMapeada.getPartesAfetadas());
        oficinaExistente.setHorasTrabalhadas(oficinaParcialmenteMapeada.getHorasTrabalhadas());
        // Adicione outros campos se o 'oficinaParcialmenteMapeada' os contiver

        // Gerencia as peças: remove antigas, adiciona novas.
        // Abordagem: Limpa todas as existentes e recria com base no DTO atual.
        log.debug("Removendo associações de peças antigas para Oficina ID {}", oficinaId);
        if (oficinaExistente.getOficinaPecas() != null && !oficinaExistente.getOficinaPecas().isEmpty()) {
            oficinaPecaRepository.deleteAllInBatch(oficinaExistente.getOficinaPecas());
            oficinaExistente.getOficinaPecas().clear();
        } else {
            // Garante que a lista existe para adicionar novos itens
            oficinaExistente.setOficinaPecas(new ArrayList<>());
        }

        // Adiciona as peças do DTO atualizado
        if (pecasDto != null && !pecasDto.isEmpty()) {
            log.debug("Adicionando/Atualizando {} peças para Oficina ID {}", pecasDto.size(), oficinaId);
            for (ItemPecaServicoDto itemPecaDto : pecasDto) {
                Pecas peca = pecasRepository.findById(itemPecaDto.getPecaId())
                        .orElseThrow(() -> new PecasNotFoundException("Peça não encontrada com ID: " + itemPecaDto.getPecaId() + " ao atualizar Oficina ID " + oficinaId));

                OficinaPeca novaOficinaPeca = new OficinaPeca();
                novaOficinaPeca.setOficina(oficinaExistente);
                novaOficinaPeca.setPeca(peca);
                novaOficinaPeca.setQuantidade(itemPecaDto.getQuantidade());

                // Adiciona à coleção gerenciada (o save ocorrerá em cascata ou ao final)
                oficinaExistente.getOficinaPecas().add(novaOficinaPeca);
                log.trace("Associada Peça ID {} (Qtd: {}) à Oficina ID {}", itemPecaDto.getPecaId(), itemPecaDto.getQuantidade(), oficinaId);
            }
        }

        // Salva a entidade Oficina. O JPA/Hibernate gerencia o save/update das OficinaPeca
        // adicionadas à coleção, devido ao CascadeType (assumindo CascadeType.ALL ou MERGE/PERSIST no relacionamento).
        return oficinaRepository.save(oficinaExistente);
    }
    // --- FIM DO MÉTODO QUE FALTAVA ---


    // --- Implementação do Histórico de Serviços ---
    @Override
    @Transactional(readOnly = true)
    public List<ServicoHistoricoResponseDto> findServicosByVeiculoId(Long veiculoId) {
        log.info("Buscando histórico de serviços para o veículo ID: {}", veiculoId);
        if (!veiculoRepository.existsById(veiculoId)) {
            throw new VeiculoNotFoundException("Veículo não encontrado com ID: " + veiculoId + " ao buscar histórico.");
        }

        List<OficinaVeiculo> associacoes = oficinaVeiculoRepository.findByVeiculoId(veiculoId);
        if (associacoes.isEmpty()) {
            log.info("Nenhum serviço encontrado para o veículo ID: {}", veiculoId);
            return Collections.emptyList();
        }

        List<ServicoHistoricoResponseDto> historico = associacoes.stream()
                .map(OficinaVeiculo::getOficina)
                .map(oficina -> {
                    List<OficinaPeca> pecasDoServico = oficinaPecaRepository.findByOficinaId(oficina.getId());
                    List<ItemPecaServicoDto> pecasDto = pecasDoServico.stream()
                            .map(oficinaPeca -> new ItemPecaServicoDto(
                                    oficinaPeca.getPeca().getId(),
                                    oficinaPeca.getPeca().getDescricao(),
                                    oficinaPeca.getPeca().getFabricante(),
                                    oficinaPeca.getQuantidade()
                            ))
                            .collect(Collectors.toList());

                    return new ServicoHistoricoResponseDto(
                            oficina.getId(),
                            oficina.getDataOficina(),
                            oficina.getDescricaoProblema(),
                            oficina.getDiagnostico(),
                            oficina.getPartesAfetadas(),
                            oficina.getHorasTrabalhadas(),
                            pecasDto
                    );
                })
                // Ordena pelo mais recente ANTES de coletar
                .sorted((s1, s2) -> {
                    if (s1.getDataOficina() == null && s2.getDataOficina() == null) return 0;
                    if (s1.getDataOficina() == null) return 1; // Nulos por último
                    if (s2.getDataOficina() == null) return -1; // Nulos por último
                    return s2.getDataOficina().compareTo(s1.getDataOficina()); // DESC
                })
                .collect(Collectors.toList());

        log.info("Encontrados {} registros de serviço para o veículo ID: {}", historico.size(), veiculoId);
        return historico;
    }
    // --- Fim do Histórico ---

    // --- Método Auxiliar Privado ---
    private Oficina findOficinaByIdOrElseThrow(Long id) {
        return oficinaRepository.findById(id)
                .orElseThrow(() -> new OficinaNotFoundException("Registro de Oficina não encontrado com ID: " + id));
    }
    // --- Fim do Método Auxiliar ---

} // <<< FIM DA CLASSE OficinaServiceImpl >>>

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\service\orcamento\OrcamentoService.java   |   package br.com.fiap.service.orcamento   |   class OrcamentoService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// br/com/fiap/service/orcamento/OrcamentoService.java
package br.com.fiap.service.orcamento;

import br.com.fiap.dto.orcamento.OrcamentoRequestDto;
import br.com.fiap.dto.orcamento.OrcamentoResponseDto;
import br.com.fiap.dto.orcamento.OrcamentoComServicoRequestDto;
import java.util.List;

public interface OrcamentoService {
    List<OrcamentoResponseDto> findAll();
    OrcamentoResponseDto findById(Long id);

    // Método CRUD simples para criar um orçamento (se necessário)
    OrcamentoResponseDto create(OrcamentoRequestDto orcamentoDto);

    // Método CRUD simples para atualizar um orçamento (se necessário)
    OrcamentoResponseDto update(Long id, OrcamentoRequestDto orcamentoDto);

    void deleteById(Long id);

    // Novo método para criar o orçamento completo com serviço e peças
    OrcamentoResponseDto registrarServicoComOrcamento(OrcamentoComServicoRequestDto dto);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\service\orcamento\OrcamentoServiceImpl.java   |   package br.com.fiap.service.orcamento   |   class OrcamentoServiceImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// br/com/fiap/service/orcamento/OrcamentoServiceImpl.java
package br.com.fiap.service.orcamento;

import br.com.fiap.dto.orcamento.OrcamentoComServicoRequestDto;
import br.com.fiap.dto.orcamento.OrcamentoResponseDto;
import br.com.fiap.dto.orcamento.OrcamentoRequestDto;
import br.com.fiap.exception.*;
import br.com.fiap.mapper.OrcamentoMapper;
import br.com.fiap.mapper.OficinaMapper; // <<< Import que estava faltando e foi adicionado
// Se ClienteMapper e VeiculoMapper não forem usados diretamente aqui, podem ser removidos dos imports desta classe.
import br.com.fiap.model.*;
import br.com.fiap.model.relacionamentos.*;
import br.com.fiap.repository.*;
import br.com.fiap.repository.relacionamentos.*;
import br.com.fiap.service.oficina.OficinaService;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class OrcamentoServiceImpl implements OrcamentoService {

    private static final Logger log = LoggerFactory.getLogger(OrcamentoServiceImpl.class);

    private final OrcamentoRepository orcamentoRepository;
    private final OrcamentoMapper orcamentoMapper;
    private final OficinaMapper oficinaMapper; // Agora o import existe
    private final OficinaService oficinaService;
    private final PecasRepository pecasRepository;

    private final OficinaOrcamentoRepository oficinaOrcamentoRepository;
    private final ClienteOrcamentoRepository clienteOrcamentoRepository;
    private final ClientesRepository clientesRepository;
    private final VeiculoRepository veiculoRepository;
    private final OficinaVeiculoRepository oficinaVeiculoRepository;

    @Autowired
    public OrcamentoServiceImpl(OrcamentoRepository orcamentoRepository,
                                OrcamentoMapper orcamentoMapper,
                                OficinaMapper oficinaMapper, // Injetado
                                OficinaService oficinaService,
                                PecasRepository pecasRepository,
                                OficinaOrcamentoRepository oficinaOrcamentoRepository,
                                ClienteOrcamentoRepository clienteOrcamentoRepository,
                                ClientesRepository clientesRepository,
                                VeiculoRepository veiculoRepository,
                                OficinaVeiculoRepository oficinaVeiculoRepository) {
        this.orcamentoRepository = orcamentoRepository;
        this.orcamentoMapper = orcamentoMapper;
        this.oficinaMapper = oficinaMapper; // Atribuído
        this.oficinaService = oficinaService;
        this.pecasRepository = pecasRepository;
        this.oficinaOrcamentoRepository = oficinaOrcamentoRepository;
        this.clienteOrcamentoRepository = clienteOrcamentoRepository;
        this.clientesRepository = clientesRepository;
        this.veiculoRepository = veiculoRepository;
        this.oficinaVeiculoRepository = oficinaVeiculoRepository;
    }

    // ... (Restante do código da classe OrcamentoServiceImpl como na resposta anterior) ...
    @Override
    @Transactional
    public OrcamentoResponseDto registrarServicoComOrcamento(OrcamentoComServicoRequestDto dto) {
        log.info("Registrando novo serviço com orçamento.");

        Oficina oficinaEntidade;
        if (dto.getOficinaExistenteId() != null) {
            log.info("Atualizando oficina existente ID: {}", dto.getOficinaExistenteId());
            Oficina oficinaParcialmenteMapeadaComDadosDoDto = oficinaMapper.fromOrcamentoComServicoDto(dto);
            oficinaEntidade = oficinaService.atualizarOficinaComPecas(
                    dto.getOficinaExistenteId(),
                    oficinaParcialmenteMapeadaComDadosDoDto,
                    dto.getPecasUtilizadas()
            );
        } else {
            log.info("Criando nova oficina.");
            Oficina oficinaParcialmenteMapeadaComDadosDoDto = oficinaMapper.fromOrcamentoComServicoDto(dto);
            oficinaEntidade = oficinaService.salvarOficinaComPecas(
                    oficinaParcialmenteMapeadaComDadosDoDto,
                    dto.getPecasUtilizadas()
            );
        }
        log.info("Oficina ID {} processada com {} peças.", oficinaEntidade.getId(), oficinaEntidade.getOficinaPecas() != null ? oficinaEntidade.getOficinaPecas().size() : 0);

        if (dto.getVeiculoId() != null && oficinaEntidade.getId() != null) {
            Veiculo veiculo = veiculoRepository.findById(dto.getVeiculoId())
                    .orElseThrow(() -> new VeiculoNotFoundException("Veículo não encontrado com ID: " + dto.getVeiculoId()));

            boolean associacaoExiste = oficinaEntidade.getOficinaVeiculos() != null &&
                    oficinaEntidade.getOficinaVeiculos().stream()
                            .anyMatch(ov -> ov.getVeiculo().getId().equals(dto.getVeiculoId()));

            if (!associacaoExiste) {
                OficinaVeiculo oficinaVeiculo = new OficinaVeiculo();
                oficinaVeiculo.setOficina(oficinaEntidade);
                oficinaVeiculo.setVeiculo(veiculo);
                oficinaVeiculoRepository.save(oficinaVeiculo);
                if (oficinaEntidade.getOficinaVeiculos() == null) {
                    oficinaEntidade.setOficinaVeiculos(new ArrayList<>());
                }
                oficinaEntidade.getOficinaVeiculos().add(oficinaVeiculo);
                log.info("Veículo ID {} associado à Oficina ID {}.", dto.getVeiculoId(), oficinaEntidade.getId());
            }
        }

        BigDecimal totalCustoPecas = BigDecimal.ZERO;
        if (oficinaEntidade.getOficinaPecas() != null) {
            for (OficinaPeca op : oficinaEntidade.getOficinaPecas()) {
                if (op.getPeca() != null && op.getPeca().getPreco() != null && op.getQuantidade() != null) {
                    BigDecimal precoPeca = op.getPeca().getPreco();
                    BigDecimal quantidadePeca = BigDecimal.valueOf(op.getQuantidade());
                    totalCustoPecas = totalCustoPecas.add(precoPeca.multiply(quantidadePeca));
                } else {
                    log.warn("Peça ou preço da peça nulo para OficinaPeca ID: {} na Oficina ID: {}", op.getId(), oficinaEntidade.getId());
                }
            }
        }
        log.info("Custo total das peças calculado: {}", totalCustoPecas);

        Orcamento orcamento = orcamentoMapper.fromOrcamentoComServicoDto(dto);

        BigDecimal custoMaoDeObraHoras = BigDecimal.ZERO;
        if (orcamento.getValorHora() != null && orcamento.getQuantidadeHoras() != null && orcamento.getQuantidadeHoras() >= 0) {
            custoMaoDeObraHoras = orcamento.getValorHora().multiply(BigDecimal.valueOf(orcamento.getQuantidadeHoras()));
        }
        BigDecimal custoMaoDeObraTotal = (orcamento.getMaoDeObra() != null ? orcamento.getMaoDeObra() : BigDecimal.ZERO).add(custoMaoDeObraHoras);
        log.info("Custo total da mão de obra calculado: {}", custoMaoDeObraTotal);

        BigDecimal valorTotalOrcamento = custoMaoDeObraTotal.add(totalCustoPecas);
        orcamento.setValorTotal(valorTotalOrcamento.setScale(2, RoundingMode.HALF_UP));
        log.info("Valor total do orçamento calculado: {}", orcamento.getValorTotal());

        Orcamento orcamentoSalvo = orcamentoRepository.save(orcamento);
        log.info("Orçamento salvo com ID: {}", orcamentoSalvo.getId());

        OficinaOrcamento oficinaOrcamento = new OficinaOrcamento();
        oficinaOrcamento.setOficina(oficinaEntidade);
        oficinaOrcamento.setOrcamento(orcamentoSalvo);
        oficinaOrcamentoRepository.save(oficinaOrcamento);
        log.info("Ligação Oficina-Orçamento criada: Oficina ID {}, Orçamento ID {}", oficinaEntidade.getId(), orcamentoSalvo.getId());

        if (dto.getClienteId() != null && dto.getClienteEnderecoId() != null) {
            ClienteId clientePk = new ClienteId(dto.getClienteId(), dto.getClienteEnderecoId());
            Clientes cliente = clientesRepository.findById(clientePk)
                    .orElseThrow(() -> new ClientesNotFoundException("Cliente não encontrado com ID: " + clientePk));

            ClienteOrcamento clienteOrcamento = new ClienteOrcamento();
            clienteOrcamento.setCliente(cliente);
            clienteOrcamento.setOrcamento(orcamentoSalvo);
            clienteOrcamentoRepository.save(clienteOrcamento);
            log.info("Ligação Cliente-Orçamento criada: Cliente ID {}, Orçamento ID {}", clientePk, orcamentoSalvo.getId());
        }

        return orcamentoMapper.toResponseDto(orcamentoSalvo);
    }

    @Override
    @Transactional
    public OrcamentoResponseDto create(OrcamentoRequestDto dto) {
        log.info("Criando novo orçamento (simples)");
        Orcamento orcamento = orcamentoMapper.toEntity(dto);

        BigDecimal maoDeObra = orcamento.getMaoDeObra() != null ? orcamento.getMaoDeObra() : BigDecimal.ZERO;
        BigDecimal valorHora = orcamento.getValorHora() != null ? orcamento.getValorHora() : BigDecimal.ZERO;
        Integer qtdHoras = orcamento.getQuantidadeHoras() != null ? orcamento.getQuantidadeHoras() : 0;

        BigDecimal custoHoras = valorHora.multiply(BigDecimal.valueOf(qtdHoras));
        orcamento.setValorTotal(maoDeObra.add(custoHoras).setScale(2, RoundingMode.HALF_UP));

        Orcamento savedOrcamento = orcamentoRepository.save(orcamento);
        log.info("Orçamento (simples) criado com ID: {}", savedOrcamento.getId());
        return orcamentoMapper.toResponseDto(savedOrcamento);
    }

    @Override
    @Transactional
    public OrcamentoResponseDto update(Long id, OrcamentoRequestDto dto) {
        log.info("Atualizando orçamento (simples) com ID: {}", id);
        Orcamento existingOrcamento = findOrcamentoByIdOrElseThrow(id);

        orcamentoMapper.updateEntityFromDto(dto, existingOrcamento);

        BigDecimal maoDeObra = existingOrcamento.getMaoDeObra() != null ? existingOrcamento.getMaoDeObra() : BigDecimal.ZERO;
        BigDecimal valorHora = existingOrcamento.getValorHora() != null ? existingOrcamento.getValorHora() : BigDecimal.ZERO;
        Integer qtdHoras = existingOrcamento.getQuantidadeHoras() != null ? existingOrcamento.getQuantidadeHoras() : 0;

        BigDecimal custoHoras = valorHora.multiply(BigDecimal.valueOf(qtdHoras));
        existingOrcamento.setValorTotal(maoDeObra.add(custoHoras).setScale(2, RoundingMode.HALF_UP));

        Orcamento updatedOrcamento = orcamentoRepository.save(existingOrcamento);
        log.info("Orçamento (simples) atualizado com ID: {}", updatedOrcamento.getId());
        return orcamentoMapper.toResponseDto(updatedOrcamento);
    }

    @Override
    @Transactional(readOnly = true)
    public List<OrcamentoResponseDto> findAll() {
        log.info("Buscando todos os orçamentos (simples)");
        return orcamentoRepository.findAll().stream()
                .map(orcamentoMapper::toResponseDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public OrcamentoResponseDto findById(Long id) {
        log.info("Buscando orçamento por ID: {}", id);
        Orcamento orcamento = findOrcamentoByIdOrElseThrow(id);
        return orcamentoMapper.toResponseDto(orcamento);
    }

    @Override
    @Transactional
    public void deleteById(Long id) {
        log.info("Deletando orçamento com ID: {}", id);
        Orcamento orcamento = findOrcamentoByIdOrElseThrow(id);

        log.warn("Lógica de remoção de associações (OFO, CO, PAO) para o orçamento ID {} precisa ser implementada antes da exclusão final.", id);

        // Exemplo de como remover associações em OFO (OficinaOrcamento)
        // Assumindo que você tenha um método no OficinaOrcamentoRepository para buscar por orcamentoId
        List<OficinaOrcamento> oficinaOrcamentos = oficinaOrcamentoRepository.findByOrcamentoId(id); // Precisa existir esse método no repo
        if (oficinaOrcamentos != null && !oficinaOrcamentos.isEmpty()) {
            oficinaOrcamentoRepository.deleteAll(oficinaOrcamentos);
            log.info("Associações Oficina-Orçamento removidas para Orçamento ID: {}", id);
        }

        List<ClienteOrcamento> clienteOrcamentos = clienteOrcamentoRepository.findByOrcamentoId(id); // Precisa existir esse método no repo
        if (clienteOrcamentos != null && !clienteOrcamentos.isEmpty()) {
            clienteOrcamentoRepository.deleteAll(clienteOrcamentos);
            log.info("Associações Cliente-Orçamento removidas para Orçamento ID: {}", id);
        }
        // Adicionar lógica para PagamentoOrcamentoRepository.deleteByOrcamentoId(id); se aplicável

        try {
            orcamentoRepository.delete(orcamento);
            log.info("Orçamento deletado com ID: {}", id);
        } catch (Exception e) {
            log.error("Erro ao deletar orçamento com ID {}: {}", id, e.getMessage(), e);
            throw new RuntimeException("Falha ao deletar orçamento. Pode estar associado a outros registros. ID: " + id, e);
        }
    }

    private Orcamento findOrcamentoByIdOrElseThrow(Long id) {
        return orcamentoRepository.findById(id)
                .orElseThrow(() -> new OrcamentoNotFoundException("Orçamento não encontrado com ID: " + id));
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\service\pagamento\PagamentoService.java   |   package br.com.fiap.service.pagamento   |   class PagamentoService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.service.pagamento;

import br.com.fiap.dto.pagamento.PagamentoRequestDto;
import br.com.fiap.dto.pagamento.PagamentoResponseDto;
import org.springframework.data.domain.Page;     // <<< IMPORT Page
import org.springframework.data.domain.Pageable; // <<< IMPORT Pageable
import java.math.BigDecimal; // <<< IMPORT BigDecimal
import java.time.LocalDate;  // <<< IMPORT LocalDate
import java.util.List;

public interface PagamentoService {

    // Métodos CRUD existentes
    List<PagamentoResponseDto> listarTodos(); // Mantém para listagem simples sem paginação/filtro se útil
    PagamentoResponseDto buscarPorId(Long id);
    PagamentoResponseDto cadastrar(PagamentoRequestDto dto);
    PagamentoResponseDto alterar(Long id, PagamentoRequestDto dto);
    void deletar(Long id);

    // --- NOVO MÉTODO PARA BUSCA COM FILTROS E PAGINAÇÃO ---
    Page<PagamentoResponseDto> findWithFilters(
            LocalDate dataInicio,
            LocalDate dataFim,
            String tipoPagamento,
            BigDecimal valorMin,
            BigDecimal valorMax,
            Long clienteId,     // Filtro opcional por Cliente
            Long orcamentoId,   // Filtro opcional por Orcamento
            Pageable pageable   // Para paginação e ordenação
    );
    // ------------------------------------------------------
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\service\pagamento\PagamentoServiceImpl.java   |   package br.com.fiap.service.pagamento   |   class PagamentoServiceImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.service.pagamento; // Ou br.com.fiap.service.pagamento.impl

import br.com.fiap.dto.pagamento.PagamentoRequestDto;
import br.com.fiap.dto.pagamento.PagamentoResponseDto;
import br.com.fiap.exception.PagamentoNotFoundException;
import br.com.fiap.mapper.PagamentoMapper; // <<< IMPORTAR O MAPPER
import br.com.fiap.model.Pagamento;
import br.com.fiap.repository.PagamentoRepository;
// Remova jakarta.persistence.EntityNotFoundException se PagamentoNotFoundException for sempre usada
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;
import br.com.fiap.repository.specification.PagamentoSpecification; // Para o método findWithFilters

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class PagamentoServiceImpl implements PagamentoService {

    private static final Logger log = LoggerFactory.getLogger(PagamentoServiceImpl.class);
    private static final BigDecimal CEM = new BigDecimal("100");
    private static final int DEFAULT_SCALE = 2;
    private static final RoundingMode DEFAULT_ROUNDING_MODE = RoundingMode.HALF_UP;

    @Autowired
    private PagamentoRepository pagamentoRepository;

    @Autowired
    private PagamentoMapper pagamentoMapper; // <<< INJETAR O MAPPER

    @Override
    @Transactional(readOnly = true)
    public List<PagamentoResponseDto> listarTodos() {
        log.info("Listando todos os pagamentos (sem filtros/paginação)");
        return pagamentoRepository.findAll().stream()
                .map(pagamentoMapper::toResponseDto) // Usa o mapper
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public PagamentoResponseDto buscarPorId(Long id) {
        log.info("Buscando pagamento com ID: {}", id);
        return pagamentoMapper.toResponseDto(findPagamentoByIdOrElseThrow(id)); // Usa o mapper
    }

    @Override
    @Transactional
    public PagamentoResponseDto cadastrar(PagamentoRequestDto dto) {
        log.info("Cadastrando novo pagamento...");
        // Mapeamento básico dos campos que coincidem ou foram explicitamente mapeados no PagamentoMapper
        Pagamento pagamento = pagamentoMapper.toEntity(dto);

        // Agora, aplicamos a lógica de cálculo para os campos que foram ignorados pelo mapper
        // ou que dependem de outros valores do DTO.
        calculateAndSetDerivedValues(pagamento, dto.getValorServico(), dto.getDescontoPercentual(), dto.getTotalParcelas());

        // Lógica para associar com Cliente/Orçamento (se necessário)...

        Pagamento pagamentoSalvo = pagamentoRepository.save(pagamento);
        log.info("Pagamento cadastrado com sucesso com ID: {}", pagamentoSalvo.getId());
        return pagamentoMapper.toResponseDto(pagamentoSalvo); // Usa o mapper
    }

    @Override
    @Transactional
    public PagamentoResponseDto alterar(Long id, PagamentoRequestDto dto) {
        log.info("Alterando pagamento com ID: {}", id);
        Pagamento pagamento = findPagamentoByIdOrElseThrow(id);

        // Atualiza os campos básicos usando o mapper
        // O PagamentoMapper.updateEntityFromDto já ignora o ID e os campos calculados
        pagamentoMapper.updateEntityFromDto(dto, pagamento);

        // Recalcula os valores derivados
        calculateAndSetDerivedValues(pagamento, dto.getValorServico(), dto.getDescontoPercentual(), dto.getTotalParcelas());

        // Lógica para atualizar associações (se necessário)...

        Pagamento pagamentoAtualizado = pagamentoRepository.save(pagamento);
        log.info("Pagamento ID: {} alterado com sucesso.", id);
        return pagamentoMapper.toResponseDto(pagamentoAtualizado); // Usa o mapper
    }

    @Override
    @Transactional
    public void deletar(Long id) {
        log.info("Deletando pagamento com ID: {}", id);
        if (!pagamentoRepository.existsById(id)) {
            throw new PagamentoNotFoundException("Pagamento não encontrado para exclusão com ID: " + id);
        }
        pagamentoRepository.deleteById(id);
        log.info("Pagamento ID: {} deletado com sucesso.", id);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<PagamentoResponseDto> findWithFilters(
            LocalDate dataInicio, LocalDate dataFim, String tipoPagamento,
            BigDecimal valorMin, BigDecimal valorMax, Long clienteId,
            Long orcamentoId, Pageable pageable)
    {
        log.info("Buscando pagamentos com filtros: dataInicio={}, dataFim={}, tipo={}, valorMin={}, valorMax={}, clienteId={}, orcamentoId={}, pageable={}",
                dataInicio, dataFim, tipoPagamento, valorMin, valorMax, clienteId, orcamentoId, pageable);

        Specification<Pagamento> spec = Specification.where(null);
        if (dataInicio != null) spec = spec.and(PagamentoSpecification.dataPagamentoMaiorOuIgualA(dataInicio));
        if (dataFim != null) spec = spec.and(PagamentoSpecification.dataPagamentoMenorOuIgualA(dataFim));
        if (StringUtils.hasText(tipoPagamento)) spec = spec.and(PagamentoSpecification.tipoPagamentoIgual(tipoPagamento));
        if (valorMin != null) spec = spec.and(PagamentoSpecification.totalComDescontoMaiorOuIgualA(valorMin));
        if (valorMax != null) spec = spec.and(PagamentoSpecification.totalComDescontoMenorOuIgualA(valorMax));
        if (clienteId != null && clienteId > 0) spec = spec.and(PagamentoSpecification.associadoAoCliente(clienteId));
        if (orcamentoId != null && orcamentoId > 0) spec = spec.and(PagamentoSpecification.associadoAoOrcamento(orcamentoId));

        Page<Pagamento> paginaPagamentos = pagamentoRepository.findAll(spec, pageable);
        log.info("Encontrados {} pagamentos na página {}/{} para os filtros aplicados.",
                paginaPagamentos.getNumberOfElements(), pageable.getPageNumber(), paginaPagamentos.getTotalPages());
        return paginaPagamentos.map(pagamentoMapper::toResponseDto); // Usa o mapper
    }

    // --- Métodos Auxiliares ---
    private Pagamento findPagamentoByIdOrElseThrow(Long id) {
        return pagamentoRepository.findById(id)
                .orElseThrow(() -> new PagamentoNotFoundException("Pagamento não encontrado com ID: " + id));
    }

    // Este método de conversão para DTO de resposta agora pode ser substituído pelo mapper
    // Se o mapeamento for direto e simples, senão, mantenha-o para lógica customizada.
    // private PagamentoResponseDto convertToResponseDto(Pagamento pagamento) {
    //     if (pagamento == null) return null;
    //     return pagamentoMapper.toResponseDto(pagamento);
    // }

    // Método centralizado para calcular os valores que o mapper ignorou
    private void calculateAndSetDerivedValues(Pagamento pagamento, BigDecimal valorServico,
                                              BigDecimal descontoPercentualInput, Integer totalParcelasInput) {

        // O mapper já deve ter setado:
        // pagamento.setDataPagamento(dto.getDataPagamento());
        // pagamento.setTipoPagamento(dto.getTipoPagamento());
        // pagamento.setDesconto(descontoPercentualInput); // Armazena %
        // pagamento.setTotalParcelas(String.valueOf(totalParcelasInput)); // O mapper já fez a conversão Integer para String

        BigDecimal descontoPercentual = pagamento.getDesconto(); // Pega o que o mapper passou
        Integer totalParcelasInt;
        try {
            totalParcelasInt = Integer.parseInt(pagamento.getTotalParcelas());
        } catch (NumberFormatException e) {
            log.warn("Total de parcelas inválido na entidade: '{}'. Usando 1.", pagamento.getTotalParcelas());
            totalParcelasInt = 1;
            pagamento.setTotalParcelas("1"); // Corrige na entidade também
        }
        if (totalParcelasInt < 1) totalParcelasInt = 1;


        BigDecimal totalComDescontoCalculado;
        BigDecimal valorParcelaCalculado;

        if (valorServico != null && valorServico.compareTo(BigDecimal.ZERO) > 0) {
            BigDecimal fatorDesconto = BigDecimal.ONE.subtract(
                    descontoPercentual.divide(CEM, 4, DEFAULT_ROUNDING_MODE)
            );
            totalComDescontoCalculado = valorServico.multiply(fatorDesconto)
                    .setScale(DEFAULT_SCALE, DEFAULT_ROUNDING_MODE);
            valorParcelaCalculado = totalComDescontoCalculado.divide(
                    BigDecimal.valueOf(totalParcelasInt), DEFAULT_SCALE, DEFAULT_ROUNDING_MODE
            );
        } else {
            totalComDescontoCalculado = BigDecimal.ZERO.setScale(DEFAULT_SCALE, DEFAULT_ROUNDING_MODE);
            valorParcelaCalculado = BigDecimal.ZERO.setScale(DEFAULT_SCALE, DEFAULT_ROUNDING_MODE);
        }
        pagamento.setTotalComDesconto(totalComDescontoCalculado);
        pagamento.setValorParcelas(valorParcelaCalculado);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\service\pecas\PecasService.java   |   package br.com.fiap.service.pecas   |   class PecasService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.service.pecas;

import br.com.fiap.dto.pecas.PecasRequestDto;
import br.com.fiap.dto.pecas.PecasResponseDto;
import java.util.List;

public interface PecasService {
    List<PecasResponseDto> findAll();
    PecasResponseDto findById(Long id);
    PecasResponseDto create(PecasRequestDto pecasDto);
    PecasResponseDto update(Long id, PecasRequestDto pecasDto);
    void deleteById(Long id);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\service\pecas\PecasServiceImpl.java   |   package br.com.fiap.service.pecas   |   class PecasServiceImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// --- src/main/java/br/com/fiap/service/pecas/PecasServiceImpl.java ---
package br.com.fiap.service.pecas;

import br.com.fiap.dto.pecas.PecasRequestDto;
import br.com.fiap.dto.pecas.PecasResponseDto;
import br.com.fiap.exception.PecasNotFoundException;
import br.com.fiap.mapper.PecasMapper; // Importar Mapper
import br.com.fiap.model.Pecas;
import br.com.fiap.repository.PecasRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class PecasServiceImpl implements PecasService {

    private static final Logger log = LoggerFactory.getLogger(PecasServiceImpl.class);
    private final PecasRepository pecasRepository;
    private final PecasMapper pecasMapper; // <-- Injetar Mapper

    @Autowired
    public PecasServiceImpl(PecasRepository pecasRepository, PecasMapper pecasMapper) { // <-- Injetar
        this.pecasRepository = pecasRepository;
        this.pecasMapper = pecasMapper; // <-- Inicializar
    }

    @Override
    @Transactional(readOnly = true)
    public List<PecasResponseDto> findAll() {
        log.info("Buscando todas as peças");
        return pecasRepository.findAll().stream()
                .map(pecasMapper::toResponseDto) // <-- Usar Mapper
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public PecasResponseDto findById(Long id) {
        log.info("Buscando peça por ID: {}", id);
        Pecas peca = findPecaById(id);
        return pecasMapper.toResponseDto(peca); // <-- Usar Mapper
    }

    @Override
    @Transactional
    public PecasResponseDto create(PecasRequestDto pecasDto) {
        log.info("Criando nova peça");
        // Adicionar lógica de cálculo se necessário
        try {
            Pecas peca = pecasMapper.toEntity(pecasDto); // <-- Usar Mapper
            Pecas savedPeca = pecasRepository.save(peca);
            log.info("Peça criada com ID: {}", savedPeca.getId());
            return pecasMapper.toResponseDto(savedPeca); // <-- Usar Mapper
        } catch (Exception e) {
            log.error("Erro ao criar peça: {}", e.getMessage(), e);
            throw new RuntimeException("Falha ao criar peça", e);
        }
    }

    @Override
    @Transactional
    public PecasResponseDto update(Long id, PecasRequestDto pecasDto) {
        log.info("Atualizando peça com ID: {}", id);
        Pecas existingPeca = findPecaById(id);
        pecasMapper.updateEntityFromDto(pecasDto, existingPeca); // <-- Usar Mapper
        // Recalcular campos se necessário
        Pecas updatedPeca = pecasRepository.save(existingPeca);
        log.info("Peça atualizada com ID: {}", updatedPeca.getId());
        return pecasMapper.toResponseDto(updatedPeca); // <-- Usar Mapper
    }

    @Override
    @Transactional
    public void deleteById(Long id) {
        log.info("Deletando peça com ID: {}", id);
        Pecas peca = findPecaById(id); // Verifica existência
        try {
            pecasRepository.delete(peca);
            log.info("Peça deletada com ID: {}", id);
        } catch (Exception e) {
            log.error("Erro ao deletar peça com ID {}: {}", id, e.getMessage(), e);
            throw new RuntimeException("Falha ao deletar peça com ID: " + id, e);
        }
    }

    // --- Método auxiliar ---
    private Pecas findPecaById(Long id) {
        return pecasRepository.findById(id)
                .orElseThrow(() -> new PecasNotFoundException("Peça não encontrada com ID: " + id));
    }

    // REMOVER os métodos manuais de mapeamento:
    // mapEntityToResponseDto(Pecas entity)
    // mapRequestDtoToEntity(PecasRequestDto dto)
    // updateEntityFromDto(Pecas entity, PecasRequestDto dto)
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\service\relatorio\RelatorioService.java   |   package br.com.fiap.service.relatorio   |   class RelatorioService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/main/java/br/com/fiap/service/relatorio/RelatorioService.java
package br.com.fiap.service.relatorio;

import br.com.fiap.dto.relatorio.*; // Importa todos os DTOs de relatório
import br.com.fiap.model.relacionamentos.ClienteId;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import java.time.LocalDate;
import java.util.List;

public interface RelatorioService {

    List<ContagemMensalDTO> getContagemMensalAgendamentos();
    List<HistoricoAgendamentoClienteDTO> getHistoricoAgendamentosCliente(ClienteId id);
    Page<ServicoAgendadoDTO> findServicosAgendados(LocalDate dataInicio, Pageable pageable);

    // --- NOVOS MÉTODOS PARA RELATÓRIOS DE PAGAMENTO ---
    EstatisticasPagamentosDto getEstatisticasPagamentos(LocalDate dataInicio, LocalDate dataFim);
    List<PagamentoPorTipoDto> getPagamentosPorTipo(LocalDate dataInicio, LocalDate dataFim);
    List<EvolucaoMensalValorDto> getEvolucaoMensalValorPagamentos(LocalDate dataInicio, LocalDate dataFim);
    // ----------------------------------------------------
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\service\relatorio\RelatorioServiceImpl.java   |   package br.com.fiap.service.relatorio   |   class RelatorioServiceImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/main/java/br/com/fiap/service/relatorio/RelatorioServiceImpl.java
package br.com.fiap.service.relatorio;

import br.com.fiap.dto.relatorio.*;
import br.com.fiap.exception.ClientesNotFoundException;
import br.com.fiap.model.relacionamentos.ClienteId;
import br.com.fiap.repository.AgendaRepository;
import br.com.fiap.repository.ClientesRepository;
import br.com.fiap.repository.PagamentoRepository; // Importado
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class RelatorioServiceImpl implements RelatorioService {

    private static final Logger log = LoggerFactory.getLogger(RelatorioServiceImpl.class);
    private final AgendaRepository agendaRepository;
    private final ClientesRepository clientesRepository;
    private final PagamentoRepository pagamentoRepository; // Injetado

    @Autowired
    public RelatorioServiceImpl(AgendaRepository agendaRepository,
                                ClientesRepository clientesRepository,
                                PagamentoRepository pagamentoRepository) { // Adicionado ao construtor
        this.agendaRepository = agendaRepository;
        this.clientesRepository = clientesRepository;
        this.pagamentoRepository = pagamentoRepository; // Atribuído
    }

    @Override
    @Transactional(readOnly = true)
    public List<ContagemMensalDTO> getContagemMensalAgendamentos() {
        log.info("Gerando relatório de contagem mensal de agendamentos.");
        try {
            List<ContagemMensalResultadoNativo> resultadosNativos = agendaRepository.countAgendamentosByMonthNative();
            List<ContagemMensalDTO> resultadoDTO = resultadosNativos.stream()
                    .map(nativo -> new ContagemMensalDTO(nativo.getMesAno(), nativo.getQuantidade()))
                    .collect(Collectors.toList());
            log.info("Relatório de contagem mensal gerado com {} resultados.", resultadoDTO.size());
            return resultadoDTO;
        } catch (Exception e) {
            log.error("Erro ao gerar relatório de contagem mensal: {}", e.getMessage(), e);
            return Collections.emptyList();
        }
    }

    @Override
    @Transactional(readOnly = true)
    public List<HistoricoAgendamentoClienteDTO> getHistoricoAgendamentosCliente(ClienteId id) {
        log.info("Buscando histórico de agendamentos para Cliente ID: {}", id);
        if (id == null || id.getIdCli() == null || id.getEnderecoId() == null) {
            throw new IllegalArgumentException("ID do Cliente (composto) inválido para buscar histórico.");
        }
        if (!clientesRepository.existsById(id)) {
            log.warn("Tentativa de buscar histórico para cliente inexistente: {}", id);
            throw new ClientesNotFoundException("Cliente não encontrado com ID: " + id);
        }
        try {
            List<HistoricoAgendamentoClienteDTO> historico = agendaRepository.findHistoricoAgendamentosByClienteId(id.getIdCli(), id.getEnderecoId());
            log.info("Encontrados {} registros de histórico para o cliente ID {}", historico.size(), id);
            return historico;
        } catch (Exception e) {
            log.error("Erro ao buscar histórico para cliente ID {}: {}", id, e.getMessage(), e);
            return Collections.emptyList();
        }
    }

    @Override
    @Transactional(readOnly = true)
    public Page<ServicoAgendadoDTO> findServicosAgendados(LocalDate dataInicio, Pageable pageable) {
        log.info("Buscando relatório de serviços agendados a partir de {} com paginação {}", dataInicio, pageable);
        try {
            Page<ServicoAgendadoDTO> pagina = agendaRepository.findServicosAgendados(dataInicio, pageable);
            log.info("Encontrados {} serviços agendados na página {}/{}",
                    pagina.getNumberOfElements(),
                    pageable.getPageNumber(),
                    pagina.getTotalPages());
            return pagina;
        } catch (Exception e) {
            log.error("Erro ao buscar relatório de serviços agendados: {}", e.getMessage(), e);
            return Page.empty(pageable);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public EstatisticasPagamentosDto getEstatisticasPagamentos(LocalDate dataInicio, LocalDate dataFim) {
        log.info("Gerando estatísticas de pagamentos para o período de {} a {}", dataInicio, dataFim);
        try {
            List<Object[]> result = pagamentoRepository.getEstatisticasPagamentos(dataInicio, dataFim);
            if (result != null && !result.isEmpty() && result.get(0) != null) {
                Object[] stats = result.get(0);
                Long totalOperacoes = (stats[0] instanceof Number) ? ((Number) stats[0]).longValue() : 0L;
                BigDecimal valorTotalArrecadado = (stats[1] instanceof BigDecimal) ? (BigDecimal) stats[1] : BigDecimal.ZERO;
                BigDecimal ticketMedio = BigDecimal.ZERO;
                if (stats[2] instanceof Number) {
                    ticketMedio = BigDecimal.valueOf(((Number) stats[2]).doubleValue()).setScale(2, BigDecimal.ROUND_HALF_UP);
                } else if (stats[2] instanceof BigDecimal) {
                    ticketMedio = ((BigDecimal) stats[2]).setScale(2, BigDecimal.ROUND_HALF_UP);
                }
                valorTotalArrecadado = valorTotalArrecadado == null ? BigDecimal.ZERO : valorTotalArrecadado;
                ticketMedio = ticketMedio == null ? BigDecimal.ZERO : ticketMedio;
                return new EstatisticasPagamentosDto(totalOperacoes, valorTotalArrecadado, ticketMedio);
            }
            return new EstatisticasPagamentosDto(0L, BigDecimal.ZERO, BigDecimal.ZERO);
        } catch (Exception e) {
            log.error("Erro ao gerar estatísticas de pagamentos: {}", e.getMessage(), e);
            return new EstatisticasPagamentosDto(0L, BigDecimal.ZERO, BigDecimal.ZERO);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public List<PagamentoPorTipoDto> getPagamentosPorTipo(LocalDate dataInicio, LocalDate dataFim) {
        log.info("Gerando relatório de pagamentos por tipo para o período de {} a {}", dataInicio, dataFim);
        try {
            return pagamentoRepository.findPagamentosAgrupadosPorTipo(dataInicio, dataFim);
        } catch (Exception e) {
            log.error("Erro ao gerar relatório de pagamentos por tipo: {}", e.getMessage(), e);
            return Collections.emptyList();
        }
    }

    @Override
    @Transactional(readOnly = true)
    public List<EvolucaoMensalValorDto> getEvolucaoMensalValorPagamentos(LocalDate dataInicio, LocalDate dataFim) {
        log.info("Gerando relatório de evolução mensal do valor dos pagamentos para o período de {} a {}", dataInicio, dataFim);
        try {
            // CORREÇÃO APLICADA AQUI: Processar List<Object[]>
            List<Object[]> resultadosNativos = pagamentoRepository.findEvolucaoMensalValorPagamentosNativo(dataInicio, dataFim);
            return resultadosNativos.stream()
                    .map(record -> {
                        String mesAno = (String) record[0];
                        // O SUM no Oracle pode retornar um tipo numérico que precisa ser convertido para BigDecimal
                        BigDecimal valorTotal = BigDecimal.ZERO;
                        if (record[1] instanceof BigDecimal) {
                            valorTotal = (BigDecimal) record[1];
                        } else if (record[1] instanceof Number) {
                            valorTotal = BigDecimal.valueOf(((Number)record[1]).doubleValue());
                        }
                        return new EvolucaoMensalValorDto(mesAno, valorTotal != null ? valorTotal : BigDecimal.ZERO);
                    })
                    .collect(Collectors.toList());
        } catch (Exception e) {
            log.error("Erro ao gerar relatório de evolução mensal do valor dos pagamentos: {}", e.getMessage(), e);
            return Collections.emptyList();
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\service\relatorio\cliente\RelatorioClienteService.java   |   package br.com.fiap.service.relatorio.cliente   |   class RelatorioClienteService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// --- Arquivo: src/main/java/br/com/fiap/service/relatorio/cliente/RelatorioClienteService.java ---
package br.com.fiap.service.relatorio.cliente;

import br.com.fiap.dto.relatorio.ClienteRelatorioCompletoDTO;

/**
 * Interface para serviços de geração de relatórios específicos de clientes.
 */
public interface RelatorioClienteService {

    /**
     * Busca e compila um relatório completo com todos os dados associados
     * a um cliente, encontrado por ID ou Documento.
     *
     * @param tipoBusca "id" ou "documento"
     * @param valorBusca O valor correspondente (ID_CLI ou CPF/CNPJ)
     * @return Um DTO contendo todas as informações agregadas do cliente.
     * @throws br.com.fiap.exception.ClientesNotFoundException Se o cliente não for encontrado.
     * @throws IllegalArgumentException Se o tipoBusca for inválido ou o valorBusca não for compatível.
     */
    ClienteRelatorioCompletoDTO getRelatorioCompletoCliente(String tipoBusca, String valorBusca);

}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\service\relatorio\cliente\RelatorioClienteServiceImpl.java   |   package br.com.fiap.service.relatorio.cliente   |   class RelatorioClienteServiceImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// --- Arquivo: src/main/java/br/com/fiap/service/relatorio/cliente/RelatorioClienteServiceImpl.java ---
package br.com.fiap.service.relatorio.cliente;

// --- Imports Verificados e Completos ---
import br.com.fiap.dto.relatorio.ClienteRelatorioCompletoDTO;
import br.com.fiap.dto.relatorio.ClienteRelatorioCompletoDTO.*; // Para Sub-DTOs aninhados
import br.com.fiap.dto.cliente.ClienteResponseDto; // Import do DTO Cliente
import br.com.fiap.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.dto.orcamento.OrcamentoResponseDto; // <<< IMPORT ESSENCIAL
import br.com.fiap.dto.pagamento.PagamentoResponseDto; // <<< IMPORT ESSENCIAL
// Importe outros DTOs usados se necessário (AgendaSimplificadoDTO, OficinaServicoDTO, etc., se não forem aninhados)

import br.com.fiap.exception.ClientesNotFoundException;
import br.com.fiap.mapper.*;
import br.com.fiap.model.*;
import br.com.fiap.model.relacionamentos.*;
import br.com.fiap.repository.*;
import br.com.fiap.repository.relacionamentos.*;
import br.com.fiap.repository.specification.ClienteSpecification;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
// ---------------------------------------

@Service
public class RelatorioClienteServiceImpl implements RelatorioClienteService {

    private static final Logger log = LoggerFactory.getLogger(RelatorioClienteServiceImpl.class);

    // --- Injeções (sem alterações) ---
    private final ClientesRepository clienteRepository;
    private final VeiculoRepository veiculoRepository;
    private final AgendaRepository agendaRepository;
    private final OficinaRepository oficinaRepository;
    private final PecasRepository pecasRepository;
    private final OrcamentoRepository orcamentoRepository;
    private final PagamentoRepository pagamentoRepository;
    private final ClienteVeiculoRepository clienteVeiculoRepository;
    private final AgendaVeiculoRepository agendaVeiculoRepository;
    private final OficinaVeiculoRepository oficinaVeiculoRepository;
    private final OficinaPecaRepository oficinaPecaRepository;
    private final ClienteOrcamentoRepository clienteOrcamentoRepository;
    private final ClientePagamentoRepository clientePagamentoRepository;
    private final ClienteMapper clienteMapper;
    private final VeiculoMapper veiculoMapper;
    private final AgendaMapper agendaMapper;
    private final OficinaMapper oficinaMapper;
    private final PecasMapper pecasMapper;
    private final OrcamentoMapper orcamentoMapper;
    private final PagamentoMapper pagamentoMapper;
    private final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");

    @Autowired
    public RelatorioClienteServiceImpl(
            ClientesRepository clienteRepository, VeiculoRepository veiculoRepository,
            AgendaRepository agendaRepository, OficinaRepository oficinaRepository,
            PecasRepository pecasRepository, OrcamentoRepository orcamentoRepository,
            PagamentoRepository pagamentoRepository,
            ClienteVeiculoRepository clienteVeiculoRepository,
            AgendaVeiculoRepository agendaVeiculoRepository,
            OficinaVeiculoRepository oficinaVeiculoRepository,
            OficinaPecaRepository oficinaPecaRepository,
            ClienteOrcamentoRepository clienteOrcamentoRepository,
            ClientePagamentoRepository clientePagamentoRepository,
            ClienteMapper clienteMapper, VeiculoMapper veiculoMapper,
            AgendaMapper agendaMapper, OficinaMapper oficinaMapper,
            PecasMapper pecasMapper, OrcamentoMapper orcamentoMapper,
            PagamentoMapper pagamentoMapper) {
        // ... atribuições do construtor ...
        this.clienteRepository = clienteRepository;
        this.veiculoRepository = veiculoRepository;
        this.agendaRepository = agendaRepository;
        this.oficinaRepository = oficinaRepository;
        this.pecasRepository = pecasRepository;
        this.orcamentoRepository = orcamentoRepository;
        this.pagamentoRepository = pagamentoRepository;
        this.clienteVeiculoRepository = clienteVeiculoRepository;
        this.agendaVeiculoRepository = agendaVeiculoRepository;
        this.oficinaVeiculoRepository = oficinaVeiculoRepository;
        this.oficinaPecaRepository = oficinaPecaRepository;
        this.clienteOrcamentoRepository = clienteOrcamentoRepository;
        this.clientePagamentoRepository = clientePagamentoRepository;
        this.clienteMapper = clienteMapper;
        this.veiculoMapper = veiculoMapper;
        this.agendaMapper = agendaMapper;
        this.oficinaMapper = oficinaMapper;
        this.pecasMapper = pecasMapper;
        this.orcamentoMapper = orcamentoMapper;
        this.pagamentoMapper = pagamentoMapper;
    }

    @Override
    @Transactional(readOnly = true)
    public ClienteRelatorioCompletoDTO getRelatorioCompletoCliente(String tipoBusca, String valorBusca) {
        log.info("Gerando relatório completo para cliente: tipo={}, valor={}", tipoBusca, valorBusca);

        // 1. Encontrar o Cliente (sem alterações)
        Specification<Clientes> spec = Specification.where(null);
        if ("id".equalsIgnoreCase(tipoBusca)) {
            try { Long idCli = Long.parseLong(valorBusca); spec = spec.and(ClienteSpecification.idCliEquals(idCli)); }
            catch (NumberFormatException e) { throw new IllegalArgumentException("ID do cliente inválido: " + valorBusca); }
        } else if ("documento".equalsIgnoreCase(tipoBusca)) {
            spec = spec.and(ClienteSpecification.numeroDocumentoEquals(valorBusca));
        } else { throw new IllegalArgumentException("Tipo de busca inválido: " + tipoBusca); }

        Optional<Clientes> clienteOpt = clienteRepository.findAll(spec).stream().findFirst();
        if (clienteOpt.isEmpty()) { throw new ClientesNotFoundException("Cliente não encontrado para os critérios fornecidos."); }
        Clientes cliente = clienteOpt.get();
        ClienteId clienteId = cliente.getId();

        // 2. Mapear Dados Básicos (sem alterações)
        ClienteRelatorioCompletoDTO relatorio = new ClienteRelatorioCompletoDTO();
        relatorio.setCliente(clienteMapper.toResponseDto(cliente));

        // 3. Buscar Veículos Associados (Usa o método correto do repo)
        List<ClienteVeiculo> clienteVeiculos = clienteVeiculoRepository.findByCliente_Id(clienteId); // CORRIGIDO
        List<VeiculoResponseDto> veiculosDto = clienteVeiculos.stream()
                .map(cv -> veiculoMapper.toResponseDto(cv.getVeiculo()))
                .collect(Collectors.toList());
        relatorio.setVeiculos(veiculosDto);
        List<Long> veiculoIds = clienteVeiculos.stream().map(cv -> cv.getVeiculo().getId()).collect(Collectors.toList());

        // 4. Buscar Agendamentos (Usa o método correto do repo e ordena antes)
        if (!veiculoIds.isEmpty()) {
            List<AgendaVeiculo> agendaVeiculos = agendaVeiculoRepository.findByVeiculoIdIn(veiculoIds); // CORRIGIDO
            List<AgendaSimplificadoDTO> agendamentosDto = agendaVeiculos.stream()
                    .sorted(Comparator.comparing( (AgendaVeiculo av) -> av.getAgenda().getDataAgendamento(), Comparator.nullsLast(Comparator.reverseOrder()) ))
                    .map(av -> {
                        AgendaSimplificadoDTO dto = new AgendaSimplificadoDTO();
                        dto.setId(av.getAgenda().getId());
                        dto.setDataAgendamento(av.getAgenda().getDataAgendamento() != null ? av.getAgenda().getDataAgendamento().format(dateFormatter) : null);
                        dto.setObservacao(av.getAgenda().getObservacao());
                        dto.setVeiculoPlaca(av.getVeiculo().getPlaca());
                        return dto;
                    })
                    .collect(Collectors.toList());
            relatorio.setAgendamentos(agendamentosDto);
            relatorio.setTotalAgendamentos(agendamentosDto.size());
        } else {
            relatorio.setAgendamentos(Collections.emptyList());
            relatorio.setTotalAgendamentos(0);
        }

        // 5. Buscar Serviços de Oficina e Peças (Usa os métodos corretos dos repos e ordena antes)
        if (!veiculoIds.isEmpty()) {
            List<OficinaVeiculo> oficinaVeiculos = oficinaVeiculoRepository.findByVeiculoIdIn(veiculoIds); // CORRIGIDO
            List<OficinaServicoDTO> servicosDto = oficinaVeiculos.stream()
                    .sorted(Comparator.comparing( (OficinaVeiculo ov) -> ov.getOficina().getDataOficina(), Comparator.nullsLast(Comparator.reverseOrder()) ))
                    .map(ov -> {
                        Oficina oficina = ov.getOficina();
                        OficinaServicoDTO dto = new OficinaServicoDTO();
                        dto.setIdOficina(oficina.getId());
                        dto.setDataOficina(oficina.getDataOficina() != null ? oficina.getDataOficina().format(dateFormatter) : null);
                        dto.setDescricaoProblema(oficina.getDescricaoProblema());
                        dto.setDiagnostico(oficina.getDiagnostico());
                        dto.setPartesAfetadas(oficina.getPartesAfetadas());
                        dto.setHorasTrabalhadas(oficina.getHorasTrabalhadas());
                        dto.setVeiculoPlaca(ov.getVeiculo().getPlaca());

                        List<OficinaPeca> oficinaPecas = oficinaPecaRepository.findByOficinaId(oficina.getId()); // CORRIGIDO
                        List<PecaUtilizadaDTO> pecasDto = oficinaPecas.stream()
                                .map(op -> {
                                    Pecas peca = op.getPeca();
                                    PecaUtilizadaDTO pecaDto = new PecaUtilizadaDTO();
                                    pecaDto.setIdPeca(peca.getId());
                                    pecaDto.setDescricaoPeca(peca.getDescricao());
                                    pecaDto.setFabricante(peca.getFabricante());
                                    return pecaDto;
                                })
                                .collect(Collectors.toList());
                        dto.setPecasUtilizadas(pecasDto);
                        return dto;
                    })
                    .collect(Collectors.toList());
            relatorio.setServicosOficina(servicosDto);
        } else {
            relatorio.setServicosOficina(Collections.emptyList());
        }

        // 6. Buscar Orçamentos (Já estava correto, apenas garantindo import)
        List<ClienteOrcamento> clienteOrcamentos = clienteOrcamentoRepository.findByCliente_Id(clienteId);
        List<OrcamentoResponseDto> orcamentosDto = clienteOrcamentos.stream()
                .map(co -> orcamentoMapper.toResponseDto(co.getOrcamento()))
                .sorted(Comparator.comparing( OrcamentoResponseDto::getDataOrcamento, Comparator.nullsLast(Comparator.reverseOrder()) ))
                .collect(Collectors.toList());
        relatorio.setOrcamentos(orcamentosDto);

        // 7. Buscar Pagamentos (Já estava correto, apenas garantindo import)
        List<ClientePagamento> clientePagamentos = clientePagamentoRepository.findByCliente_Id(clienteId);
        List<PagamentoResponseDto> pagamentosDto = clientePagamentos.stream()
                .map(cp -> pagamentoMapper.toResponseDto(cp.getPagamento()))
                .sorted(Comparator.comparing( PagamentoResponseDto::getDataPagamento, Comparator.nullsLast(Comparator.reverseOrder()) ))
                .collect(Collectors.toList());
        relatorio.setPagamentos(pagamentosDto);

        log.info("Relatório completo gerado com sucesso para cliente ID: {}", clienteId);
        return relatorio;
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\service\security\AutenticarUserDetailsService.java   |   package br.com.fiap.service.security   |   class AutenticarUserDetailsService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.service.security;

import br.com.fiap.model.autenticar.Autenticar;
import br.com.fiap.repository.AutenticarRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.ArrayList; // Usaremos uma lista vazia para authorities por enquanto

@Service // Marca esta classe como um serviço gerenciado pelo Spring
public class AutenticarUserDetailsService implements UserDetailsService {

    @Autowired
    private AutenticarRepository autenticarRepository; // Injete seu repositório

    // Método que o Spring Security chama para carregar os detalhes do usuário
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // Busca o usuário no seu banco de dados usando o repositório
        // Você precisará adicionar um método findByUsuario(String usuario) no seu AutenticarRepository
        Autenticar autenticar = autenticarRepository.findByUsuario(username)
                .orElseThrow(() -> new UsernameNotFoundException("Usuário não encontrado: " + username));

        // Constrói um objeto UserDetails com os dados do usuário encontrado
        // Por enquanto, não temos papéis/autoridades no seu modelo Autenticar, então usaremos uma lista vazia
        return new User(
                autenticar.getUsuario(), // Nome de usuário
                autenticar.getSenha(),   // Senha (já hashed)
                new ArrayList<>()        // Lista de Authorities/Papéis (vazia por enquanto)
        );
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\service\veiculo\VeiculoService.java   |   package br.com.fiap.service.veiculo   |   class VeiculoService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/main/java/br/com/fiap/service/veiculo/VeiculoService.java
package br.com.fiap.service.veiculo;

import br.com.fiap.dto.veiculo.VeiculoRequestDto;
import br.com.fiap.dto.veiculo.VeiculoResponseDto;
import java.util.List;

public interface VeiculoService {
    List<VeiculoResponseDto> findAll();
    VeiculoResponseDto findById(Long id);
    VeiculoResponseDto create(VeiculoRequestDto veiculoDto);
    VeiculoResponseDto update(Long id, VeiculoRequestDto veiculoDto);
    void deleteById(Long id);

    // <<< NOVA ASSINATURA PARA BUSCA >>>
    List<VeiculoResponseDto> buscarVeiculos(String placa, String modelo, String proprietario);
    // ---------------------------------
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\service\veiculo\VeiculoServiceImpl.java   |   package br.com.fiap.service.veiculo   |   class VeiculoServiceImpl
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/main/java/br/com/fiap/service/veiculo/VeiculoServiceImpl.java
package br.com.fiap.service.veiculo;

// --- Imports ---
import br.com.fiap.dto.veiculo.VeiculoRequestDto;
import br.com.fiap.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.exception.VeiculoNotFoundException;
import br.com.fiap.mapper.VeiculoMapper;
import br.com.fiap.model.Veiculo;
import br.com.fiap.repository.VeiculoRepository;
import br.com.fiap.repository.specification.VeiculoSpecification;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;
import java.util.stream.Collectors;
// ---------------

@Service
public class VeiculoServiceImpl implements VeiculoService {

    private static final Logger log = LoggerFactory.getLogger(VeiculoServiceImpl.class);
    private final VeiculoRepository veiculoRepository;
    private final VeiculoMapper veiculoMapper;

    @Autowired
    public VeiculoServiceImpl(VeiculoRepository veiculoRepository, VeiculoMapper veiculoMapper) {
        this.veiculoRepository = veiculoRepository;
        this.veiculoMapper = veiculoMapper;
    }

    // --- IMPLEMENTAÇÃO DO MÉTODO DE BUSCA ---
    @Override
    @Transactional(readOnly = true)
    public List<VeiculoResponseDto> buscarVeiculos(String placa, String modelo, String proprietario) {
        log.info("Buscando veículos com critérios: placa='{}', modelo='{}', proprietario='{}'", placa, modelo, proprietario);

        // Combina as especificações baseadas nos parâmetros não nulos/vazios
        Specification<Veiculo> spec = Specification.where(null); // Base neutra
        if (placa != null && !placa.isBlank()) {
            spec = spec.and(VeiculoSpecification.placaContains(placa));
        }
        if (modelo != null && !modelo.isBlank()) {
            spec = spec.and(VeiculoSpecification.modeloContains(modelo));
        }
        if (proprietario != null && !proprietario.isBlank()) {
            spec = spec.and(VeiculoSpecification.proprietarioContains(proprietario));
        }

        // Validação para evitar busca sem critério (se desejado)
        if ((placa == null || placa.isBlank()) && (modelo == null || modelo.isBlank()) && (proprietario == null || proprietario.isBlank())) {
            log.warn("Busca de veículos chamada sem critérios válidos.");
            return List.of(); // Retorna lista vazia
        }

        List<Veiculo> veiculosEncontrados = veiculoRepository.findAll(spec); // Usa findAll com Specification
        log.info("Encontrados {} veículos para os critéiros.", veiculosEncontrados.size());

        return veiculosEncontrados.stream()
                .map(veiculoMapper::toResponseDto)
                .collect(Collectors.toList());
    }
    // <<< FIM DA IMPLEMENTAÇÃO DA BUSCA >>>


    // --- Métodos CRUD e Auxiliar (como antes) ---
    @Override
    @Transactional(readOnly = true)
    public List<VeiculoResponseDto> findAll() {
        log.info("Buscando todos os veículos");
        return veiculoRepository.findAll().stream()
                .map(veiculoMapper::toResponseDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public VeiculoResponseDto findById(Long id) {
        log.info("Buscando veículo por ID: {}", id);
        Veiculo veiculo = findVeiculoById(id);
        return veiculoMapper.toResponseDto(veiculo);
    }

    @Override
    @Transactional
    public VeiculoResponseDto create(VeiculoRequestDto veiculoDto) {
        log.info("Criando novo veículo, placa: {}", veiculoDto.getPlaca());
        try {
            Veiculo veiculo = veiculoMapper.toEntity(veiculoDto);
            Veiculo savedVeiculo = veiculoRepository.save(veiculo);
            log.info("Veículo criado com ID: {}", savedVeiculo.getId());
            return veiculoMapper.toResponseDto(savedVeiculo);
        } catch (Exception e) {
            log.error("Erro ao criar veículo: {}", e.getMessage(), e);
            throw new RuntimeException("Falha ao criar veículo", e);
        }
    }

    @Override
    @Transactional
    public VeiculoResponseDto update(Long id, VeiculoRequestDto veiculoDto) {
        log.info("Atualizando veículo com ID: {}", id);
        Veiculo existingVeiculo = findVeiculoById(id);
        veiculoMapper.updateEntityFromDto(veiculoDto, existingVeiculo);
        Veiculo updatedVeiculo = veiculoRepository.save(existingVeiculo);
        log.info("Veículo atualizado com ID: {}", updatedVeiculo.getId());
        return veiculoMapper.toResponseDto(updatedVeiculo);
    }

    @Override
    @Transactional
    public void deleteById(Long id) {
        log.info("Deletando veículo com ID: {}", id);
        Veiculo veiculo = findVeiculoById(id); // Verifica existência
        try {
            veiculoRepository.delete(veiculo);
            log.info("Veículo deletado com ID: {}", id);
        } catch (Exception e) {
            log.error("Erro ao deletar veículo com ID {}: {}", id, e.getMessage(), e);
            throw new RuntimeException("Falha ao deletar veículo com ID: " + id, e);
        }
    }

    // --- Método auxiliar ---
    private Veiculo findVeiculoById(Long id) {
        return veiculoRepository.findById(id)
                .orElseThrow(() -> new VeiculoNotFoundException("Veículo não encontrado com ID: " + id));
    }
}

