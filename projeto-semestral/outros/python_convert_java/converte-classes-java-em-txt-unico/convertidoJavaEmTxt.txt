// Script: converte-classes-java-em-txt-unico (v3)
// Data de criação do arquivo de saída: 2025-05-12 15:58:34

// Estrutura de diretórios do projeto:
src/
    main/
        java/
            br/
                com/
                    fiap/
                        mottu/
                            config/
                            controller/
                            dto/
                                box/
                                cliente/
                                contato/
                                endereco/
                                patio/
                                rastreamento/
                                veiculo/
                                zona/
                            exception/
                                handler/
                            external/
                                outro/
                                viacep/
                            filter/
                            mapper/
                            model/
                                relacionamento/
                            repository/
                                relacionamento/
                            service/
                            specification/
        resources/
            static/
            templates/
    test/
        java/
            br/
                com/
                    fiap/
                        mottu/

// Arquivos encontrados (FQN => caminho relativo):
// br.com.fiap.mottu.MottuApplication => main\java\br\com\fiap\mottu\MottuApplication.java
// br.com.fiap.mottu.config.CorsConfig => main\java\br\com\fiap\mottu\config\CorsConfig.java
// br.com.fiap.mottu.config.OpenApiConfig => main\java\br\com\fiap\mottu\config\OpenApiConfig.java
// br.com.fiap.mottu.config.SwaggerBrowserLauncher => main\java\br\com\fiap\mottu\config\SwaggerBrowserLauncher.java
// br.com.fiap.mottu.controller.BoxController => main\java\br\com\fiap\mottu\controller\BoxController.java
// br.com.fiap.mottu.controller.ClienteController => main\java\br\com\fiap\mottu\controller\ClienteController.java
// br.com.fiap.mottu.controller.ContatoController => main\java\br\com\fiap\mottu\controller\ContatoController.java
// br.com.fiap.mottu.controller.EnderecoController => main\java\br\com\fiap\mottu\controller\EnderecoController.java
// br.com.fiap.mottu.controller.PatioController => main\java\br\com\fiap\mottu\controller\PatioController.java
// br.com.fiap.mottu.controller.RastreamentoController => main\java\br\com\fiap\mottu\controller\RastreamentoController.java
// br.com.fiap.mottu.controller.VeiculoController => main\java\br\com\fiap\mottu\controller\VeiculoController.java
// br.com.fiap.mottu.controller.ZonaController => main\java\br\com\fiap\mottu\controller\ZonaController.java
// br.com.fiap.mottu.dto.box.BoxRequestDto => main\java\br\com\fiap\mottu\dto\box\BoxRequestDto.java
// br.com.fiap.mottu.dto.box.BoxResponseDto => main\java\br\com\fiap\mottu\dto\box\BoxResponseDto.java
// br.com.fiap.mottu.dto.cliente.ClienteRequestDto => main\java\br\com\fiap\mottu\dto\cliente\ClienteRequestDto.java
// br.com.fiap.mottu.dto.cliente.ClienteResponseDto => main\java\br\com\fiap\mottu\dto\cliente\ClienteResponseDto.java
// br.com.fiap.mottu.dto.contato.ContatoRequestDto => main\java\br\com\fiap\mottu\dto\contato\ContatoRequestDto.java
// br.com.fiap.mottu.dto.contato.ContatoResponseDto => main\java\br\com\fiap\mottu\dto\contato\ContatoResponseDto.java
// br.com.fiap.mottu.dto.endereco.EnderecoRequestDto => main\java\br\com\fiap\mottu\dto\endereco\EnderecoRequestDto.java
// br.com.fiap.mottu.dto.endereco.EnderecoResponseDto => main\java\br\com\fiap\mottu\dto\endereco\EnderecoResponseDto.java
// br.com.fiap.mottu.dto.patio.PatioRequestDto => main\java\br\com\fiap\mottu\dto\patio\PatioRequestDto.java
// br.com.fiap.mottu.dto.patio.PatioResponseDto => main\java\br\com\fiap\mottu\dto\patio\PatioResponseDto.java
// br.com.fiap.mottu.dto.rastreamento.RastreamentoRequestDto => main\java\br\com\fiap\mottu\dto\rastreamento\RastreamentoRequestDto.java
// br.com.fiap.mottu.dto.rastreamento.RastreamentoResponseDto => main\java\br\com\fiap\mottu\dto\rastreamento\RastreamentoResponseDto.java
// br.com.fiap.mottu.dto.veiculo.VeiculoLocalizacaoResponseDto => main\java\br\com\fiap\mottu\dto\veiculo\VeiculoLocalizacaoResponseDto.java
// br.com.fiap.mottu.dto.veiculo.VeiculoRequestDto => main\java\br\com\fiap\mottu\dto\veiculo\VeiculoRequestDto.java
// br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto => main\java\br\com\fiap\mottu\dto\veiculo\VeiculoResponseDto.java
// br.com.fiap.mottu.dto.zona.ZonaRequestDto => main\java\br\com\fiap\mottu\dto\zona\ZonaRequestDto.java
// br.com.fiap.mottu.dto.zona.ZonaResponseDto => main\java\br\com\fiap\mottu\dto\zona\ZonaResponseDto.java
// br.com.fiap.mottu.exception.DuplicatedResourceException => main\java\br\com\fiap\mottu\exception\DuplicatedResourceException.java
// br.com.fiap.mottu.exception.InvalidInputException => main\java\br\com\fiap\mottu\exception\InvalidInputException.java
// br.com.fiap.mottu.exception.ResourceNotFoundException => main\java\br\com\fiap\mottu\exception\ResourceNotFoundException.java
// br.com.fiap.mottu.exception.handler.GlobalExceptionHandler => main\java\br\com\fiap\mottu\exception\handler\GlobalExceptionHandler.java
// br.com.fiap.mottu.external.viacep.ViaCepResponse => main\java\br\com\fiap\mottu\external\viacep\ViaCepResponse.java
// br.com.fiap.mottu.external.viacep.ViaCepService => main\java\br\com\fiap\mottu\external\viacep\ViaCepService.java
// br.com.fiap.mottu.filter.BoxFilter => main\java\br\com\fiap\mottu\filter\BoxFilter.java
// br.com.fiap.mottu.filter.ClienteFilter => main\java\br\com\fiap\mottu\filter\ClienteFilter.java
// br.com.fiap.mottu.filter.ContatoFilter => main\java\br\com\fiap\mottu\filter\ContatoFilter.java
// br.com.fiap.mottu.filter.EnderecoFilter => main\java\br\com\fiap\mottu\filter\EnderecoFilter.java
// br.com.fiap.mottu.filter.PatioFilter => main\java\br\com\fiap\mottu\filter\PatioFilter.java
// br.com.fiap.mottu.filter.RastreamentoFilter => main\java\br\com\fiap\mottu\filter\RastreamentoFilter.java
// br.com.fiap.mottu.filter.VeiculoFilter => main\java\br\com\fiap\mottu\filter\VeiculoFilter.java
// br.com.fiap.mottu.filter.ZonaFilter => main\java\br\com\fiap\mottu\filter\ZonaFilter.java
// br.com.fiap.mottu.mapper.BoxMapper => main\java\br\com\fiap\mottu\mapper\BoxMapper.java
// br.com.fiap.mottu.mapper.ClienteMapper => main\java\br\com\fiap\mottu\mapper\ClienteMapper.java
// br.com.fiap.mottu.mapper.ContatoMapper => main\java\br\com\fiap\mottu\mapper\ContatoMapper.java
// br.com.fiap.mottu.mapper.EnderecoMapper => main\java\br\com\fiap\mottu\mapper\EnderecoMapper.java
// br.com.fiap.mottu.mapper.PatioMapper => main\java\br\com\fiap\mottu\mapper\PatioMapper.java
// br.com.fiap.mottu.mapper.RastreamentoMapper => main\java\br\com\fiap\mottu\mapper\RastreamentoMapper.java
// br.com.fiap.mottu.mapper.VeiculoMapper => main\java\br\com\fiap\mottu\mapper\VeiculoMapper.java
// br.com.fiap.mottu.mapper.ZonaMapper => main\java\br\com\fiap\mottu\mapper\ZonaMapper.java
// br.com.fiap.mottu.model.Box => main\java\br\com\fiap\mottu\model\Box.java
// br.com.fiap.mottu.model.Cliente => main\java\br\com\fiap\mottu\model\Cliente.java
// br.com.fiap.mottu.model.Contato => main\java\br\com\fiap\mottu\model\Contato.java
// br.com.fiap.mottu.model.Endereco => main\java\br\com\fiap\mottu\model\Endereco.java
// br.com.fiap.mottu.model.Patio => main\java\br\com\fiap\mottu\model\Patio.java
// br.com.fiap.mottu.model.Rastreamento => main\java\br\com\fiap\mottu\model\Rastreamento.java
// br.com.fiap.mottu.model.Veiculo => main\java\br\com\fiap\mottu\model\Veiculo.java
// br.com.fiap.mottu.model.Zona => main\java\br\com\fiap\mottu\model\Zona.java
// br.com.fiap.mottu.model.relacionamento.ClienteVeiculo => main\java\br\com\fiap\mottu\model\relacionamento\ClienteVeiculo.java
// br.com.fiap.mottu.model.relacionamento.ClienteVeiculoId => main\java\br\com\fiap\mottu\model\relacionamento\ClienteVeiculoId.java
// br.com.fiap.mottu.model.relacionamento.ContatoPatio => main\java\br\com\fiap\mottu\model\relacionamento\ContatoPatio.java
// br.com.fiap.mottu.model.relacionamento.ContatoPatioId => main\java\br\com\fiap\mottu\model\relacionamento\ContatoPatioId.java
// br.com.fiap.mottu.model.relacionamento.EnderecoPatio => main\java\br\com\fiap\mottu\model\relacionamento\EnderecoPatio.java
// br.com.fiap.mottu.model.relacionamento.EnderecoPatioId => main\java\br\com\fiap\mottu\model\relacionamento\EnderecoPatioId.java
// br.com.fiap.mottu.model.relacionamento.PatioBox => main\java\br\com\fiap\mottu\model\relacionamento\PatioBox.java
// br.com.fiap.mottu.model.relacionamento.PatioBoxId => main\java\br\com\fiap\mottu\model\relacionamento\PatioBoxId.java
// br.com.fiap.mottu.model.relacionamento.VeiculoBox => main\java\br\com\fiap\mottu\model\relacionamento\VeiculoBox.java
// br.com.fiap.mottu.model.relacionamento.VeiculoBoxId => main\java\br\com\fiap\mottu\model\relacionamento\VeiculoBoxId.java
// br.com.fiap.mottu.model.relacionamento.VeiculoPatio => main\java\br\com\fiap\mottu\model\relacionamento\VeiculoPatio.java
// br.com.fiap.mottu.model.relacionamento.VeiculoPatioId => main\java\br\com\fiap\mottu\model\relacionamento\VeiculoPatioId.java
// br.com.fiap.mottu.model.relacionamento.VeiculoRastreamento => main\java\br\com\fiap\mottu\model\relacionamento\VeiculoRastreamento.java
// br.com.fiap.mottu.model.relacionamento.VeiculoRastreamentoId => main\java\br\com\fiap\mottu\model\relacionamento\VeiculoRastreamentoId.java
// br.com.fiap.mottu.model.relacionamento.VeiculoZona => main\java\br\com\fiap\mottu\model\relacionamento\VeiculoZona.java
// br.com.fiap.mottu.model.relacionamento.VeiculoZonaId => main\java\br\com\fiap\mottu\model\relacionamento\VeiculoZonaId.java
// br.com.fiap.mottu.model.relacionamento.ZonaBox => main\java\br\com\fiap\mottu\model\relacionamento\ZonaBox.java
// br.com.fiap.mottu.model.relacionamento.ZonaBoxId => main\java\br\com\fiap\mottu\model\relacionamento\ZonaBoxId.java
// br.com.fiap.mottu.model.relacionamento.ZonaPatio => main\java\br\com\fiap\mottu\model\relacionamento\ZonaPatio.java
// br.com.fiap.mottu.model.relacionamento.ZonaPatioId => main\java\br\com\fiap\mottu\model\relacionamento\ZonaPatioId.java
// br.com.fiap.mottu.repository.BoxRepository => main\java\br\com\fiap\mottu\repository\BoxRepository.java
// br.com.fiap.mottu.repository.ClienteRepository => main\java\br\com\fiap\mottu\repository\ClienteRepository.java
// br.com.fiap.mottu.repository.ContatoRepository => main\java\br\com\fiap\mottu\repository\ContatoRepository.java
// br.com.fiap.mottu.repository.EnderecoRepository => main\java\br\com\fiap\mottu\repository\EnderecoRepository.java
// br.com.fiap.mottu.repository.PatioRepository => main\java\br\com\fiap\mottu\repository\PatioRepository.java
// br.com.fiap.mottu.repository.RastreamentoRepository => main\java\br\com\fiap\mottu\repository\RastreamentoRepository.java
// br.com.fiap.mottu.repository.VeiculoRepository => main\java\br\com\fiap\mottu\repository\VeiculoRepository.java
// br.com.fiap.mottu.repository.ZonaRepository => main\java\br\com\fiap\mottu\repository\ZonaRepository.java
// br.com.fiap.mottu.repository.relacionamento.ClienteVeiculoRepository => main\java\br\com\fiap\mottu\repository\relacionamento\ClienteVeiculoRepository.java
// br.com.fiap.mottu.repository.relacionamento.ContatoPatioRepository => main\java\br\com\fiap\mottu\repository\relacionamento\ContatoPatioRepository.java
// br.com.fiap.mottu.repository.relacionamento.EnderecoPatioRepository => main\java\br\com\fiap\mottu\repository\relacionamento\EnderecoPatioRepository.java
// br.com.fiap.mottu.repository.relacionamento.PatioBoxRepository => main\java\br\com\fiap\mottu\repository\relacionamento\PatioBoxRepository.java
// br.com.fiap.mottu.repository.relacionamento.VeiculoBoxRepository => main\java\br\com\fiap\mottu\repository\relacionamento\VeiculoBoxRepository.java
// br.com.fiap.mottu.repository.relacionamento.VeiculoPatioRepository => main\java\br\com\fiap\mottu\repository\relacionamento\VeiculoPatioRepository.java
// br.com.fiap.mottu.repository.relacionamento.VeiculoRastreamentoRepository => main\java\br\com\fiap\mottu\repository\relacionamento\VeiculoRastreamentoRepository.java
// br.com.fiap.mottu.repository.relacionamento.VeiculoZonaRepository => main\java\br\com\fiap\mottu\repository\relacionamento\VeiculoZonaRepository.java
// br.com.fiap.mottu.repository.relacionamento.ZonaBoxRepository => main\java\br\com\fiap\mottu\repository\relacionamento\ZonaBoxRepository.java
// br.com.fiap.mottu.repository.relacionamento.ZonaPatioRepository => main\java\br\com\fiap\mottu\repository\relacionamento\ZonaPatioRepository.java
// br.com.fiap.mottu.service.BoxService => main\java\br\com\fiap\mottu\service\BoxService.java
// br.com.fiap.mottu.service.ClienteService => main\java\br\com\fiap\mottu\service\ClienteService.java
// br.com.fiap.mottu.service.ContatoService => main\java\br\com\fiap\mottu\service\ContatoService.java
// br.com.fiap.mottu.service.EnderecoService => main\java\br\com\fiap\mottu\service\EnderecoService.java
// br.com.fiap.mottu.service.PatioService => main\java\br\com\fiap\mottu\service\PatioService.java
// br.com.fiap.mottu.service.RastreamentoService => main\java\br\com\fiap\mottu\service\RastreamentoService.java
// br.com.fiap.mottu.service.VeiculoService => main\java\br\com\fiap\mottu\service\VeiculoService.java
// br.com.fiap.mottu.service.ZonaService => main\java\br\com\fiap\mottu\service\ZonaService.java
// br.com.fiap.mottu.specification.BoxSpecification => main\java\br\com\fiap\mottu\specification\BoxSpecification.java
// br.com.fiap.mottu.specification.ClienteSpecification => main\java\br\com\fiap\mottu\specification\ClienteSpecification.java
// br.com.fiap.mottu.specification.ContatoSpecification => main\java\br\com\fiap\mottu\specification\ContatoSpecification.java
// br.com.fiap.mottu.specification.EnderecoSpecification => main\java\br\com\fiap\mottu\specification\EnderecoSpecification.java
// br.com.fiap.mottu.specification.PatioSpecification => main\java\br\com\fiap\mottu\specification\PatioSpecification.java
// br.com.fiap.mottu.specification.RastreamentoSpecification => main\java\br\com\fiap\mottu\specification\RastreamentoSpecification.java
// br.com.fiap.mottu.specification.VeiculoSpecification => main\java\br\com\fiap\mottu\specification\VeiculoSpecification.java
// br.com.fiap.mottu.specification.ZonaSpecification => main\java\br\com\fiap\mottu\specification\ZonaSpecification.java
// br.com.fiap.mottu.MottuApplicationTests => test\java\br\com\fiap\mottu\MottuApplicationTests.java

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\MottuApplication.java   |   package br.com.fiap.mottu   |   class MottuApplication
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu; // Este é o pacote correto

// import io.swagger.v3.oas.annotations.OpenAPIDefinition;
// import io.swagger.v3.oas.annotations.info.Info;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.web.client.RestTemplate; // <-- Importar RestTemplate
import org.springframework.web.reactive.function.client.WebClient; // <-- Adicione esta importação AQUI!


@EnableJpaRepositories
@SpringBootApplication
@EnableCaching
// @OpenAPIDefinition(info = @Info(title="CHALLENGE-2025-FIAP-TEMMU-METAMIND SOLUTIONS-1.0", description = "CHALLENGE FIAP 2025", version = "v1"))
public class MottuApplication {

	public static void main(String[] args) {
		SpringApplication.run(MottuApplication.class, args);
	}

	@Bean
	public RestTemplate restTemplate(){
		return new RestTemplate();
	}

	// Adicionado para suportar WebClient no EnderecoService
	@Bean // <-- Adicione este Bean AQUI!
	public WebClient.Builder webClientBuilder() {
		return WebClient.builder();
	}
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\config\CorsConfig.java   |   package br.com.fiap.mottu.config   |   class CorsConfig
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class CorsConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("*")
                .allowedMethods("GET", "POST", "DELETE", "PUT")
                .allowedHeaders("*");
    }

}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\config\OpenApiConfig.java   |   package br.com.fiap.mottu.config   |   class OpenApiConfig
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.servers.Server; // Importação necessária para a classe Server
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.List; // Importação necessária para List

/**
 * Classe de configuração do Springdoc OpenAPI para definir as informações detalhadas da API.
 * Isso inclui título, versão, descrição completa com Markdown, informações de contato da equipe
 * e detalhes de licença, que serão exibidos na interface do Swagger UI.
 */
@Configuration
public class OpenApiConfig {

    private static final Logger log = LoggerFactory.getLogger(OpenApiConfig.class);

    @Bean
    public OpenAPI customOpenAPI() {
        log.info("🔧 Configuração personalizada do OpenAPI inicializada com dados completos.");

        return new OpenAPI()
                .info(new Info()
                        .title("Challenge-2025-FIAP-TEMMU-METAMIND SOLUTIONS") // Título completo do seu projeto
                        .version("1.0") // Versão do seu projeto
                        .description("""
                                **CHALLENGE FIAP 2025**

                                API RESTful para o Challenge Mottu - Gestão de Clientes, Veículos, Endereços, Contatos e mais.

                                **Endereço do Projeto GitHub:** [GitHub - Mottu](https://github.com/carmipa/challenge_2025_1_semestre_mottu)

                                **Turma:** 2TDSPV / 2TDSPZ

                                **Contatos da Equipe:**
                                - Arthur Bispo de Lima RM557568: [RM557568@fiap.com.br](mailto:RM557568@fiap.com.br) | [GitHub](https://github.com/ArthurBispo00)
                                - João Paulo Moreira RM557808: [RM557808@fiap.com.br](mailto:RM557808@fiap.com.br) | [GitHub](https://github.com/joao1015)
                                - Paulo André Carminati RM557881: [RM557881@fiap.com.br](mailto:RM557881@fiap.com.br) | [GitHub](https://github.com/carmipa)
                                """)
                        .contact(new Contact()
                                .name("Metamind Solution") // Nome da equipe
                                .email("RM557568@fiap.com.br") // E-mail de contato da equipe
                                .url("https://github.com/carmipa/challenge_2025_1_semestre_mottu") // URL do projeto ou da equipe
                        )
                        .license(new License()
                                .name("Licença de Uso") // Nome da licença
                                .url("https://github.com/carmipa/challenge_2025_1_semestre_mottu/tree/main/Java_Advanced") // URL da licença
                        )
                )
                // Adicione a seção de servidores se desejar, como você tinha no seu código anterior
                .servers(List.of(new Server().url("http://localhost:8080").description("Servidor Local")));
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\config\SwaggerBrowserLauncher.java   |   package br.com.fiap.mottu.config   |   class SwaggerBrowserLauncher
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.config;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

import java.awt.Desktop;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;

@Component
public class SwaggerBrowserLauncher {

    private static final Logger log = LoggerFactory.getLogger(SwaggerBrowserLauncher.class);

    @Value("${server.port:8080}")
    private String serverPort;

    @Value("${server.servlet.context-path:}")
    private String contextPath;

    @Value("${springdoc.swagger-ui.path:/swagger-ui/index.html}")
    private String swaggerUiPath;

    @Value("${app.launch-swagger-on-startup:true}")
    private boolean launchSwaggerOnStartup;

    @EventListener(ApplicationReadyEvent.class)
    public void launchBrowserOnStartup() {
        if (!launchSwaggerOnStartup) {
            log.info("Abertura automática do Swagger no navegador está desabilitada.");
            return;
        }

        String url = "http://localhost:" + serverPort + contextPath + swaggerUiPath;
        log.info("Tentando abrir o Swagger UI em: {}", url);

        if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {
            try {
                Desktop.getDesktop().browse(new URI(url));
                log.info("Navegador aberto com sucesso na URL do Swagger UI.");
            } catch (IOException | URISyntaxException e) {
                log.error("Erro ao tentar abrir o navegador para o Swagger UI: {}", e.getMessage());
            }
        } else {
            log.warn("Abertura automática do navegador não é suportada neste ambiente. Acesse manualmente: {}", url);
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\controller\BoxController.java   |   package br.com.fiap.mottu.controller   |   class BoxController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.box.BoxRequestDto;
import br.com.fiap.mottu.dto.box.BoxResponseDto;
import br.com.fiap.mottu.filter.BoxFilter;
import br.com.fiap.mottu.service.BoxService;
import br.com.fiap.mottu.mapper.BoxMapper;
import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/boxes")
@Tag(name = "Boxes", description = "Gerenciamento de Boxes")
public class BoxController {

    private static final Logger log = LoggerFactory.getLogger(BoxController.class);
    private final BoxService boxService;
    private final BoxMapper boxMapper;

    @Autowired
    public BoxController(BoxService boxService, BoxMapper boxMapper) {
        this.boxService = boxService;
        this.boxMapper = boxMapper;
    }

    @Operation(
            summary = "Listar todos os boxes",
            description = "Retorna uma lista de todos os boxes cadastrados.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de boxes retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = BoxResponseDto.class)))
            }
    )
    @GetMapping
    public ResponseEntity<List<BoxResponseDto>> listarTodosBoxes() {
        log.info("Buscando todos os boxes.");
        List<BoxResponseDto> boxes = boxService.listarTodosBoxes().stream()
                .map(boxMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} boxes.", boxes.size());
        return ResponseEntity.ok(boxes);
    }

    @Operation(
            summary = "Buscar box por ID",
            description = "Retorna um box específico com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Box encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = BoxResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Box não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Box com ID 1 não encontrado(a).\",\"path\":\"/api/boxes/1\"}")))
            }
    )
    @GetMapping("/{id}")
    public ResponseEntity<BoxResponseDto> buscarBoxPorId(@PathVariable Long id) {
        log.info("Buscando box com ID: {}", id);
        try {
            BoxResponseDto box = boxMapper.toResponseDto(boxService.buscarBoxPorId(id));
            log.info("Box com ID {} encontrado com sucesso.", id);
            return ResponseEntity.ok(box);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar box com ID {}: {}", id, e.getMessage());
            throw e; // O GlobalExceptionHandler cuidará da resposta HTTP
        }
    }

    @Operation(
            summary = "Buscar boxes por filtro",
            description = "Retorna uma lista de boxes que correspondem aos critérios de filtro fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de boxes filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = BoxResponseDto.class)))
            }
    )
    @GetMapping("/search")
    public ResponseEntity<List<BoxResponseDto>> buscarBoxesPorFiltro(BoxFilter filter) {
        log.info("Buscando boxes com filtro: {}", filter);
        List<BoxResponseDto> boxes = boxService.buscarBoxesPorFiltro(filter).stream()
                .map(boxMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} boxes filtrados.", boxes.size());
        return ResponseEntity.ok(boxes);
    }

    @Operation(
            summary = "Criar novo box",
            description = "Cria um novo box com os dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Box criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = BoxResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"Requisição Inválida\",\"message\":\"Mensagem de validação ou erro de input.\",\"path\":\"/api/boxes\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (nome duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Box com nome 'Nome Duplicado' já existe.\",\"path\":\"/api/boxes\"}")))
            }
    )
    @PostMapping
    public ResponseEntity<BoxResponseDto> criarBox(@Valid @RequestBody BoxRequestDto boxRequestDto) {
        log.info("Recebida requisição para criar box: {}", boxRequestDto);
        try {
            BoxResponseDto novoBox = boxMapper.toResponseDto(boxService.criarBox(boxRequestDto));
            log.info("Box criado com sucesso com ID: {}", novoBox.getIdBox());
            return ResponseEntity.status(HttpStatus.CREATED).body(novoBox);
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao criar box - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao criar box: {}", e.getMessage(), e);
            throw e; // O GlobalExceptionHandler pode pegar outras exceções inesperadas
        }
    }

    @Operation(
            summary = "Atualizar box existente",
            description = "Atualiza um box existente com base no ID e nos dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Box atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = BoxResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"Requisição Inválida\",\"message\":\"Mensagem de validação ou erro de input.\",\"path\":\"/api/boxes/1\"}"))),
                    @ApiResponse(responseCode = "404", description = "Box não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Box com ID 1 não encontrado(a).\",\"path\":\"/api/boxes/1\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (nome duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Box com nome 'Nome Duplicado' já existe.\",\"path\":\"/api/boxes/1\"}")))
            }
    )
    @PutMapping("/{id}")
    public ResponseEntity<BoxResponseDto> atualizarBox(@PathVariable Long id, @Valid @RequestBody BoxRequestDto boxRequestDto) {
        log.info("Recebida requisição para atualizar box com ID {}: {}", id, boxRequestDto);
        try {
            BoxResponseDto boxAtualizado = boxMapper.toResponseDto(boxService.atualizarBox(id, boxRequestDto));
            log.info("Box com ID {} atualizado com sucesso.", id);
            return ResponseEntity.ok(boxAtualizado);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao atualizar box - Não encontrado: {}", e.getMessage());
            throw e;
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao atualizar box - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao atualizar box com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Deletar box",
            description = "Exclui um box com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Box deletado com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Box não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Box com ID 1 não encontrado(a).\",\"path\":\"/api/boxes/1\"}")))
            }
    )
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarBox(@PathVariable Long id) {
        log.info("Recebida requisição para deletar box com ID: {}", id);
        try {
            boxService.deletarBox(id);
            log.info("Box com ID {} deletado com sucesso.", id);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao deletar box - Não encontrado: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao deletar box com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\controller\ClienteController.java   |   package br.com.fiap.mottu.controller   |   class ClienteController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.cliente.ClienteRequestDto;
import br.com.fiap.mottu.dto.cliente.ClienteResponseDto;
import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.mottu.filter.ClienteFilter;
import br.com.fiap.mottu.service.ClienteService;
import br.com.fiap.mottu.mapper.ClienteMapper;
import br.com.fiap.mottu.mapper.VeiculoMapper; // Adicione o VeiculoMapper
import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;
import br.com.fiap.mottu.exception.InvalidInputException;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;
import reactor.core.publisher.Mono; // Importe Mono

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/clientes")
@Tag(name = "Clientes", description = "Gerenciamento de Clientes")
public class ClienteController {

    private static final Logger log = LoggerFactory.getLogger(ClienteController.class);
    private final ClienteService clienteService;
    private final ClienteMapper clienteMapper;
    private final VeiculoMapper veiculoMapper; // Injetar VeiculoMapper

    @Autowired
    public ClienteController(ClienteService clienteService, ClienteMapper clienteMapper, VeiculoMapper veiculoMapper) {
        this.clienteService = clienteService;
        this.clienteMapper = clienteMapper;
        this.veiculoMapper = veiculoMapper;
    }

    @Operation(
            summary = "Listar todos os clientes",
            description = "Retorna uma lista de todos os clientes cadastrados.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de clientes retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ClienteResponseDto.class)))
            }
    )
    @GetMapping
    public ResponseEntity<List<ClienteResponseDto>> listarTodosClientes() {
        log.info("Buscando todos os clientes.");
        List<ClienteResponseDto> clientes = clienteService.listarTodosClientes().stream()
                .map(clienteMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} clientes.", clientes.size());
        return ResponseEntity.ok(clientes);
    }

    @Operation(
            summary = "Buscar cliente por ID",
            description = "Retorna um cliente específico com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Cliente encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ClienteResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Cliente não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Cliente com ID 1 não encontrado(a).\",\"path\":\"/api/clientes/1\"}")))
            }
    )
    @GetMapping("/{id}")
    public ResponseEntity<ClienteResponseDto> buscarClientePorId(@PathVariable Long id) {
        log.info("Buscando cliente com ID: {}", id);
        try {
            ClienteResponseDto cliente = clienteMapper.toResponseDto(clienteService.buscarClientePorId(id));
            log.info("Cliente com ID {} encontrado com sucesso.", id);
            return ResponseEntity.ok(cliente);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar cliente com ID {}: {}", id, e.getMessage());
            throw e;
        }
    }

    @Operation(
            summary = "Buscar clientes por filtro",
            description = "Retorna uma lista de clientes que correspondem aos critérios de filtro fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de clientes filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ClienteResponseDto.class)))
            }
    )
    @GetMapping("/search")
    public ResponseEntity<List<ClienteResponseDto>> buscarClientesPorFiltro(ClienteFilter filter) {
        log.info("Buscando clientes com filtro: {}", filter);
        List<ClienteResponseDto> clientes = clienteService.buscarClientesPorFiltro(filter).stream()
                .map(clienteMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} clientes filtrados.", clientes.size());
        return ResponseEntity.ok(clientes);
    }

    @Operation(
            summary = "Criar novo cliente",
            description = "Cria um novo cliente com os dados fornecidos, incluindo endereço e contato. Pode criar novos ou associar existentes.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Cliente criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ClienteResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"Requisição Inválida\",\"message\":\"Mensagem de validação ou erro de input.\",\"path\":\"/api/clientes\"}"))),
                    @ApiResponse(responseCode = "404", description = "Recurso aninhado não encontrado (Ex: Endereço/Contato com ID fornecido não existe)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Endereço com ID 100 não encontrado(a).\",\"path\":\"/api/clientes\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (CPF duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Cliente com CPF '12345678901' já existe.\",\"path\":\"/api/clientes\"}")))
            }
    )
    @PostMapping
    public Mono<ResponseEntity<ClienteResponseDto>> criarCliente(@Valid @RequestBody ClienteRequestDto clienteRequestDto) {
        log.info("Recebida requisição para criar cliente: {}", clienteRequestDto);
        return clienteService.criarCliente(clienteRequestDto)
                .map(clienteCriado -> {
                    log.info("Cliente criado com sucesso com ID: {}", clienteCriado.getIdCliente());
                    return ResponseEntity.status(HttpStatus.CREATED).body(clienteMapper.toResponseDto(clienteCriado));
                })
                .onErrorResume(ResourceNotFoundException.class, e -> {
                    log.error("Erro ao criar cliente - Recurso aninhado não encontrado: {}", e.getMessage());
                    return Mono.error(e);
                })
                .onErrorResume(DuplicatedResourceException.class, e -> {
                    log.error("Erro ao criar cliente - Conflito: {}", e.getMessage());
                    return Mono.error(e);
                })
                .onErrorResume(InvalidInputException.class, e -> {
                    log.error("Erro ao criar cliente - Requisição inválida: {}", e.getMessage());
                    return Mono.error(e);
                })
                .onErrorResume(e -> {
                    log.error("Erro inesperado ao criar cliente: {}", e.getMessage(), e);
                    return Mono.error(e);
                });
    }

    @Operation(
            summary = "Atualizar cliente existente",
            description = "Atualiza um cliente existente com base no ID e nos dados fornecidos. Permite atualizar endereço e contato.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Cliente atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ClienteResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"Requisição Inválida\",\"message\":\"Mensagem de validação ou erro de input.\",\"path\":\"/api/clientes/1\"}"))),
                    @ApiResponse(responseCode = "404", description = "Cliente ou recurso aninhado não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Cliente com ID 1 não encontrado(a).\",\"path\":\"/api/clientes/1\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (CPF duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Cliente com CPF '12345678901' já existe.\",\"path\":\"/api/clientes/1\"}")))
            }
    )
    @PutMapping("/{id}")
    public Mono<ResponseEntity<ClienteResponseDto>> atualizarCliente(@PathVariable Long id, @Valid @RequestBody ClienteRequestDto clienteRequestDto) {
        log.info("Recebida requisição para atualizar cliente com ID {}: {}", id, clienteRequestDto);
        return clienteService.atualizarCliente(id, clienteRequestDto)
                .map(clienteAtualizado -> {
                    log.info("Cliente com ID {} atualizado com sucesso.", id);
                    return ResponseEntity.ok(clienteMapper.toResponseDto(clienteAtualizado));
                })
                .onErrorResume(ResourceNotFoundException.class, e -> {
                    log.error("Erro ao atualizar cliente - Não encontrado: {}", e.getMessage());
                    return Mono.error(e);
                })
                .onErrorResume(DuplicatedResourceException.class, e -> {
                    log.error("Erro ao atualizar cliente - Conflito: {}", e.getMessage());
                    return Mono.error(e);
                })
                .onErrorResume(InvalidInputException.class, e -> {
                    log.error("Erro ao atualizar cliente - Requisição inválida: {}", e.getMessage());
                    return Mono.error(e);
                })
                .onErrorResume(e -> {
                    log.error("Erro inesperado ao atualizar cliente com ID {}: {}", id, e.getMessage(), e);
                    return Mono.error(e);
                });
    }

    @Operation(
            summary = "Deletar cliente",
            description = "Exclui um cliente com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Cliente deletado com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Cliente não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Cliente com ID 1 não encontrado(a).\",\"path\":\"/api/clientes/1\"}")))
            }
    )
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarCliente(@PathVariable Long id) {
        log.info("Recebida requisição para deletar cliente com ID: {}", id);
        try {
            clienteService.deletarCliente(id);
            log.info("Cliente com ID {} deletado com sucesso.", id);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao deletar cliente - Não encontrado: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao deletar cliente com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Associar veículo a um cliente",
            description = "Associa um veículo existente a um cliente existente.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Associação criada com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Cliente ou Veículo não encontrado"),
                    @ApiResponse(responseCode = "409", description = "Associação já existe")
            }
    )
    @PostMapping("/{clienteId}/enderecos/{enderecoId}/contatos/{contatoId}/veiculos/{veiculoId}/associar")
    public ResponseEntity<String> associarClienteVeiculo(
            @PathVariable Long clienteId,
            @PathVariable Long enderecoId,
            @PathVariable Long contatoId,
            @PathVariable Long veiculoId) {
        log.info("Associando veículo ID {} ao cliente ID {} (Endereco: {}, Contato: {}).", veiculoId, clienteId, enderecoId, contatoId);
        try {
            clienteService.associarClienteVeiculo(clienteId, enderecoId, contatoId, veiculoId);
            log.info("Associação entre Cliente {} e Veículo {} (End: {}, Cont: {}) criada com sucesso.", clienteId, veiculoId, enderecoId, contatoId);
            return ResponseEntity.status(HttpStatus.CREATED).body("Associação criada com sucesso.");
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao associar - Recurso não encontrado: {}", e.getMessage());
            throw e;
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao associar - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao associar Cliente {} e Veículo {}: {}", clienteId, veiculoId, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Desassociar veículo de um cliente",
            description = "Remove a associação entre um veículo e um cliente.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Associação removida com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Associação não encontrada")
            }
    )
    @DeleteMapping("/{clienteId}/enderecos/{enderecoId}/contatos/{contatoId}/veiculos/{veiculoId}/desassociar")
    public ResponseEntity<Void> desassociarClienteVeiculo(
            @PathVariable Long clienteId,
            @PathVariable Long enderecoId,
            @PathVariable Long contatoId,
            @PathVariable Long veiculoId) {
        log.info("Desassociando veículo ID {} do cliente ID {} (Endereco: {}, Contato: {}).", veiculoId, clienteId, enderecoId, contatoId);
        try {
            clienteService.desassociarClienteVeiculo(clienteId, enderecoId, contatoId, veiculoId);
            log.info("Associação entre Cliente {} e Veículo {} (End: {}, Cont: {}) removida com sucesso.", clienteId, veiculoId, enderecoId, contatoId);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao desassociar - Associação não encontrada: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao desassociar Cliente {} e Veículo {}: {}", clienteId, veiculoId, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Listar veículos de um cliente",
            description = "Retorna todos os veículos associados a um cliente específico.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Veículos do cliente retornados com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Cliente não encontrado")
            }
    )
    @GetMapping("/{clienteId}/veiculos")
    public ResponseEntity<Set<VeiculoResponseDto>> getVeiculosByClienteId(@PathVariable Long clienteId) {
        log.info("Buscando veículos associados ao cliente com ID: {}", clienteId);
        try {
            Set<VeiculoResponseDto> veiculos = clienteService.getVeiculosByClienteId(clienteId).stream()
                    .map(veiculoMapper::toResponseDto)
                    .collect(Collectors.toSet());
            log.info("Retornando {} veículos para o cliente com ID {}.", veiculos.size(), clienteId);
            return ResponseEntity.ok(veiculos);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar veículos do cliente com ID {}: {}", clienteId, e.getMessage());
            throw e;
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\controller\ContatoController.java   |   package br.com.fiap.mottu.controller   |   class ContatoController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.contato.ContatoRequestDto;
import br.com.fiap.mottu.dto.contato.ContatoResponseDto;
import br.com.fiap.mottu.filter.ContatoFilter;
import br.com.fiap.mottu.service.ContatoService;
import br.com.fiap.mottu.mapper.ContatoMapper;
import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/contatos")
@Tag(name = "Contatos", description = "Gerenciamento de Contatos")
public class ContatoController {

    private static final Logger log = LoggerFactory.getLogger(ContatoController.class);
    private final ContatoService contatoService;
    private final ContatoMapper contatoMapper;

    @Autowired
    public ContatoController(ContatoService contatoService, ContatoMapper contatoMapper) {
        this.contatoService = contatoService;
        this.contatoMapper = contatoMapper;
    }

    @Operation(
            summary = "Listar todos os contatos",
            description = "Retorna uma lista de todos os contatos cadastrados.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de contatos retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ContatoResponseDto.class)))
            }
    )
    @GetMapping
    public ResponseEntity<List<ContatoResponseDto>> listarTodosContatos() {
        log.info("Buscando todos os contatos.");
        List<ContatoResponseDto> contatos = contatoService.listarTodosContatos().stream()
                .map(contatoMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} contatos.", contatos.size());
        return ResponseEntity.ok(contatos);
    }

    @Operation(
            summary = "Buscar contato por ID",
            description = "Retorna um contato específico com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Contato encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ContatoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Contato não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Contato com ID 1 não encontrado(a).\",\"path\":\"/api/contatos/1\"}")))
            }
    )
    @GetMapping("/{id}")
    public ResponseEntity<ContatoResponseDto> buscarContatoPorId(@PathVariable Long id) {
        log.info("Buscando contato com ID: {}", id);
        try {
            ContatoResponseDto contato = contatoMapper.toResponseDto(contatoService.buscarContatoPorId(id));
            log.info("Contato com ID {} encontrado com sucesso.", id);
            return ResponseEntity.ok(contato);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar contato com ID {}: {}", id, e.getMessage());
            throw e;
        }
    }

    @Operation(
            summary = "Buscar contatos por filtro",
            description = "Retorna uma lista de contatos que correspondem aos critérios de filtro fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de contatos filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ContatoResponseDto.class)))
            }
    )
    @GetMapping("/search")
    public ResponseEntity<List<ContatoResponseDto>> buscarContatosPorFiltro(ContatoFilter filter) {
        log.info("Buscando contatos com filtro: {}", filter);
        List<ContatoResponseDto> contatos = contatoService.buscarContatosPorFiltro(filter).stream()
                .map(contatoMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} contatos filtrados.", contatos.size());
        return ResponseEntity.ok(contatos);
    }

    @Operation(
            summary = "Criar novo contato",
            description = "Cria um novo contato com os dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Contato criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ContatoResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"Requisição Inválida\",\"message\":\"Mensagem de validação ou erro de input.\",\"path\":\"/api/contatos\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (email duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Contato com email 'email@duplicado.com' já existe.\",\"path\":\"/api/contatos\"}")))
            }
    )
    @PostMapping
    public ResponseEntity<ContatoResponseDto> criarContato(@Valid @RequestBody ContatoRequestDto contatoRequestDto) {
        log.info("Recebida requisição para criar contato: {}", contatoRequestDto);
        try {
            ContatoResponseDto novoContato = contatoMapper.toResponseDto(contatoService.criarContato(contatoRequestDto));
            log.info("Contato criado com sucesso com ID: {}", novoContato.getIdContato());
            return ResponseEntity.status(HttpStatus.CREATED).body(novoContato);
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao criar contato - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao criar contato: {}", e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Atualizar contato existente",
            description = "Atualiza um contato existente com base no ID e nos dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Contato atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ContatoResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"Requisição Inválida\",\"message\":\"Mensagem de validação ou erro de input.\",\"path\":\"/api/contatos/1\"}"))),
                    @ApiResponse(responseCode = "404", description = "Contato não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Contato com ID 1 não encontrado(a).\",\"path\":\"/api/contatos/1\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (email duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Contato com email 'email@duplicado.com' já existe.\",\"path\":\"/api/contatos/1\"}")))
            }
    )
    @PutMapping("/{id}")
    public ResponseEntity<ContatoResponseDto> atualizarContato(@PathVariable Long id, @Valid @RequestBody ContatoRequestDto contatoRequestDto) {
        log.info("Recebida requisição para atualizar contato com ID {}: {}", id, contatoRequestDto);
        try {
            ContatoResponseDto contatoAtualizado = contatoMapper.toResponseDto(contatoService.atualizarContato(id, contatoRequestDto));
            log.info("Contato com ID {} atualizado com sucesso.", id);
            return ResponseEntity.ok(contatoAtualizado);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao atualizar contato - Não encontrado: {}", e.getMessage());
            throw e;
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao atualizar contato - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao atualizar contato com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Deletar contato",
            description = "Exclui um contato com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Contato deletado com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Contato não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Contato com ID 1 não encontrado(a).\",\"path\":\"/api/contatos/1\"}")))
            }
    )
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarContato(@PathVariable Long id) {
        log.info("Recebida requisição para deletar contato com ID: {}", id);
        try {
            contatoService.deletarContato(id);
            log.info("Contato com ID {} deletado com sucesso.", id);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao deletar contato - Não encontrado: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao deletar contato com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\controller\EnderecoController.java   |   package br.com.fiap.mottu.controller   |   class EnderecoController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.endereco.EnderecoRequestDto;
import br.com.fiap.mottu.dto.endereco.EnderecoResponseDto;
import br.com.fiap.mottu.filter.EnderecoFilter;
import br.com.fiap.mottu.service.EnderecoService;
import br.com.fiap.mottu.mapper.EnderecoMapper;
import br.com.fiap.mottu.exception.ResourceNotFoundException;
import br.com.fiap.mottu.exception.InvalidInputException;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;
import reactor.core.publisher.Mono; // Importe Mono

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/enderecos")
@Tag(name = "Enderecos", description = "Gerenciamento de Endereços")
public class EnderecoController {

    private static final Logger log = LoggerFactory.getLogger(EnderecoController.class);
    private final EnderecoService enderecoService;
    private final EnderecoMapper enderecoMapper;

    @Autowired
    public EnderecoController(EnderecoService enderecoService, EnderecoMapper enderecoMapper) {
        this.enderecoService = enderecoService;
        this.enderecoMapper = enderecoMapper;
    }

    @Operation(
            summary = "Listar todos os endereços",
            description = "Retorna uma lista de todos os endereços cadastrados.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de endereços retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = EnderecoResponseDto.class)))
            }
    )
    @GetMapping
    public ResponseEntity<List<EnderecoResponseDto>> listarTodosEnderecos() {
        log.info("Buscando todos os endereços.");
        List<EnderecoResponseDto> enderecos = enderecoService.listarTodosEnderecos().stream()
                .map(enderecoMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} endereços.", enderecos.size());
        return ResponseEntity.ok(enderecos);
    }

    @Operation(
            summary = "Buscar endereço por ID",
            description = "Retorna um endereço específico com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Endereço encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = EnderecoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Endereço não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Endereço com ID 1 não encontrado(a).\",\"path\":\"/api/enderecos/1\"}")))
            }
    )
    @GetMapping("/{id}")
    public ResponseEntity<EnderecoResponseDto> buscarEnderecoPorId(@PathVariable Long id) {
        log.info("Buscando endereço com ID: {}", id);
        try {
            EnderecoResponseDto endereco = enderecoMapper.toResponseDto(enderecoService.buscarEnderecoPorId(id));
            log.info("Endereço com ID {} encontrado com sucesso.", id);
            return ResponseEntity.ok(endereco);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar endereço com ID {}: {}", id, e.getMessage());
            throw e;
        }
    }

    @Operation(
            summary = "Buscar endereços por filtro",
            description = "Retorna uma lista de endereços que correspondem aos critérios de filtro fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de endereços filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = EnderecoResponseDto.class)))
            }
    )
    @GetMapping("/search")
    public ResponseEntity<List<EnderecoResponseDto>> buscarEnderecosPorFiltro(EnderecoFilter filter) {
        log.info("Buscando endereços com filtro: {}", filter);
        List<EnderecoResponseDto> enderecos = enderecoService.listarTodosEnderecos().stream() // EnderecoService não tem buscarEnderecosPorFiltro
                .map(enderecoMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} endereços filtrados.", enderecos.size());
        return ResponseEntity.ok(enderecos);
    }

    @Operation(
            summary = "Criar novo endereço",
            description = "Cria um novo endereço com os dados fornecidos, buscando informações de CEP na ViaCEP.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Endereço criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = EnderecoResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"Requisição Inválida\",\"message\":\"Mensagem de validação ou erro de input.\",\"path\":\"/api/enderecos\"}"))),
                    @ApiResponse(responseCode = "404", description = "CEP não encontrado na ViaCEP",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"CEP com cep '12345-678' não encontrado(a).\",\"path\":\"/api/enderecos\"}")))
            }
    )
    @PostMapping
    public Mono<ResponseEntity<EnderecoResponseDto>> criarEndereco(@Valid @RequestBody EnderecoRequestDto enderecoRequestDto) {
        log.info("Recebida requisição para criar endereço: {}", enderecoRequestDto);
        return enderecoService.criarEndereco(enderecoRequestDto)
                .map(enderecoCriado -> {
                    log.info("Endereço criado com sucesso com ID: {}", enderecoCriado.getIdEndereco());
                    return ResponseEntity.status(HttpStatus.CREATED).body(enderecoMapper.toResponseDto(enderecoCriado));
                })
                .onErrorResume(ResourceNotFoundException.class, e -> {
                    log.error("Erro ao criar endereço - CEP não encontrado: {}", e.getMessage());
                    return Mono.error(e);
                })
                .onErrorResume(InvalidInputException.class, e -> {
                    log.error("Erro ao criar endereço - Requisição inválida: {}", e.getMessage());
                    return Mono.error(e);
                })
                .onErrorResume(e -> {
                    log.error("Erro inesperado ao criar endereço: {}", e.getMessage(), e);
                    return Mono.error(e);
                });
    }

    @Operation(
            summary = "Atualizar endereço existente",
            description = "Atualiza um endereço existente com base no ID e nos dados fornecidos. Pode buscar informações de CEP na ViaCEP se o CEP for alterado.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Endereço atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = EnderecoResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"Requisição Inválida\",\"message\":\"Mensagem de validação ou erro de input.\",\"path\":\"/api/enderecos/1\"}"))),
                    @ApiResponse(responseCode = "404", description = "Endereço não encontrado ou CEP de atualização não encontrado na ViaCEP",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Endereço com ID 1 não encontrado(a).\",\"path\":\"/api/enderecos/1\"}")))
            }
    )
    @PutMapping("/{id}")
    public Mono<ResponseEntity<EnderecoResponseDto>> atualizarEndereco(@PathVariable Long id, @Valid @RequestBody EnderecoRequestDto enderecoRequestDto) {
        log.info("Recebida requisição para atualizar endereço com ID {}: {}", id, enderecoRequestDto);
        return enderecoService.atualizarEndereco(id, enderecoRequestDto)
                .map(enderecoAtualizado -> {
                    log.info("Endereço com ID {} atualizado com sucesso.", id);
                    return ResponseEntity.ok(enderecoMapper.toResponseDto(enderecoAtualizado));
                })
                .onErrorResume(ResourceNotFoundException.class, e -> {
                    log.error("Erro ao atualizar endereço - Não encontrado: {}", e.getMessage());
                    return Mono.error(e);
                })
                .onErrorResume(InvalidInputException.class, e -> {
                    log.error("Erro ao atualizar endereço - Requisição inválida: {}", e.getMessage());
                    return Mono.error(e);
                })
                .onErrorResume(e -> {
                    log.error("Erro inesperado ao atualizar endereço com ID {}: {}", id, e.getMessage(), e);
                    return Mono.error(e);
                });
    }

    @Operation(
            summary = "Deletar endereço",
            description = "Exclui um endereço com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Endereço deletado com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Endereço não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Endereço com ID 1 não encontrado(a).\",\"path\":\"/api/enderecos/1\"}")))
            }
    )
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarEndereco(@PathVariable Long id) {
        log.info("Recebida requisição para deletar endereço com ID: {}", id);
        try {
            enderecoService.deletarEndereco(id);
            log.info("Endereço com ID {} deletado com sucesso.", id);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao deletar endereço - Não encontrado: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao deletar endereço com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\controller\PatioController.java   |   package br.com.fiap.mottu.controller   |   class PatioController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.patio.PatioRequestDto;
import br.com.fiap.mottu.dto.patio.PatioResponseDto;
import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto; // Para listar veículos associados
import br.com.fiap.mottu.dto.zona.ZonaResponseDto;       // Para listar zonas associadas
import br.com.fiap.mottu.dto.box.BoxResponseDto;    // NOVO: Para listar boxes associados
import br.com.fiap.mottu.dto.contato.ContatoResponseDto; // Para listar contatos associados
import br.com.fiap.mottu.dto.endereco.EnderecoResponseDto; // Para listar endereços associados

import br.com.fiap.mottu.filter.PatioFilter;
import br.com.fiap.mottu.service.PatioService;
import br.com.fiap.mottu.mapper.PatioMapper;
import br.com.fiap.mottu.mapper.VeiculoMapper; // Injetar para mapear Veiculo
import br.com.fiap.mottu.mapper.ZonaMapper;    // Injetar para mapear Zona
import br.com.fiap.mottu.mapper.BoxMapper;           // NOVO: Injetar para mapear Box
import br.com.fiap.mottu.mapper.ContatoMapper;  // Injetar para mapear Contato
import br.com.fiap.mottu.mapper.EnderecoMapper; // Injetar para mapear Endereco

import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/patios")
@Tag(name = "Patios", description = "Gerenciamento de Pátios e Suas Associações")
public class PatioController {

    private static final Logger log = LoggerFactory.getLogger(PatioController.class);
    private final PatioService patioService;
    private final PatioMapper patioMapper;
    private final VeiculoMapper veiculoMapper;
    private final ZonaMapper zonaMapper;
    private final BoxMapper boxMapper;           // NOVO
    private final ContatoMapper contatoMapper;
    private final EnderecoMapper enderecoMapper;

    @Autowired
    public PatioController(PatioService patioService, PatioMapper patioMapper,
                           VeiculoMapper veiculoMapper, ZonaMapper zonaMapper,
                           ContatoMapper contatoMapper, EnderecoMapper enderecoMapper,
                           BoxMapper boxMapper) { // NOVO: Adicione BoxMapper aqui
        this.patioService = patioService;
        this.patioMapper = patioMapper;
        this.veiculoMapper = veiculoMapper;
        this.zonaMapper = zonaMapper;
        this.contatoMapper = contatoMapper;
        this.enderecoMapper = enderecoMapper;
        this.boxMapper = boxMapper;
    }

    @Operation(
            summary = "Listar todos os pátios",
            description = "Retorna uma lista de todos os pátios cadastrados.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de pátios retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = PatioResponseDto.class)))
            }
    )
    @GetMapping
    public ResponseEntity<List<PatioResponseDto>> listarTodosPatios() {
        log.info("Buscando todos os pátios.");
        List<PatioResponseDto> patios = patioService.listarTodosPatios().stream()
                .map(patioMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} pátios.", patios.size());
        return ResponseEntity.ok(patios);
    }

    @Operation(
            summary = "Buscar pátio por ID",
            description = "Retorna um pátio específico com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Pátio encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = PatioResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Pátio não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Pátio com ID 1 não encontrado(a).\",\"path\":\"/api/patios/1\"}")))
            }
    )
    @GetMapping("/{id}")
    public ResponseEntity<PatioResponseDto> buscarPatioPorId(@PathVariable Long id) {
        log.info("Buscando pátio com ID: {}", id);
        try {
            PatioResponseDto patio = patioMapper.toResponseDto(patioService.buscarPatioPorId(id));
            log.info("Pátio com ID {} encontrado com sucesso.", id);
            return ResponseEntity.ok(patio);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar pátio com ID {}: {}", id, e.getMessage());
            throw e;
        }
    }

    @Operation(
            summary = "Buscar pátios por filtro",
            description = "Retorna uma lista de pátios que correspondem aos critérios de filtro fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de pátios filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = PatioResponseDto.class)))
            }
    )
    @GetMapping("/search")
    public ResponseEntity<List<PatioResponseDto>> buscarPatiosPorFiltro(PatioFilter filter) {
        log.info("Buscando pátios com filtro: {}", filter);
        List<PatioResponseDto> patios = patioService.buscarPatiosPorFiltro(filter).stream()
                .map(patioMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} pátios filtrados.", patios.size());
        return ResponseEntity.ok(patios);
    }

    @Operation(
            summary = "Criar novo pátio",
            description = "Cria um novo pátio com os dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Pátio criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = PatioResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"Requisição Inválida\",\"message\":\"Mensagem de validação ou erro de input.\",\"path\":\"/api/patios\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (nome duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Pátio com nome 'Nome Duplicado' já existe.\",\"path\":\"/api/patios\"}")))
            }
    )
    @PostMapping
    public ResponseEntity<PatioResponseDto> criarPatio(@Valid @RequestBody PatioRequestDto patioRequestDto) {
        log.info("Recebida requisição para criar pátio: {}", patioRequestDto);
        try {
            PatioResponseDto novoPatio = patioMapper.toResponseDto(patioService.criarPatio(patioRequestDto));
            log.info("Pátio criado com sucesso com ID: {}", novoPatio.getIdPatio());
            return ResponseEntity.status(HttpStatus.CREATED).body(novoPatio);
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao criar pátio - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao criar pátio: {}", e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Atualizar pátio existente",
            description = "Atualiza um pátio existente com base no ID e nos dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Pátio atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = PatioResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"Requisição Inválida\",\"message\":\"Mensagem de validação ou erro de input.\",\"path\":\"/api/patios/1\"}"))),
                    @ApiResponse(responseCode = "404", description = "Pátio não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Pátio com ID 1 não encontrado(a).\",\"path\":\"/api/patios/1\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (nome duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Pátio com nome 'Nome Duplicado' já existe.\",\"path\":\"/api/patios/1\"}")))
            }
    )
    @PutMapping("/{id}")
    public ResponseEntity<PatioResponseDto> atualizarPatio(@PathVariable Long id, @Valid @RequestBody PatioRequestDto patioRequestDto) {
        log.info("Recebida requisição para atualizar pátio com ID {}: {}", id, patioRequestDto);
        try {
            PatioResponseDto patioAtualizado = patioMapper.toResponseDto(patioService.atualizarPatio(id, patioRequestDto));
            log.info("Pátio com ID {} atualizado com sucesso.", id);
            return ResponseEntity.ok(patioAtualizado);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao atualizar pátio - Não encontrado: {}", e.getMessage());
            throw e;
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao atualizar pátio - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao atualizar pátio com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Deletar pátio",
            description = "Exclui um pátio com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Pátio deletado com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Pátio não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Pátio com ID 1 não encontrado(a).\",\"path\":\"/api/patios/1\"}")))
            }
    )
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarPatio(@PathVariable Long id) {
        log.info("Recebida requisição para deletar pátio com ID: {}", id);
        try {
            patioService.deletarPatio(id);
            log.info("Pátio com ID {} deletado com sucesso.", id);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao deletar pátio - Não encontrado: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao deletar pátio com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }

    // --- Endpoints de Associação de Veículos com Pátio ---
    @Operation(
            summary = "Associar veículo a um pátio",
            description = "Associa um veículo existente a um pátio existente.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Associação criada com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Pátio ou Veículo não encontrado"),
                    @ApiResponse(responseCode = "409", description = "Associação já existe")
            }
    )
    @PostMapping("/{patioId}/veiculos/{veiculoId}/associar")
    public ResponseEntity<String> associarPatioVeiculo(
            @PathVariable Long patioId,
            @PathVariable Long veiculoId) {
        log.info("Associando veículo ID {} ao pátio ID {}.", veiculoId, patioId);
        try {
            patioService.associarPatioVeiculo(patioId, veiculoId);
            log.info("Associação entre Pátio {} e Veículo {} criada com sucesso.", patioId, veiculoId);
            return ResponseEntity.status(HttpStatus.CREATED).body("Associação criada com sucesso.");
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao associar - Recurso não encontrado: {}", e.getMessage());
            throw e;
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao associar - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao associar Pátio {} e Veículo {}: {}", patioId, veiculoId, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Desassociar veículo de um pátio",
            description = "Remove a associação entre um veículo e um pátio.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Associação removida com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Associação não encontrada")
            }
    )
    @DeleteMapping("/{patioId}/veiculos/{veiculoId}/desassociar")
    public ResponseEntity<Void> desassociarPatioVeiculo(
            @PathVariable Long patioId,
            @PathVariable Long veiculoId) {
        log.info("Desassociando veículo ID {} do pátio ID {}.", veiculoId, patioId);
        try {
            patioService.desassociarPatioVeiculo(patioId, veiculoId);
            log.info("Associação entre Pátio {} e Veículo {} removida com sucesso.", patioId, veiculoId);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao desassociar - Associação não encontrada: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao desassociar Pátio {} e Veículo {}: {}", patioId, veiculoId, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Listar veículos de um pátio",
            description = "Retorna todos os veículos associados a um pátio específico.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Veículos do pátio retornados com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Pátio não encontrado")
            }
    )
    @GetMapping("/{patioId}/veiculos")
    public ResponseEntity<Set<VeiculoResponseDto>> getVeiculosByPatioId(@PathVariable Long patioId) {
        log.info("Buscando veículos associados ao pátio com ID: {}", patioId);
        try {
            Set<VeiculoResponseDto> veiculos = patioService.getVeiculosByPatioId(patioId).stream()
                    .map(veiculoMapper::toResponseDto)
                    .collect(Collectors.toSet());
            log.info("Retornando {} veículos para o pátio com ID {}.", veiculos.size(), patioId);
            return ResponseEntity.ok(veiculos);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar veículos do pátio com ID {}: {}", patioId, e.getMessage());
            throw e;
        }
    }


    // --- Endpoints de Associação de Zonas com Pátio ---
    @Operation(
            summary = "Associar zona a um pátio",
            description = "Associa uma zona existente a um pátio existente.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Associação criada com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Pátio ou Zona não encontrada"),
                    @ApiResponse(responseCode = "409", description = "Associação já existe")
            }
    )
    @PostMapping("/{patioId}/zonas/{zonaId}/associar")
    public ResponseEntity<String> associarPatioZona(
            @PathVariable Long patioId,
            @PathVariable Long zonaId) {
        log.info("Associando zona ID {} ao pátio ID {}.", zonaId, patioId);
        try {
            patioService.associarPatioZona(patioId, zonaId);
            log.info("Associação entre Pátio {} e Zona {} criada com sucesso.", patioId, zonaId);
            return ResponseEntity.status(HttpStatus.CREATED).body("Associação criada com sucesso.");
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao associar - Recurso não encontrado: {}", e.getMessage());
            throw e;
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao associar - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao associar Pátio {} e Zona {}: {}", patioId, zonaId, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Desassociar zona de um pátio",
            description = "Remove a associação entre uma zona e um pátio.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Associação removida com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Associação não encontrada")
            }
    )
    @DeleteMapping("/{patioId}/zonas/{zonaId}/desassociar")
    public ResponseEntity<Void> desassociarPatioZona(
            @PathVariable Long patioId,
            @PathVariable Long zonaId) {
        log.info("Desassociando zona ID {} do pátio ID {}.", zonaId, patioId);
        try {
            patioService.desassociarPatioZona(patioId, zonaId);
            log.info("Associação entre Pátio {} e Zona {} removida com sucesso.", patioId, zonaId);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao desassociar - Associação não encontrada: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao desassociar Pátio {} e Zona {}: {}", patioId, zonaId, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Listar zonas de um pátio",
            description = "Retorna todas as zonas associadas a um pátio específico.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Zonas do pátio retornadas com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ZonaResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Pátio não encontrado")
            }
    )
    @GetMapping("/{patioId}/zonas")
    public ResponseEntity<Set<ZonaResponseDto>> getZonasByPatioId(@PathVariable Long patioId) {
        log.info("Buscando zonas associadas ao pátio com ID: {}", patioId);
        try {
            Set<ZonaResponseDto> zonas = patioService.getZonasByPatioId(patioId).stream()
                    .map(zonaMapper::toResponseDto)
                    .collect(Collectors.toSet());
            log.info("Retornando {} zonas para o pátio com ID {}.", zonas.size(), patioId);
            return ResponseEntity.ok(zonas);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar zonas do pátio com ID {}: {}", patioId, e.getMessage());
            throw e;
        }
    }

    // --- Endpoints de Associação de Contatos com Pátio ---
    @Operation(
            summary = "Associar contato a um pátio",
            description = "Associa um contato existente a um pátio existente.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Associação criada com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Pátio ou Contato não encontrado"),
                    @ApiResponse(responseCode = "409", description = "Associação já existe")
            }
    )
    @PostMapping("/{patioId}/contatos/{contatoId}/associar")
    public ResponseEntity<String> associarPatioContato(
            @PathVariable Long patioId,
            @PathVariable Long contatoId) {
        log.info("Associando contato ID {} ao pátio ID {}.", contatoId, patioId);
        try {
            patioService.associarPatioContato(patioId, contatoId);
            log.info("Associação entre Pátio {} e Contato {} criada com sucesso.", patioId, contatoId);
            return ResponseEntity.status(HttpStatus.CREATED).body("Associação criada com sucesso.");
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao associar - Recurso não encontrado: {}", e.getMessage());
            throw e;
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao associar - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao associar Pátio {} e Contato {}: {}", patioId, contatoId, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Desassociar contato de um pátio",
            description = "Remove a associação entre um contato e um pátio.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Associação removida com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Associação não encontrada")
            }
    )
    @DeleteMapping("/{patioId}/contatos/{contatoId}/desassociar")
    public ResponseEntity<Void> desassociarPatioContato(
            @PathVariable Long patioId,
            @PathVariable Long contatoId) {
        log.info("Desassociando contato ID {} do pátio ID {}.", contatoId, patioId);
        try {
            patioService.desassociarPatioContato(patioId, contatoId);
            log.info("Associação entre Pátio {} e Contato {} removida com sucesso.", patioId, contatoId);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao desassociar - Associação não encontrada: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao desassociar Pátio {} e Contato {}: {}", patioId, contatoId, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Listar contatos de um pátio",
            description = "Retorna todos os contatos associados a um pátio específico.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Contatos do pátio retornados com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ContatoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Pátio não encontrado")
            }
    )
    @GetMapping("/{patioId}/contatos")
    public ResponseEntity<Set<ContatoResponseDto>> getContatosByPatioId(@PathVariable Long patioId) {
        log.info("Buscando contatos associados ao pátio com ID: {}", patioId);
        try {
            Set<ContatoResponseDto> contatos = patioService.getContatosByPatioId(patioId).stream()
                    .map(contatoMapper::toResponseDto)
                    .collect(Collectors.toSet());
            log.info("Retornando {} contatos para o pátio com ID {}.", contatos.size(), patioId);
            return ResponseEntity.ok(contatos);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar contatos do pátio com ID {}: {}", patioId, e.getMessage());
            throw e;
        }
    }

    // --- Endpoints de Associação de Endereços com Pátio ---
    @Operation(
            summary = "Associar endereço a um pátio",
            description = "Associa um endereço existente a um pátio existente.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Associação criada com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Pátio ou Endereço não encontrado"),
                    @ApiResponse(responseCode = "409", description = "Associação já existe")
            }
    )
    @PostMapping("/{patioId}/enderecos/{enderecoId}/associar")
    public ResponseEntity<String> associarPatioEndereco(
            @PathVariable Long patioId,
            @PathVariable Long enderecoId) {
        log.info("Associando endereço ID {} ao pátio ID {}.", enderecoId, patioId);
        try {
            patioService.associarPatioEndereco(patioId, enderecoId);
            log.info("Associação entre Pátio {} e Endereço {} criada com sucesso.", patioId, enderecoId);
            return ResponseEntity.status(HttpStatus.CREATED).body("Associação criada com sucesso.");
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao associar - Recurso não encontrado: {}", e.getMessage());
            throw e;
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao associar - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao associar Pátio {} e Endereço {}: {}", patioId, enderecoId, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Desassociar endereço de um pátio",
            description = "Remove a associação entre um endereço e um pátio.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Associação removida com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Associação não encontrada")
            }
    )
    @DeleteMapping("/{patioId}/enderecos/{enderecoId}/desassociar")
    public ResponseEntity<Void> desassociarPatioEndereco(
            @PathVariable Long patioId,
            @PathVariable Long enderecoId) {
        log.info("Desassociando endereço ID {} do pátio ID {}.", enderecoId, patioId);
        try {
            patioService.desassociarPatioEndereco(patioId, enderecoId);
            log.info("Associação entre Pátio {} e Endereço {} removida com sucesso.", patioId, enderecoId);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao desassociar - Associação não encontrada: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao desassociar Pátio {} e Endereço {}: {}", patioId, enderecoId, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Listar endereços de um pátio",
            description = "Retorna todos os endereços associados a um pátio específico.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Endereços do pátio retornados com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = EnderecoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Pátio não encontrado")
            }
    )
    @GetMapping("/{patioId}/enderecos")
    public ResponseEntity<Set<EnderecoResponseDto>> getEnderecosByPatioId(@PathVariable Long patioId) {
        log.info("Buscando endereços associados ao pátio com ID: {}", patioId);
        try {
            Set<EnderecoResponseDto> enderecos = patioService.getEnderecosByPatioId(patioId).stream()
                    .map(enderecoMapper::toResponseDto)
                    .collect(Collectors.toSet());
            log.info("Retornando {} endereços para o pátio com ID {}.", enderecos.size(), patioId);
            return ResponseEntity.ok(enderecos);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar endereços do pátio com ID {}: {}", patioId, e.getMessage());
            throw e;
        }
    }

    // --- Endpoints de Associação de Boxes com Pátio (NOVO) ---
    @Operation(
            summary = "Associar box a um pátio",
            description = "Associa um box existente a um pátio existente.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Associação criada com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Pátio ou Box não encontrado"),
                    @ApiResponse(responseCode = "409", description = "Associação já existe")
            }
    )
    @PostMapping("/{patioId}/boxes/{boxId}/associar")
    public ResponseEntity<String> associarPatioBox(
            @PathVariable Long patioId,
            @PathVariable Long boxId) {
        log.info("Associando box ID {} ao pátio ID {}.", boxId, patioId);
        try {
            patioService.associarPatioBox(patioId, boxId);
            log.info("Associação entre Pátio {} e Box {} criada com sucesso.", patioId, boxId);
            return ResponseEntity.status(HttpStatus.CREATED).body("Associação criada com sucesso.");
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao associar - Recurso não encontrado: {}", e.getMessage());
            throw e;
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao associar - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao associar Pátio {} e Box {}: {}", patioId, boxId, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Desassociar box de um pátio",
            description = "Remove a associação entre um box e um pátio.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Associação removida com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Associação não encontrada")
            }
    )
    @DeleteMapping("/{patioId}/boxes/{boxId}/desassociar")
    public ResponseEntity<Void> desassociarPatioBox(
            @PathVariable Long patioId,
            @PathVariable Long boxId) {
        log.info("Desassociando box ID {} do pátio ID {}.", boxId, patioId);
        try {
            patioService.desassociarPatioBox(patioId, boxId);
            log.info("Associação entre Pátio {} e Box {} removida com sucesso.", patioId, boxId);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao desassociar - Associação não encontrada: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao desassociar Pátio {} e Box {}: {}", patioId, boxId, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Listar boxes de um pátio",
            description = "Retorna todos os boxes associados a um pátio específico.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Boxes do pátio retornados com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = BoxResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Pátio não encontrado")
            }
    )
    @GetMapping("/{patioId}/boxes")
    public ResponseEntity<Set<BoxResponseDto>> getBoxesByPatioId(@PathVariable Long patioId) {
        log.info("Buscando boxes associados ao pátio com ID: {}", patioId);
        try {
            Set<BoxResponseDto> boxes = patioService.getBoxesByPatioId(patioId).stream()
                    .map(boxMapper::toResponseDto)
                    .collect(Collectors.toSet());
            log.info("Retornando {} boxes para o pátio com ID {}.", boxes.size(), patioId);
            return ResponseEntity.ok(boxes);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar boxes do pátio com ID {}: {}", patioId, e.getMessage());
            throw e;
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\controller\RastreamentoController.java   |   package br.com.fiap.mottu.controller   |   class RastreamentoController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.rastreamento.RastreamentoRequestDto;
import br.com.fiap.mottu.dto.rastreamento.RastreamentoResponseDto;
import br.com.fiap.mottu.filter.RastreamentoFilter;
import br.com.fiap.mottu.service.RastreamentoService;
import br.com.fiap.mottu.mapper.RastreamentoMapper;
import br.com.fiap.mottu.exception.ResourceNotFoundException;
import br.com.fiap.mottu.exception.InvalidInputException;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/rastreamentos")
@Tag(name = "Rastreamentos", description = "Gerenciamento de Rastreamentos")
public class RastreamentoController {

    private static final Logger log = LoggerFactory.getLogger(RastreamentoController.class);
    private final RastreamentoService rastreamentoService;
    private final RastreamentoMapper rastreamentoMapper;

    @Autowired
    public RastreamentoController(RastreamentoService rastreamentoService, RastreamentoMapper rastreamentoMapper) {
        this.rastreamentoService = rastreamentoService;
        this.rastreamentoMapper = rastreamentoMapper;
    }

    @Operation(
            summary = "Listar todos os rastreamentos",
            description = "Retorna uma lista de todos os rastreamentos cadastrados.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de rastreamentos retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = RastreamentoResponseDto.class)))
            }
    )
    @GetMapping
    public ResponseEntity<List<RastreamentoResponseDto>> listarTodosRastreamentos() {
        log.info("Buscando todos os rastreamentos.");
        List<RastreamentoResponseDto> rastreamentos = rastreamentoService.listarTodosRastreamentos().stream()
                .map(rastreamentoMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} rastreamentos.", rastreamentos.size());
        return ResponseEntity.ok(rastreamentos);
    }

    @Operation(
            summary = "Buscar rastreamento por ID",
            description = "Retorna um rastreamento específico com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Rastreamento encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = RastreamentoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Rastreamento não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Rastreamento com ID 1 não encontrado(a).\",\"path\":\"/api/rastreamentos/1\"}")))
            }
    )
    @GetMapping("/{id}")
    public ResponseEntity<RastreamentoResponseDto> buscarRastreamentoPorId(@PathVariable Long id) {
        log.info("Buscando rastreamento com ID: {}", id);
        try {
            RastreamentoResponseDto rastreamento = rastreamentoMapper.toResponseDto(rastreamentoService.buscarRastreamentoPorId(id));
            log.info("Rastreamento com ID {} encontrado com sucesso.", id);
            return ResponseEntity.ok(rastreamento);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar rastreamento com ID {}: {}", id, e.getMessage());
            throw e;
        }
    }

    @Operation(
            summary = "Buscar rastreamentos por filtro",
            description = "Retorna uma lista de rastreamentos que correspondem aos critérios de filtro fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de rastreamentos filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = RastreamentoResponseDto.class)))
            }
    )
    @GetMapping("/search")
    public ResponseEntity<List<RastreamentoResponseDto>> buscarRastreamentosPorFiltro(RastreamentoFilter filter) {
        log.info("Buscando rastreamentos com filtro: {}", filter);
        List<RastreamentoResponseDto> rastreamentos = rastreamentoService.buscarRastreamentosPorFiltro(filter).stream()
                .map(rastreamentoMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} rastreamentos filtrados.", rastreamentos.size());
        return ResponseEntity.ok(rastreamentos);
    }

    @Operation(
            summary = "Criar novo rastreamento",
            description = "Cria um novo rastreamento com os dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Rastreamento criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = RastreamentoResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos (coordenadas ausentes)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"Requisição Inválida\",\"message\":\"Todas as coordenadas são obrigatórias.\",\"path\":\"/api/rastreamentos\"}")))
            }
    )
    @PostMapping
    public ResponseEntity<RastreamentoResponseDto> criarRastreamento(@Valid @RequestBody RastreamentoRequestDto rastreamentoRequestDto) {
        log.info("Recebida requisição para criar rastreamento: {}", rastreamentoRequestDto);
        try {
            RastreamentoResponseDto novoRastreamento = rastreamentoMapper.toResponseDto(rastreamentoService.criarRastreamento(rastreamentoRequestDto));
            log.info("Rastreamento criado com sucesso com ID: {}", novoRastreamento.getIdRastreamento());
            return ResponseEntity.status(HttpStatus.CREATED).body(novoRastreamento);
        } catch (InvalidInputException e) {
            log.error("Erro ao criar rastreamento - Requisição inválida: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao criar rastreamento: {}", e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Atualizar rastreamento existente",
            description = "Atualiza um rastreamento existente com base no ID e nos dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Rastreamento atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = RastreamentoResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"Requisição Inválida\",\"message\":\"Mensagem de validação ou erro de input.\",\"path\":\"/api/rastreamentos/1\"}"))),
                    @ApiResponse(responseCode = "404", description = "Rastreamento não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Rastreamento com ID 1 não encontrado(a).\",\"path\":\"/api/rastreamentos/1\"}")))
            }
    )
    @PutMapping("/{id}")
    public ResponseEntity<RastreamentoResponseDto> atualizarRastreamento(@PathVariable Long id, @Valid @RequestBody RastreamentoRequestDto rastreamentoRequestDto) {
        log.info("Recebida requisição para atualizar rastreamento com ID {}: {}", id, rastreamentoRequestDto);
        try {
            RastreamentoResponseDto rastreamentoAtualizado = rastreamentoMapper.toResponseDto(rastreamentoService.atualizarRastreamento(id, rastreamentoRequestDto));
            log.info("Rastreamento com ID {} atualizado com sucesso.", id);
            return ResponseEntity.ok(rastreamentoAtualizado);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao atualizar rastreamento - Não encontrado: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao atualizar rastreamento com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Deletar rastreamento",
            description = "Exclui um rastreamento com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Rastreamento deletado com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Rastreamento não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Rastreamento com ID 1 não encontrado(a).\",\"path\":\"/api/rastreamentos/1\"}")))
            }
    )
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarRastreamento(@PathVariable Long id) {
        log.info("Recebida requisição para deletar rastreamento com ID: {}", id);
        try {
            rastreamentoService.deletarRastreamento(id);
            log.info("Rastreamento com ID {} deletado com sucesso.", id);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao deletar rastreamento - Não encontrado: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao deletar rastreamento com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\controller\VeiculoController.java   |   package br.com.fiap.mottu.controller   |   class VeiculoController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.veiculo.VeiculoRequestDto;
import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.mottu.dto.veiculo.VeiculoLocalizacaoResponseDto; // NOVO: Importar

import br.com.fiap.mottu.filter.VeiculoFilter;
import br.com.fiap.mottu.service.VeiculoService;
import br.com.fiap.mottu.mapper.VeiculoMapper;
import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/veiculos")
@Tag(name = "Veiculos", description = "Gerenciamento de Veículos e Rastreamento") // Altere o Tag para refletir o rastreamento
public class VeiculoController {

    private static final Logger log = LoggerFactory.getLogger(VeiculoController.class);
    private final VeiculoService veiculoService;
    private final VeiculoMapper veiculoMapper;

    @Autowired
    public VeiculoController(VeiculoService veiculoService,
                             VeiculoMapper veiculoMapper) {
        this.veiculoService = veiculoService;
        this.veiculoMapper = veiculoMapper;
    }

    @Operation(
            summary = "Listar todos os veículos",
            description = "Retorna uma lista de todos os veículos cadastrados.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de veículos retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoResponseDto.class)))
            }
    )
    @GetMapping
    public ResponseEntity<List<VeiculoResponseDto>> listarTodosVeiculos() {
        log.info("Buscando todos os veículos.");
        List<VeiculoResponseDto> veiculos = veiculoService.listarTodosVeiculos().stream()
                .map(veiculoMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} veículos.", veiculos.size());
        return ResponseEntity.ok(veiculos);
    }

    @Operation(
            summary = "Buscar veículo por ID",
            description = "Retorna um veículo específico com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Veículo encontrado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Veículo não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Veículo com ID 1 não encontrado(a).\",\"path\":\"/api/veiculos/1\"}")))
            }
    )
    @GetMapping("/{id}")
    public ResponseEntity<VeiculoResponseDto> buscarVeiculoPorId(@PathVariable Long id) {
        log.info("Buscando veículo com ID: {}", id);
        try {
            VeiculoResponseDto veiculo = veiculoMapper.toResponseDto(veiculoService.buscarVeiculoPorId(id));
            log.info("Veículo com ID {} encontrado com sucesso.", id);
            return ResponseEntity.ok(veiculo);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar veículo com ID {}: {}", id, e.getMessage());
            throw e;
        }
    }

    @Operation(
            summary = "Buscar veículos por filtro",
            description = "Retorna uma lista de veículos que correspondem aos critérios de filtro fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de veículos filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoResponseDto.class)))
            }
    )
    @GetMapping("/search")
    public ResponseEntity<List<VeiculoResponseDto>> buscarVeiculosPorFiltro(VeiculoFilter filter) {
        log.info("Buscando veículos com filtro: {}", filter);
        List<VeiculoResponseDto> veiculos = veiculoService.buscarVeiculosPorFiltro(filter).stream()
                .map(veiculoMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} veículos filtrados.", veiculos.size());
        return ResponseEntity.ok(veiculos);
    }

    @Operation(
            summary = "Criar novo veículo",
            description = "Cria um novo veículo com os dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Veículo criado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"Requisição Inválida\",\"message\":\"Mensagem de validação ou erro de input.\",\"path\":\"/api/veiculos\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (placa, RENAVAM ou chassi duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Veículo com placa 'ABC1234' já existe.\",\"path\":\"/api/veiculos\"}")))
            }
    )
    @PostMapping
    public ResponseEntity<VeiculoResponseDto> criarVeiculo(@Valid @RequestBody VeiculoRequestDto veiculoRequestDto) {
        log.info("Recebida requisição para criar veículo: {}", veiculoRequestDto);
        try {
            VeiculoResponseDto novoVeiculo = veiculoMapper.toResponseDto(veiculoService.criarVeiculo(veiculoRequestDto));
            log.info("Veículo criado com sucesso com ID: {}", novoVeiculo.getIdVeiculo());
            return ResponseEntity.status(HttpStatus.CREATED).body(novoVeiculo);
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao criar veículo - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao criar veículo: {}", e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Atualizar veículo existente",
            description = "Atualiza um veículo existente com base no ID e nos dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Veículo atualizado com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"Requisição Inválida\",\"message\":\"Mensagem de validação ou erro de input.\",\"path\":\"/api/veiculos/1\"}"))),
                    @ApiResponse(responseCode = "404", description = "Veículo não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Veículo com ID 1 não encontrado(a).\",\"path\":\"/api/veiculos/1\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (placa, RENAVAM ou chassi duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Veículo com placa 'ABC1234' já existe.\",\"path\":\"/api/veiculos/1\"}")))
            }
    )
    @PutMapping("/{id}")
    public ResponseEntity<VeiculoResponseDto> atualizarVeiculo(@PathVariable Long id, @Valid @RequestBody VeiculoRequestDto veiculoRequestDto) {
        log.info("Recebida requisição para atualizar veículo com ID {}: {}", id, veiculoRequestDto);
        try {
            VeiculoResponseDto veiculoAtualizado = veiculoMapper.toResponseDto(veiculoService.atualizarVeiculo(id, veiculoRequestDto));
            log.info("Veículo com ID {} atualizado com sucesso.", id);
            return ResponseEntity.ok(veiculoAtualizado);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao atualizar veículo - Não encontrado: {}", e.getMessage());
            throw e;
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao atualizar veículo - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao atualizar veículo com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Deletar veículo",
            description = "Exclui um veículo com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Veículo deletado com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Veículo não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Veículo com ID 1 não encontrado(a).\",\"path\":\"/api/veiculos/1\"}")))
            }
    )
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarVeiculo(@PathVariable Long id) {
        log.info("Recebida requisição para deletar veículo com ID: {}", id);
        try {
            veiculoService.deletarVeiculo(id);
            log.info("Veículo com ID {} deletado com sucesso.", id);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao deletar veículo - Não encontrado: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao deletar veículo com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }

    /**
     * Endpoint para obter a localização de um veículo.
     * Retorna o último ponto de rastreamento do veículo e suas associações atuais com Pátio, Zona e Box.
     *
     * @param id O ID do veículo a ser localizado.
     * @return ResponseEntity contendo o DTO de localização do veículo ou um erro.
     */
    @Operation(
            summary = "Obter localização de um veículo",
            description = "Retorna o último ponto de rastreamento de um veículo e suas associações atuais com Pátio, Zona e Box.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Localização do veículo retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = VeiculoLocalizacaoResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Veículo não encontrado",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Veículo com ID 1 não encontrado(a).\",\"path\":\"/api/veiculos/1/localizacao\"}")))
            }
    )
    @GetMapping("/{id}/localizacao")
    public ResponseEntity<VeiculoLocalizacaoResponseDto> getLocalizacaoVeiculo(@PathVariable Long id) {
        log.info("Buscando localização para o veículo com ID: {}", id);
        try {
            VeiculoLocalizacaoResponseDto localizacao = veiculoService.getLocalizacaoVeiculo(id);
            log.info("Localização do veículo com ID {} encontrada com sucesso.", id);
            return ResponseEntity.ok(localizacao);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar localização para o veículo com ID {}: {}", id, e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao buscar localização para o veículo com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\controller\ZonaController.java   |   package br.com.fiap.mottu.controller   |   class ZonaController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.controller;

import br.com.fiap.mottu.dto.zona.ZonaRequestDto;
import br.com.fiap.mottu.dto.zona.ZonaResponseDto;
import br.com.fiap.mottu.filter.ZonaFilter;
import br.com.fiap.mottu.service.ZonaService;
import br.com.fiap.mottu.mapper.ZonaMapper;
import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/zonas")
@Tag(name = "Zonas", description = "Gerenciamento de Zonas")
public class ZonaController {

    private static final Logger log = LoggerFactory.getLogger(ZonaController.class);
    private final ZonaService zonaService;
    private final ZonaMapper zonaMapper;

    @Autowired
    public ZonaController(ZonaService zonaService, ZonaMapper zonaMapper) {
        this.zonaService = zonaService;
        this.zonaMapper = zonaMapper;
    }

    @Operation(
            summary = "Listar todas as zonas",
            description = "Retorna uma lista de todas as zonas cadastradas.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de zonas retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ZonaResponseDto.class)))
            }
    )
    @GetMapping
    public ResponseEntity<List<ZonaResponseDto>> listarTodasZonas() {
        log.info("Buscando todas as zonas.");
        List<ZonaResponseDto> zonas = zonaService.listarTodasZonas().stream()
                .map(zonaMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} zonas.", zonas.size());
        return ResponseEntity.ok(zonas);
    }

    @Operation(
            summary = "Buscar zona por ID",
            description = "Retorna uma zona específica com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Zona encontrada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ZonaResponseDto.class))),
                    @ApiResponse(responseCode = "404", description = "Zona não encontrada",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Zona com ID 1 não encontrado(a).\",\"path\":\"/api/zonas/1\"}")))
            }
    )
    @GetMapping("/{id}")
    public ResponseEntity<ZonaResponseDto> buscarZonaPorId(@PathVariable Long id) {
        log.info("Buscando zona com ID: {}", id);
        try {
            ZonaResponseDto zona = zonaMapper.toResponseDto(zonaService.buscarZonaPorId(id));
            log.info("Zona com ID {} encontrado com sucesso.", id);
            return ResponseEntity.ok(zona);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao buscar zona com ID {}: {}", id, e.getMessage());
            throw e;
        }
    }

    @Operation(
            summary = "Buscar zonas por filtro",
            description = "Retorna uma lista de zonas que correspondem aos critérios de filtro fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Lista de zonas filtrada retornada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ZonaResponseDto.class)))
            }
    )
    @GetMapping("/search")
    public ResponseEntity<List<ZonaResponseDto>> buscarZonasPorFiltro(ZonaFilter filter) {
        log.info("Buscando zonas com filtro: {}", filter);
        List<ZonaResponseDto> zonas = zonaService.buscarZonasPorFiltro(filter).stream()
                .map(zonaMapper::toResponseDto)
                .collect(Collectors.toList());
        log.info("Retornando {} zonas filtradas.", zonas.size());
        return ResponseEntity.ok(zonas);
    }

    @Operation(
            summary = "Criar nova zona",
            description = "Cria uma nova zona com os dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "201", description = "Zona criada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ZonaResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"Requisição Inválida\",\"message\":\"Mensagem de validação ou erro de input.\",\"path\":\"/api/zonas\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (nome duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Zona com nome 'Nome Duplicado' já existe.\",\"path\":\"/api/zonas\"}")))
            }
    )
    @PostMapping
    public ResponseEntity<ZonaResponseDto> criarZona(@Valid @RequestBody ZonaRequestDto zonaRequestDto) {
        log.info("Recebida requisição para criar zona: {}", zonaRequestDto);
        try {
            ZonaResponseDto novaZona = zonaMapper.toResponseDto(zonaService.criarZona(zonaRequestDto));
            log.info("Zona criada com sucesso com ID: {}", novaZona.getIdZona());
            return ResponseEntity.status(HttpStatus.CREATED).body(novaZona);
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao criar zona - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao criar zona: {}", e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Atualizar zona existente",
            description = "Atualiza uma zona existente com base no ID e nos dados fornecidos.",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Zona atualizada com sucesso",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(implementation = ZonaResponseDto.class))),
                    @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":400,\"error\":\"Requisição Inválida\",\"message\":\"Mensagem de validação ou erro de input.\",\"path\":\"/api/zonas/1\"}"))),
                    @ApiResponse(responseCode = "404", description = "Zona não encontrada",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Zona com ID 1 não encontrado(a).\",\"path\":\"/api/zonas/1\"}"))),
                    @ApiResponse(responseCode = "409", description = "Conflito de recurso (nome duplicado)",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":409,\"error\":\"Conflito de Dados\",\"message\":\"Zona com nome 'Nome Duplicado' já existe.\",\"path\":\"/api/zonas/1\"}")))
            }
    )
    @PutMapping("/{id}")
    public ResponseEntity<ZonaResponseDto> atualizarZona(@PathVariable Long id, @Valid @RequestBody ZonaRequestDto zonaRequestDto) {
        log.info("Recebida requisição para atualizar zona com ID {}: {}", id, zonaRequestDto);
        try {
            ZonaResponseDto zonaAtualizada = zonaMapper.toResponseDto(zonaService.atualizarZona(id, zonaRequestDto));
            log.info("Zona com ID {} atualizada com sucesso.", id);
            return ResponseEntity.ok(zonaAtualizada);
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao atualizar zona - Não encontrado: {}", e.getMessage());
            throw e;
        } catch (DuplicatedResourceException e) {
            log.error("Erro ao atualizar zona - Conflito: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao atualizar zona com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }

    @Operation(
            summary = "Deletar zona",
            description = "Exclui uma zona com base no ID fornecido.",
            responses = {
                    @ApiResponse(responseCode = "204", description = "Zona deletada com sucesso"),
                    @ApiResponse(responseCode = "404", description = "Zona não encontrada",
                            content = @Content(mediaType = "application/json",
                                    schema = @Schema(example = "{\"timestamp\":\"2025-01-01T12:00:00\",\"status\":404,\"error\":\"Não Encontrado\",\"message\":\"Zona com ID 1 não encontrado(a).\",\"path\":\"/api/zonas/1\"}")))
            }
    )
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarZona(@PathVariable Long id) {
        log.info("Recebida requisição para deletar zona com ID: {}", id);
        try {
            zonaService.deletarZona(id);
            log.info("Zona com ID {} deletada com sucesso.", id);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.error("Erro ao deletar zona - Não encontrado: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("Erro inesperado ao deletar zona com ID {}: {}", id, e.getMessage(), e);
            throw e;
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\dto\box\BoxRequestDto.java   |   package br.com.fiap.mottu.dto.box   |   class BoxRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\box\BoxRequestDto.java
package br.com.fiap.mottu.dto.box;

import lombok.Value;
import java.io.Serializable;
import java.time.LocalDate;
import jakarta.validation.constraints.*;

/**
 * DTO for {@link br.com.fiap.mottu.model.Box}
 */
@Value
public class BoxRequestDto implements Serializable {
    @NotBlank(message = "O nome não pode estar em branco.")
    @Size(max = 50, message = "O nome deve ter no máximo 50 caracteres.")
    String nome;

    @NotBlank(message = "O status não pode estar em branco.")
    @Size(max = 1, message = "O status deve ter 1 caracter.")
    @Pattern(regexp = "[LO]", message = "O status deve ser 'L' (Livre) ou 'O' (Ocupado).")
    String status;

    @NotNull(message = "A data de entrada não pode ser nula.")
    LocalDate dataEntrada;

    @NotNull(message = "A data de saída não pode ser nula.")
    LocalDate dataSaida;

    @Size(max = 100, message = "A observação deve ter no máximo 100 caracteres.")
    String observacao;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\dto\box\BoxResponseDto.java   |   package br.com.fiap.mottu.dto.box   |   class BoxResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\box\BoxResponseDto.java
package br.com.fiap.mottu.dto.box;

import lombok.Value;
import java.io.Serializable;
import java.time.LocalDate;

/**
 * DTO for {@link br.com.fiap.mottu.model.Box}
 */
@Value
public class BoxResponseDto implements Serializable {
    Long idBox;
    String nome;
    String status;
    LocalDate dataEntrada;
    LocalDate dataSaida;
    String observacao;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\dto\cliente\ClienteRequestDto.java   |   package br.com.fiap.mottu.dto.cliente   |   class ClienteRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\cliente\ClienteRequestDto.java
package br.com.fiap.mottu.dto.cliente;

import br.com.fiap.mottu.dto.contato.ContatoRequestDto;
import br.com.fiap.mottu.dto.endereco.EnderecoRequestDto;
import lombok.Value;

import jakarta.validation.Valid;
import jakarta.validation.constraints.*;
import java.io.Serializable;
import java.time.LocalDate;

/**
 * DTO for {@link br.com.fiap.mottu.model.Cliente}
 */
@Value
public class ClienteRequestDto implements Serializable {
    @NotBlank(message = "O sexo não pode estar em branco.")
    @Size(min = 1, max = 2, message = "O sexo deve ter 1 ou 2 caracteres.")
    @Pattern(regexp = "^[MH]$", message = "O sexo deve ser 'M' (Masculino) ou 'H' (Feminino).")
    String sexo;

    @NotBlank(message = "O nome não pode estar em branco.")
    @Size(max = 100, message = "O nome deve ter no máximo 100 caracteres.")
    String nome;

    @NotBlank(message = "O sobrenome não pode estar em branco.")
    @Size(max = 100, message = "O sobrenome deve ter no máximo 100 caracteres.")
    String sobrenome;

    @NotNull(message = "A data de nascimento não pode ser nula.")
    @Past(message = "A data de nascimento deve ser no passado.")
    LocalDate dataNascimento;

    @NotBlank(message = "O CPF não pode estar em branco.")
    @Size(min = 11, max = 11, message = "O CPF deve ter 11 caracteres.")
    @Pattern(regexp = "^\\d{11}$", message = "O CPF deve conter apenas dígitos.")
    String cpf;

    @NotBlank(message = "A profissão não pode estar em branco.")
    @Size(max = 50, message = "A profissão deve ter no máximo 50 caracteres.")
    String profissao;

    @NotBlank(message = "O estado civil não pode estar em branco.")
    @Size(max = 50, message = "O estado civil deve ter no máximo 50 caracteres.")
    @Pattern(regexp = "^(Solteiro|Casado|Divorciado|Viúvo|Separado|União Estável)$", message = "Estado civil inválido.")
    String estadoCivil;

    @NotNull(message = "O endereço não pode ser nulo.")
    @Valid
    EnderecoRequestDto enderecoRequestDto;

    @NotNull(message = "O contato não pode ser nulo.")
    @Valid
    ContatoRequestDto contatoRequestDto;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\dto\cliente\ClienteResponseDto.java   |   package br.com.fiap.mottu.dto.cliente   |   class ClienteResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\cliente\ClienteResponseDto.java
package br.com.fiap.mottu.dto.cliente;

import br.com.fiap.mottu.dto.contato.ContatoResponseDto;
import br.com.fiap.mottu.dto.endereco.EnderecoResponseDto;
import lombok.Value;

import java.io.Serializable;
import java.time.LocalDate;
import java.util.Set;
import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto;

/**
 * DTO for {@link br.com.fiap.mottu.model.Cliente}
 */
@Value
public class ClienteResponseDto implements Serializable {
    Long idCliente;
    LocalDate dataCadastro;
    String sexo;
    String nome;
    String sobrenome;
    LocalDate dataNascimento;
    String cpf;
    String profissao;
    String estadoCivil;
    EnderecoResponseDto enderecoResponseDto;
    ContatoResponseDto contatoResponseDto;

    // Set<VeiculoResponseDto> veiculos; // Necessita de mapeamento customizado no ClienteMapper
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\dto\contato\ContatoRequestDto.java   |   package br.com.fiap.mottu.dto.contato   |   class ContatoRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// br/com/fiap/mottu/dto/contato/ContatoRequestDto.java
package br.com.fiap.mottu.dto.contato;

import lombok.Value;
import jakarta.validation.constraints.*;
import java.io.Serializable;

@Value
public class ContatoRequestDto implements Serializable {
    /** ID para identificar um contato existente em operações de atualização */
    Long idContato;

    @NotBlank(message = "O email não pode estar em branco.")
    @Email(message = "Formato de email inválido.")
    String email;

    @Min(value = 0, message = "DDD inválido.")
    Integer ddd;

    @Min(value = 0, message = "DDI inválido.")
    Integer ddi;

    @Size(max = 20, message = "O telefone 1 deve ter no máximo 20 caracteres.")
    String telefone1;

    @Size(max = 20, message = "O telefone 2 deve ter no máximo 20 caracteres.")
    String telefone2;

    @Size(max = 20, message = "O telefone 3 deve ter no máximo 20 caracteres.")
    String telefone3;

    @NotBlank(message = "O celular não pode estar em branco.")
    @Size(max = 20, message = "O celular deve ter no máximo 20 caracteres.")
    String celular;

    @Size(max = 100, message = "Outras informações de contato devem ter no máximo 100 caracteres.")
    String outro;

    @Size(max = 200, message = "A observação deve ter no máximo 200 caracteres.")
    String observacao;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\dto\contato\ContatoResponseDto.java   |   package br.com.fiap.mottu.dto.contato   |   class ContatoResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\contato\ContatoResponseDto.java
package br.com.fiap.mottu.dto.contato;

import lombok.Value;

import java.io.Serializable;

/**
 * DTO for {@link br.com.fiap.mottu.model.Contato}
 */
@Value
public class ContatoResponseDto implements Serializable {
    Long idContato;
    String email;
    Integer ddd;
    Integer ddi;
    String telefone1;
    String telefone2;
    String telefone3;
    String celular;
    String outro;
    String observacao;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\dto\endereco\EnderecoRequestDto.java   |   package br.com.fiap.mottu.dto.endereco   |   class EnderecoRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\endereco\EnderecoRequestDto.java
package br.com.fiap.mottu.dto.endereco;

import lombok.Value;

import jakarta.validation.constraints.*;
import java.io.Serializable;

/**
 * DTO for {@link br.com.fiap.mottu.model.Endereco}
 */
@Value
public class EnderecoRequestDto implements Serializable {
    // Apenas CEP, numero, complemento e observacao virão na requisição
    // Outros campos serão preenchidos pela ViaCEP
    @NotBlank(message = "O CEP não pode estar em branco.")
    @Size(min = 8, max = 9, message = "O CEP deve ter 8 ou 9 caracteres (formato 'XXXXXXXX' ou 'XXXXX-XXX').")
    @Pattern(regexp = "^\\d{8}$|^\\d{5}-\\d{3}$", message = "Formato de CEP inválido (esperado XXXXXXXX ou XXXXX-XXX).")
    String cep;

    @NotNull(message = "O número do endereço não pode ser nulo.")
    @Positive(message = "O número do endereço deve ser positivo.")
    @Max(value = 9999999, message = "O número do endereço deve ter no máximo 7 dígitos.")
    Integer numero;

    @Size(max = 60, message = "O complemento deve ter no máximo 60 caracteres.")
    String complemento;

    @Size(max = 200, message = "A observação deve ter no máximo 200 caracteres.")
    String observacao;

    // ID para identificar um endereço existente em operações de atualização
    Long idEndereco; // Adicionado para permitir a atualização de endereços existentes via ClienteRequestDto
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\dto\endereco\EnderecoResponseDto.java   |   package br.com.fiap.mottu.dto.endereco   |   class EnderecoResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\endereco\EnderecoResponseDto.java
package br.com.fiap.mottu.dto.endereco;

import lombok.Value;

import java.io.Serializable;

/**
 * DTO for {@link br.com.fiap.mottu.model.Endereco}
 */
@Value
public class EnderecoResponseDto implements Serializable {
    Long idEndereco;
    String cep;
    Integer numero;
    String logradouro;
    String bairro;
    String cidade;
    String estado;
    String pais;
    String complemento;
    String observacao;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\dto\patio\PatioRequestDto.java   |   package br.com.fiap.mottu.dto.patio   |   class PatioRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\patio\PatioRequestDto.java
package br.com.fiap.mottu.dto.patio;

import lombok.Value;
import java.io.Serializable;
import java.time.LocalDate;
import jakarta.validation.constraints.*;

/**
 * DTO for {@link br.com.fiap.mottu.model.Patio}
 */
@Value
public class PatioRequestDto implements Serializable {
    @NotBlank(message = "O nome do pátio não pode estar em branco.")
    @Size(max = 50, message = "O nome do pátio deve ter no máximo 50 caracteres.")
    String nomePatio;

    @NotNull(message = "A data de entrada não pode ser nula.")
    LocalDate dataEntrada;

    @NotNull(message = "A data de saída não pode ser nula.")
    LocalDate dataSaida;

    @Size(max = 100, message = "A observação deve ter no máximo 100 caracteres.")
    String observacao;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\dto\patio\PatioResponseDto.java   |   package br.com.fiap.mottu.dto.patio   |   class PatioResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\patio\PatioResponseDto.java
package br.com.fiap.mottu.dto.patio;

import lombok.Value;
import java.io.Serializable;
import java.time.LocalDate;

/**
 * DTO for {@link br.com.fiap.mottu.model.Patio}
 */
@Value
public class PatioResponseDto implements Serializable {
    Long idPatio;
    String nomePatio;
    LocalDate dataEntrada;
    LocalDate dataSaida;
    String observacao;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\dto\rastreamento\RastreamentoRequestDto.java   |   package br.com.fiap.mottu.dto.rastreamento   |   class RastreamentoRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.dto.rastreamento;

import lombok.Value;
import jakarta.validation.constraints.*;
import java.io.Serializable;
import java.math.BigDecimal; // Importe BigDecimal!

/**
 * DTO for {@link br.com.fiap.mottu.model.Rastreamento}
 */
@Value
public class RastreamentoRequestDto implements Serializable {

    @NotNull(message = "A coordenada IPS X não pode ser nula.")
    private BigDecimal ipsX;

    @NotNull(message = "A coordenada IPS Y não pode ser nula.")
    private BigDecimal ipsY;

    @NotNull(message = "A coordenada IPS Z não pode ser nula.")
    private BigDecimal ipsZ;

    @NotNull(message = "A Latitude GPRS não pode ser nula.")
    private BigDecimal gprsLatitude;

    @NotNull(message = "A Longitude GPRS não pode ser nula.")
    private BigDecimal gprsLongitude;

    @NotNull(message = "A Altitude GPRS não pode ser nula.")
    private BigDecimal gprsAltitude;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\dto\rastreamento\RastreamentoResponseDto.java   |   package br.com.fiap.mottu.dto.rastreamento   |   class RastreamentoResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.dto.rastreamento;

import lombok.Value;
import java.io.Serializable;
import java.math.BigDecimal; // Importe BigDecimal!

/**
 * DTO for {@link br.com.fiap.mottu.model.Rastreamento}
 */
@Value
public class RastreamentoResponseDto implements Serializable {
    Long idRastreamento;

    private BigDecimal ipsX;
    private BigDecimal ipsY;
    private BigDecimal ipsZ;

    private BigDecimal gprsLatitude;
    private BigDecimal gprsLongitude;
    private BigDecimal gprsAltitude;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\dto\veiculo\VeiculoLocalizacaoResponseDto.java   |   package br.com.fiap.mottu.dto.veiculo   |   class VeiculoLocalizacaoResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.dto.veiculo;

import br.com.fiap.mottu.dto.rastreamento.RastreamentoResponseDto;
import br.com.fiap.mottu.dto.patio.PatioResponseDto;
import br.com.fiap.mottu.dto.zona.ZonaResponseDto;
import br.com.fiap.mottu.dto.box.BoxResponseDto;
import lombok.Value;

import java.io.Serializable;
import java.time.LocalDateTime; // Para o timestamp do último rastreamento

@Value
public class VeiculoLocalizacaoResponseDto implements Serializable {
    Long idVeiculo;
    String placa;
    String modelo;
    String fabricante;

    RastreamentoResponseDto ultimoRastreamento; // O último ponto de rastreamento

    PatioResponseDto patioAssociado; // O pátio ao qual o veículo está atualmente associado (se houver)
    ZonaResponseDto zonaAssociada;   // A zona ao qual o veículo está atualmente associado (se houver)
    BoxResponseDto boxAssociado;     // O box ao qual o veículo está atualmente associado (se houver)

    LocalDateTime dataConsulta; // Timestamp da consulta
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\dto\veiculo\VeiculoRequestDto.java   |   package br.com.fiap.mottu.dto.veiculo   |   class VeiculoRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\veiculo\VeiculoRequestDto.java
package br.com.fiap.mottu.dto.veiculo;

import lombok.Value;
import jakarta.validation.constraints.*;
import java.io.Serializable;

/**
 * DTO for {@link br.com.fiap.mottu.model.Veiculo}
 */
@Value
public class VeiculoRequestDto implements Serializable {
    @NotBlank(message = "A placa não pode estar em branco.")
    @Size(max = 10, message = "A placa deve ter no máximo 10 caracteres.")
    String placa;

    @NotBlank(message = "O RENAVAM não pode estar em branco.")
    @Size(min = 11, max = 11, message = "O RENAVAM deve ter 11 caracteres.")
    @Pattern(regexp = "^\\d{11}$", message = "O RENAVAM deve conter apenas dígitos.")
    String renavam;

    @NotBlank(message = "O chassi não pode estar em branco.")
    @Size(min = 17, max = 17, message = "O chassi deve ter 17 caracteres.")
    String chassi;

    @NotBlank(message = "O fabricante não pode estar em branco.")
    @Size(max = 50, message = "O fabricante deve ter no máximo 50 caracteres.")
    String fabricante;

    @NotBlank(message = "O modelo não pode estar em branco.")
    @Size(max = 60, message = "O modelo deve ter no máximo 60 caracteres.")
    String modelo;

    @Size(max = 30, message = "O motor deve ter no máximo 30 caracteres.")
    String motor;

    @NotNull(message = "O ano não pode ser nulo.")
    @Min(value = 1900, message = "O ano deve ser a partir de 1900.")
    @Max(value = 2100, message = "O ano deve ser no máximo 2100.")
    Integer ano;

    @NotBlank(message = "O combustível não pode estar em branco.")
    @Size(max = 20, message = "O combustível deve ter no máximo 20 caracteres.")
    String combustivel;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\dto\veiculo\VeiculoResponseDto.java   |   package br.com.fiap.mottu.dto.veiculo   |   class VeiculoResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\veiculo\VeiculoResponseDto.java
package br.com.fiap.mottu.dto.veiculo;

import lombok.Value;
import java.io.Serializable;

/**
 * DTO for {@link br.com.fiap.mottu.model.Veiculo}
 */
@Value
public class VeiculoResponseDto implements Serializable {
    Long idVeiculo;
    String placa;
    String renavam;
    String chassi;
    String fabricante;
    String modelo;
    String motor;
    Integer ano;
    String combustivel;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\dto\zona\ZonaRequestDto.java   |   package br.com.fiap.mottu.dto.zona   |   class ZonaRequestDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\zona\ZonaRequestDto.java
package br.com.fiap.mottu.dto.zona;

import lombok.Value;
import java.io.Serializable;
import java.time.LocalDate;
import jakarta.validation.constraints.*;

/**
 * DTO for {@link br.com.fiap.mottu.model.Zona}
 */
@Value
public class ZonaRequestDto implements Serializable {
    @NotBlank(message = "O nome não pode estar em branco.")
    @Size(max = 50, message = "O nome deve ter no máximo 50 caracteres.")
    String nome;

    @NotNull(message = "A data de entrada não pode ser nula.")
    LocalDate dataEntrada;

    @NotNull(message = "A data de saída não pode ser nula.")
    LocalDate dataSaida;

    @Size(max = 100, message = "A observação deve ter no máximo 100 caracteres.")
    String observacao;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\dto\zona\ZonaResponseDto.java   |   package br.com.fiap.mottu.dto.zona   |   class ZonaResponseDto
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\dto\zona\ZonaResponseDto.java
package br.com.fiap.mottu.dto.zona;

import lombok.Value;
import java.io.Serializable;
import java.time.LocalDate;

/**
 * DTO for {@link br.com.fiap.mottu.model.Zona}
 */
@Value
public class ZonaResponseDto implements Serializable {
    Long idZona;
    String nome;
    LocalDate dataEntrada;
    LocalDate dataSaida;
    String observacao;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\exception\DuplicatedResourceException.java   |   package br.com.fiap.mottu.exception   |   class DuplicatedResourceException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\exception\DuplicatedResourceException.java
package br.com.fiap.mottu.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

// Anotação para que o Spring mude o status HTTP automaticamente
@ResponseStatus(HttpStatus.CONFLICT) // 409 Conflict
public class DuplicatedResourceException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    public DuplicatedResourceException(String message) {
        super(message);
    }

    public DuplicatedResourceException(String resourceName, String identifierName, String identifierValue) {
        super(String.format("%s com %s '%s' já existe.", resourceName, identifierName, identifierValue));
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\exception\InvalidInputException.java   |   package br.com.fiap.mottu.exception   |   class InvalidInputException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\exception\InvalidInputException.java
package br.com.fiap.mottu.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

// Anotação para que o Spring mude o status HTTP automaticamente
@ResponseStatus(HttpStatus.BAD_REQUEST) // 400 Bad Request
public class InvalidInputException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    public InvalidInputException(String message) {
        super(message);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\exception\ResourceNotFoundException.java   |   package br.com.fiap.mottu.exception   |   class ResourceNotFoundException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\exception\ResourceNotFoundException.java
package br.com.fiap.mottu.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

// Anotação para que o Spring mude o status HTTP automaticamente
@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    public ResourceNotFoundException(String message) {
        super(message);
    }

    public ResourceNotFoundException(String resourceName, Long id) {
        super(String.format("%s com ID %d não encontrado(a).", resourceName, id));
    }

    public ResourceNotFoundException(String resourceName, String identifierName, String identifierValue) {
        super(String.format("%s com %s '%s' não encontrado(a).", resourceName, identifierName, identifierValue));
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\exception\handler\GlobalExceptionHandler.java   |   package br.com.fiap.mottu.exception.handler   |   class GlobalExceptionHandler
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\exception\handler\GlobalExceptionHandler.java
package br.com.fiap.mottu.exception.handler;

import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.InvalidInputException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

import java.time.LocalDateTime;
import java.util.LinkedHashMap;
import java.util.Map;

@ControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Object> handleResourceNotFoundException(ResourceNotFoundException ex, WebRequest request) {
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.NOT_FOUND.value());
        body.put("error", "Não Encontrado");
        body.put("message", ex.getMessage());
        body.put("path", request.getDescription(false));
        return new ResponseEntity<>(body, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(DuplicatedResourceException.class)
    public ResponseEntity<Object> handleDuplicatedResourceException(DuplicatedResourceException ex, WebRequest request) {
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.CONFLICT.value());
        body.put("error", "Conflito de Dados");
        body.put("message", ex.getMessage());
        body.put("path", request.getDescription(false));
        return new ResponseEntity<>(body, HttpStatus.CONFLICT);
    }

    @ExceptionHandler(InvalidInputException.class)
    public ResponseEntity<Object> handleInvalidInputException(InvalidInputException ex, WebRequest request) {
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.BAD_REQUEST.value());
        body.put("error", "Requisição Inválida");
        body.put("message", ex.getMessage());
        body.put("path", request.getDescription(false));
        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
    }

    // Você pode adicionar mais handlers para outras exceções que possam surgir,
    // como DataIntegrityViolationException do JPA/Hibernate.
    // Exemplo:
    // @ExceptionHandler(DataIntegrityViolationException.class)
    // public ResponseEntity<Object> handleDataIntegrityViolationException(DataIntegrityViolationException ex, WebRequest request) {
    //    // ... lógica similar, retornando 409 Conflict ou 400 Bad Request dependendo do caso
    // }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\external\viacep\ViaCepResponse.java   |   package br.com.fiap.mottu.external.viacep   |   class ViaCepResponse
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\external\viacep\ViaCepResponse.java
package br.com.fiap.mottu.external.viacep; // Pacote atualizado

import com.fasterxml.jackson.annotation.JsonAlias;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ViaCepResponse {
    private String cep;
    private String logradouro;
    private String complemento;
    private String bairro;
    private String localidade; // Corresponde à cidade
    private String uf;         // Corresponde ao estado
    private String ibge;
    private String gia;
    private String ddd;
    private String siafi;

    @JsonAlias("erro")
    private Boolean erro;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\external\viacep\ViaCepService.java   |   package br.com.fiap.mottu.external.viacep   |   class ViaCepService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\external\viacep\ViaCepService.java
package br.com.fiap.mottu.external.viacep; // Pacote atualizado

import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono; // Para trabalhar com WebClient (assíncrono)

@Service
public class ViaCepService {

    private final WebClient webClient;

    public ViaCepService(WebClient.Builder webClientBuilder) {
        this.webClient = webClientBuilder.baseUrl("https://viacep.com.br/ws/").build();
    }

    public Mono<ViaCepResponse> buscarEnderecoPorCep(String cep) {
        String cleanCep = cep.replaceAll("[^0-9]", "");

        if (cleanCep.length() != 8) {
            return Mono.error(new IllegalArgumentException("CEP inválido. Deve conter 8 dígitos."));
        }

        return webClient.get()
                .uri("/{cep}/json/", cleanCep)
                .retrieve()
                .bodyToMono(ViaCepResponse.class)
                .flatMap(response -> {
                    if (response.getErro() != null && response.getErro()) {
                        return Mono.empty();
                    }
                    return Mono.just(response);
                });
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\filter\BoxFilter.java   |   package br.com.fiap.mottu.filter   |   class BoxFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\filter\BoxFilter.java
package br.com.fiap.mottu.filter;

import java.time.LocalDate;

public record BoxFilter(
        String nome,
        String status,
        LocalDate dataEntradaInicio,
        LocalDate dataEntradaFim,
        LocalDate dataSaidaInicio,
        LocalDate dataSaidaFim,
        String observacao
) {}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\filter\ClienteFilter.java   |   package br.com.fiap.mottu.filter   |   class ClienteFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\filter\ClienteFilter.java
package br.com.fiap.mottu.filter;

import java.time.LocalDate;

public record ClienteFilter(
        String nome,
        String sobrenome,
        String cpf,
        String sexo,
        String profissao,
        String estadoCivil,
        LocalDate dataCadastroInicio,
        LocalDate dataCadastroFim,
        LocalDate dataNascimentoInicio,
        LocalDate dataNascimentoFim,
        String enderecoCidade,
        String enderecoEstado,
        String contatoEmail,
        String contatoCelular,
        String veiculoPlaca,
        String veiculoModelo
) {}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\filter\ContatoFilter.java   |   package br.com.fiap.mottu.filter   |   class ContatoFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\filter\ContatoFilter.java
package br.com.fiap.mottu.filter;

public record ContatoFilter(
        String email,
        Integer ddd,
        Integer ddi,
        String telefone1,
        String celular,
        String observacao,
        String clienteNome // Filtro por cliente associado
) {}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\filter\EnderecoFilter.java   |   package br.com.fiap.mottu.filter   |   class EnderecoFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\filter\EnderecoFilter.java
package br.com.fiap.mottu.filter;

public record EnderecoFilter(
        String cep,
        Integer numero,
        String logradouro,
        String bairro,
        String cidade,
        String estado,
        String pais,
        String observacao,
        String clienteNome // Filtro por cliente associado
) {}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\filter\PatioFilter.java   |   package br.com.fiap.mottu.filter   |   class PatioFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\filter\PatioFilter.java
package br.com.fiap.mottu.filter;

import java.time.LocalDate;

public record PatioFilter(
        String nomePatio,
        LocalDate dataEntradaInicio,
        LocalDate dataEntradaFim,
        LocalDate dataSaidaInicio,
        LocalDate dataSaidaFim,
        String observacao,
        String veiculoPlaca, // Filtro por veículo associado (via junção)
        String enderecoCidade, // Filtro por endereço associado (via junção)
        String contatoEmail, // Filtro por contato associado (via junção)
        String zonaNome // Filtro por zona associada (via junção)
) {}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\filter\RastreamentoFilter.java   |   package br.com.fiap.mottu.filter   |   class RastreamentoFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.filter;

import java.math.BigDecimal; // Importe BigDecimal!

public record RastreamentoFilter(
        BigDecimal ipsX,
        BigDecimal ipsY,
        BigDecimal ipsZ,

        BigDecimal gprsLatitude,
        BigDecimal gprsLongitude,
        BigDecimal gprsAltitude,

        String veiculoPlaca // Filtro por veículo associado
) {}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\filter\VeiculoFilter.java   |   package br.com.fiap.mottu.filter   |   class VeiculoFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\filter\VeiculoFilter.java
package br.com.fiap.mottu.filter;

public record VeiculoFilter(
        String placa,
        String renavam,
        String chassi,
        String fabricante,
        String modelo,
        String motor,
        Integer ano,
        String combustivel,
        String clienteCpf, // Filtro por cliente associado (via junção)
        String boxNome, // Filtro por box associado (via junção)
        String patioNome, // Filtro por patio associado (via junção)
        String zonaNome // Filtro por zona associada (via junção)
) {}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\filter\ZonaFilter.java   |   package br.com.fiap.mottu.filter   |   class ZonaFilter
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\filter\ZonaFilter.java
package br.com.fiap.mottu.filter;

import java.time.LocalDate;

public record ZonaFilter(
        String nome,
        LocalDate dataEntradaInicio,
        LocalDate dataEntradaFim,
        LocalDate dataSaidaInicio,
        LocalDate dataSaidaFim,
        String observacao,
        String boxNome, // Filtro por box associado (via junção)
        String veiculoPlaca, // Filtro por veículo associado (via junção)
        String patioNome // Filtro por patio associado (via junção)
) {}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\mapper\BoxMapper.java   |   package br.com.fiap.mottu.mapper   |   class BoxMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.box.BoxRequestDto;
import br.com.fiap.mottu.dto.box.BoxResponseDto;
import br.com.fiap.mottu.model.Box;

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING,
        uses = {PatioMapper.class} // NOVO: Adicionar PatioMapper aqui, se necessário para o DTO (não estritamente necessário para esta feature, mas boa prática para o gráfico de dependências)
)
public interface BoxMapper {

    // Método 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    @Mapping(target = "idBox", ignore = true) // ID é gerado pelo BD
    @Mapping(target = "veiculoBoxes", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "zonaBoxes", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "patioBoxes", ignore = true) // NOVO: Ignorar coleção de relacionamento muitos-para-muitos
    Box toEntity(BoxRequestDto boxRequestDto);

    // Método 2: Atualização de uma Entidade existente a partir de um Request DTO
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idBox", ignore = true) // ID não é atualizado
    @Mapping(target = "veiculoBoxes", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "zonaBoxes", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "patioBoxes", ignore = true) // NOVO: Ignorar coleção de relacionamento muitos-para-muitos
    Box partialUpdate(BoxRequestDto boxRequestDto, @MappingTarget Box box);

    // Método 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    BoxResponseDto toResponseDto(Box box);
    // --- Métodos para mapear coleções (opcional) ---
    // List<BoxResponseDto> toResponseDtoList(List<Box> boxes);
    // Set<BoxResponseDto> toResponseDtoSet(Set<Box> boxes);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\mapper\ClienteMapper.java   |   package br.com.fiap.mottu.mapper   |   class ClienteMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\mapper\ClienteMapper.java
package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.cliente.ClienteRequestDto;
import br.com.fiap.mottu.dto.cliente.ClienteResponseDto;
import br.com.fiap.mottu.model.Cliente;

// Importe os mappers para os DTOs aninhados
import br.com.fiap.mottu.mapper.EnderecoMapper;
import br.com.fiap.mottu.mapper.ContatoMapper;
// Importar mapper para VeiculoResponseDto se ClienteResponseDto for incluí-lo
// import br.com.fiap.mottu.mapper.relacionamento.ClienteVeiculoMapper;
// import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto; // Para mapear para VeiculoResponseDto

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

import java.util.Set; // Necessário para mapear coleções
import java.util.stream.Collectors; // Necessário para stream() e collect()

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING,
        // Adiciona os mappers para os DTOs aninhados (Endereco e Contato)
        uses = { EnderecoMapper.class, ContatoMapper.class }
        // Se for mapear Set<ClienteVeiculo> para Set<VeiculoResponseDto>, precisará de um Mapper que faça isso.
        // Ex: uses = { EnderecoMapper.class, ContatoMapper.class, ClienteVeiculoMapper.class }
)
public interface ClienteMapper {

    // Método 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    // Mapeia ClienteRequestDto -> Cliente
    @Mapping(target = "idCliente", ignore = true) // ID é gerado pelo BD, ignore ao mapear Request para Entidade
    @Mapping(target = "dataCadastro", ignore = true) // dataCadastro é gerada pelo BD (DEFAULT SYSDATE), ignore ao mapear Request para Entidade
    @Mapping(target = "endereco", source = "enderecoRequestDto") // Mapeia o DTO de Endereco aninhado para a Entidade Endereco
    @Mapping(target = "contato", source = "contatoRequestDto") // Mapeia o DTO de Contato aninhado para a Entidade Contato
    @Mapping(target = "clienteVeiculos", ignore = true) // Relação Many-to-Many não é criada diretamente aqui
    Cliente toEntity(ClienteRequestDto clienteRequestDto);

    // Método 2: Atualização de uma Entidade existente a partir de um Request DTO
    // Mapeia ClienteRequestDto -> Cliente (existente)
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idCliente", ignore = true) // ID não é atualizado pelo DTO
    @Mapping(target = "dataCadastro", ignore = true) // Data de cadastro não é atualizada pelo DTO
    @Mapping(target = "endereco", source = "enderecoRequestDto") // Mapeia o DTO de Endereco aninhado para a Entidade Endereco existente no Cliente
    @Mapping(target = "contato", source = "contatoRequestDto") // Mapeia o DTO de Contato aninhado para a Entidade Contato existente no Cliente
    @Mapping(target = "clienteVeiculos", ignore = true) // Relação Many-to-Many não é atualizada diretamente aqui
    Cliente partialUpdate(ClienteRequestDto clienteRequestDto, @MappingTarget Cliente cliente);

    // Método 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    // Mapeia Cliente -> ClienteResponseDto
    @Mapping(target = "enderecoResponseDto", source = "endereco") // Mapeia a Entidade Endereco para o DTO de Endereco aninhado no Response
    @Mapping(target = "contatoResponseDto", source = "contato") // Mapeia a Entidade Contato para o DTO de Contato aninhado no Response
    // Se ClienteResponseDto tiver campos de coleções (ex: Set<VeiculoResponseDto> veiculos)
    // Você precisaria de um método @Named para fazer essa conversão se ClienteVeiculoMapper não for suficiente,
    // ou um método diretamente no mapper se a lógica for simples.
    // Exemplo: @Mapping(target = "veiculos", expression = "java(mapClienteVeiculosToVeiculoResponseDtos(cliente.getClienteVeiculos()))")
    ClienteResponseDto toResponseDto(Cliente cliente);

    // Exemplo de método para mapear Set<ClienteVeiculo> para Set<VeiculoResponseDto>
    // Este método pode ser um @Named ou um método privado na interface se for Java 8 default methods
    /*
    default Set<VeiculoResponseDto> mapClienteVeiculosToVeiculoResponseDtos(Set<br.com.fiap.mottu.model.relacionamento.ClienteVeiculo> clienteVeiculos) {
        if (clienteVeiculos == null) {
            return null;
        }
        // Assume que você tem um VeiculoMapper injetável para converter Veiculo para VeiculoResponseDto
        // Ou que o ClienteVeiculoMapper tem um método para mapear para VeiculoResponseDto
        return clienteVeiculos.stream()
                .map(ClienteVeiculo::getVeiculo) // Pega a entidade Veiculo da associação
                .map(veiculo -> SpringApplicationContext.getBean(VeiculoMapper.class).toResponseDto(veiculo)) // Necessita de um mecanismo para obter o bean do mapper
                .collect(Collectors.toSet());
    }
    */

    // --- Métodos para mapear coleções (opcional) ---
    // List<ClienteResponseDto> toResponseDtoList(List<Cliente> clientes);
    // Set<ClienteResponseDto> toResponseDtoSet(Set<Cliente> clientes);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\mapper\ContatoMapper.java   |   package br.com.fiap.mottu.mapper   |   class ContatoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\mapper\ContatoMapper.java
package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.contato.ContatoRequestDto;
import br.com.fiap.mottu.dto.contato.ContatoResponseDto;
import br.com.fiap.mottu.model.Contato;

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

// Importe os mappers das entidades relacionadas se ContatoResponseDto tiver DTOs aninhados ou coleções de DTOs delas
// import br.com.fiap.mottu.mapper.ClienteMapper; // Exemplo se ContatoResponseDto incluir Cliente associado
// import br.com.fiap.mottu.mapper.relacionamento.ContatoPatioMapper; // Exemplo se ContatoResponseDto incluir Patio associado

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING
        // Adicione aqui o 'uses' se ContatoResponseDto incluir DTOs aninhados ou coleções
        // uses = { ClienteMapper.class, ContatoPatioMapper.class }
)
public interface ContatoMapper {

    // Método 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    @Mapping(target = "idContato", ignore = true) // ID é gerado pelo BD
    @Mapping(target = "clienteContatos", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "contatoPatios", ignore = true) // Relacionamento inverso não é mapeado na criação
    Contato toEntity(ContatoRequestDto contatoRequestDto);

    // Método 2: Atualização de uma Entidade existente a partir de Request DTO
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idContato", ignore = true) // ID não é atualizado
    @Mapping(target = "clienteContatos", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "contatoPatios", ignore = true) // Relacionamento inverso não é atualizado
    Contato partialUpdate(ContatoRequestDto contatoRequestDto, @MappingTarget Contato contato);

    // Método 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    ContatoResponseDto toResponseDto(Contato contato);

    // --- Métodos para mapear coleções (opcional) ---
    // List<ContatoResponseDto> toResponseDtoList(List<Contato> contatos);
    // Set<ContatoResponseDto> toResponseDtoSet(Set<Contato> contatos);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\mapper\EnderecoMapper.java   |   package br.com.fiap.mottu.mapper   |   class EnderecoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\mapper\EnderecoMapper.java
package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.endereco.EnderecoRequestDto;
import br.com.fiap.mottu.dto.endereco.EnderecoResponseDto;
import br.com.fiap.mottu.model.Endereco;

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

// Importe os mappers das entidades relacionadas se EnderecoResponseDto tiver DTOs aninhados ou coleções de DTOs delas
// import br.com.fiap.mottu.mapper.ClienteMapper; // Exemplo se EnderecoResponseDto incluir Cliente associado
// import br.com.fiap.mottu.mapper.relacionamento.EnderecoPatioMapper; // Exemplo se EnderecoResponseDto incluir Patio associado

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING
        // Adicione aqui o 'uses' se EnderecoResponseDto incluir DTOs aninhados ou coleções
        // uses = { ClienteMapper.class, EnderecoPatioMapper.class }
)
public interface EnderecoMapper {

    // Método 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    @Mapping(target = "idEndereco", ignore = true) // ID é gerado pelo BD
    @Mapping(target = "clienteEnderecos", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "enderecoPatios", ignore = true) // Relacionamento inverso não é mapeado na criação
    Endereco toEntity(EnderecoRequestDto enderecoRequestDto);

    // Método 2: Atualização de uma Entidade existente a partir de Request DTO
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idEndereco", ignore = true) // ID não é atualizado
    @Mapping(target = "clienteEnderecos", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "enderecoPatios", ignore = true) // Relacionamento inverso não é atualizado
    Endereco partialUpdate(EnderecoRequestDto enderecoRequestDto, @MappingTarget Endereco endereco);

    // Método 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    EnderecoResponseDto toResponseDto(Endereco endereco);

    // --- Métodos para mapear coleções (opcional) ---
    // List<EnderecoResponseDto> toResponseDtoList(List<Endereco> enderecos);
    // Set<EnderecoResponseDto> toResponseDtoSet(Set<Endereco> enderecos);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\mapper\PatioMapper.java   |   package br.com.fiap.mottu.mapper   |   class PatioMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.patio.PatioRequestDto;
import br.com.fiap.mottu.dto.patio.PatioResponseDto;
import br.com.fiap.mottu.model.Patio;

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING,
        uses = {BoxMapper.class} // NOVO: Adicionar BoxMapper aqui
)
public interface PatioMapper {

    // Método 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    @Mapping(target = "idPatio", ignore = true) // ID é gerado pelo BD
    @Mapping(target = "contatoPatios", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "enderecoPatios", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "veiculoPatios", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "zonaPatios", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "patioBoxes", ignore = true) // NOVO: Ignorar coleção de relacionamento muitos-para-muitos
    Patio toEntity(PatioRequestDto patioRequestDto);

    // Método 2: Atualização de uma Entidade existente a partir de Request DTO
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idPatio", ignore = true) // ID não é atualizado
    @Mapping(target = "contatoPatios", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "enderecoPatios", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "veiculoPatios", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "zonaPatios", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "patioBoxes", ignore = true) // NOVO: Ignorar coleção de relacionamento muitos-para-muitos
    Patio partialUpdate(PatioRequestDto patioRequestDto, @MappingTarget Patio patio);

    // Método 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    PatioResponseDto toResponseDto(Patio patio);
    // List<PatioResponseDto> toResponseDtoList(List<Patio> patios);
    // Set<PatioResponseDto> toResponseDtoSet(Set<Patio> patios);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\mapper\RastreamentoMapper.java   |   package br.com.fiap.mottu.mapper   |   class RastreamentoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.rastreamento.RastreamentoRequestDto;
import br.com.fiap.mottu.dto.rastreamento.RastreamentoResponseDto;
import br.com.fiap.mottu.model.Rastreamento;
import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

import java.math.BigDecimal; // Importe BigDecimal!

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING
)
public interface RastreamentoMapper {

    @Mapping(target = "idRastreamento", ignore = true)
    @Mapping(target = "veiculoRastreamentos", ignore = true)
    @Mapping(target = "ipsX", source = "ipsX")
    @Mapping(target = "ipsY", source = "ipsY")
    @Mapping(target = "ipsZ", source = "ipsZ")
    @Mapping(target = "gprsLatitude", source = "gprsLatitude")
    @Mapping(target = "gprsLongitude", source = "gprsLongitude")
    @Mapping(target = "gprsAltitude", source = "gprsAltitude")
    Rastreamento toEntity(RastreamentoRequestDto rastreamentoRequestDto);

    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idRastreamento", ignore = true)
    @Mapping(target = "veiculoRastreamentos", ignore = true)
    @Mapping(target = "ipsX", source = "ipsX")
    @Mapping(target = "ipsY", source = "ipsY")
    @Mapping(target = "ipsZ", source = "ipsZ")
    @Mapping(target = "gprsLatitude", source = "gprsLatitude")
    @Mapping(target = "gprsLongitude", source = "gprsLongitude")
    @Mapping(target = "gprsAltitude", source = "gprsAltitude")
    Rastreamento partialUpdate(RastreamentoRequestDto dto, @MappingTarget Rastreamento rastreamento);

    @Mapping(target = "ipsX", source = "ipsX")
    @Mapping(target = "ipsY", source = "ipsY")
    @Mapping(target = "ipsZ", source = "ipsZ")
    @Mapping(target = "gprsLatitude", source = "gprsLatitude")
    @Mapping(target = "gprsLongitude", source = "gprsLongitude")
    @Mapping(target = "gprsAltitude", source = "gprsAltitude")
    RastreamentoResponseDto toResponseDto(Rastreamento rastreamento);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\mapper\VeiculoMapper.java   |   package br.com.fiap.mottu.mapper   |   class VeiculoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\mapper\VeiculoMapper.java
package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.veiculo.VeiculoRequestDto;
import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.mottu.model.Veiculo;

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

// Importe os mappers das entidades relacionadas se VeiculoRequestDto ou VeiculoResponseDto tiverem DTOs aninhados ou coleções de DTOs delas
// import br.com.fiap.mottu.mapper.relacionamento.ClienteVeiculoMapper;
// import br.com.fiap.mottu.mapper.relacionamento.VeiculoBoxMapper;
// import br.com.fiap.mottu.mapper.relacionamento.VeiculoPatioMapper;
// import br.com.fiap.mottu.mapper.relacionamento.VeiculoRastreamentoMapper;
// import br.com.fiap.mottu.mapper.relacionamento.VeiculoZonaMapper;

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING
        // Adicione aqui o 'uses' se VeiculoRequestDto ou VeiculoResponseDto incluirem DTOs aninhados ou coleções
        // uses = { ClienteVeiculoMapper.class, VeiculoBoxMapper.class, VeiculoPatioMapper.class, VeiculoRastreamentoMapper.class, VeiculoZonaMapper.class }
)
public interface VeiculoMapper {

    // Método 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    @Mapping(target = "idVeiculo", ignore = true) // ID é gerado pelo BD
    @Mapping(target = "clienteVeiculos", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "veiculoBoxes", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "veiculoPatios", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "veiculoRastreamentos", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "veiculoZonas", ignore = true) // Relacionamento inverso não é mapeado na criação
    Veiculo toEntity(VeiculoRequestDto veiculoRequestDto);

    // Método 2: Atualização de uma Entidade existente a partir de Request DTO
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idVeiculo", ignore = true) // ID não é atualizado
    @Mapping(target = "clienteVeiculos", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "veiculoBoxes", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "veiculoPatios", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "veiculoRastreamentos", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "veiculoZonas", ignore = true) // Relacionamento inverso não é atualizado
    Veiculo partialUpdate(VeiculoRequestDto veiculoRequestDto, @MappingTarget Veiculo veiculo);

    // Método 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    VeiculoResponseDto toResponseDto(Veiculo veiculo);

    // --- Métodos para mapear coleções (opcional) ---
    // List<VeiculoResponseDto> toResponseDtoList(List<Veiculo> veiculos);
    // Set<VeiculoResponseDto> toResponseDtoSet(Set<Veiculo> veiculos);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\mapper\ZonaMapper.java   |   package br.com.fiap.mottu.mapper   |   class ZonaMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\mapper\ZonaMapper.java
package br.com.fiap.mottu.mapper;

import br.com.fiap.mottu.dto.zona.ZonaRequestDto;
import br.com.fiap.mottu.dto.zona.ZonaResponseDto;
import br.com.fiap.mottu.model.Zona;

import org.mapstruct.*;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.MappingConstants;

// Importe os mappers das entidades relacionadas se ZonaRequestDto ou ZonaResponseDto tiverem DTOs aninhados ou coleções de DTOs delas
// import br.com.fiap.mottu.mapper.relacionamento.VeiculoZonaMapper;
// import br.com.fiap.mottu.mapper.relacionamento.ZonaBoxMapper;
// import br.com.fiap.mottu.mapper.relacionamento.ZonaPatioMapper;

@Mapper(
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        componentModel = MappingConstants.ComponentModel.SPRING
        // Adicione aqui o 'uses' se ZonaRequestDto ou ZonaResponseDto incluirem DTOs aninhados ou coleções
        // uses = { VeiculoZonaMapper.class, ZonaBoxMapper.class, ZonaPatioMapper.class }
)
public interface ZonaMapper {

    // Método 1: Converte de Request DTO para Entidade (para CRIAR uma nova)
    @Mapping(target = "idZona", ignore = true) // ID é gerado pelo BD
    @Mapping(target = "veiculoZonas", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "zonaBoxes", ignore = true) // Relacionamento inverso não é mapeado na criação
    @Mapping(target = "zonaPatios", ignore = true) // Relacionamento inverso não é mapeado na criação
    Zona toEntity(ZonaRequestDto zonaRequestDto);

    // Método 2: Atualização de uma Entidade existente a partir de Request DTO
    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "idZona", ignore = true) // ID não é atualizado
    @Mapping(target = "veiculoZonas", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "zonaBoxes", ignore = true) // Relacionamento inverso não é atualizado
    @Mapping(target = "zonaPatios", ignore = true) // Relacionamento inverso não é atualizado
    Zona partialUpdate(ZonaRequestDto zonaRequestDto, @MappingTarget Zona zona);

    // Método 3: Converte de Entidade para DTO de Resposta (ESSENCIAL para consultas)
    ZonaResponseDto toResponseDto(Zona zona);

    // --- Métodos para mapear coleções (opcional) ---
    // List<ZonaResponseDto> toResponseDtoList(List<Zona> zonas);
    // Set<ZonaResponseDto> toResponseDtoSet(Set<Zona> zonas);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\Box.java   |   package br.com.fiap.mottu.model   |   class Box
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "TB_BOX", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido 'exclude = {...}'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Box {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_BOX")
    @EqualsAndHashCode.Include
    private Long idBox;

    @Column(name = "NOME", nullable = false, length = 50)
    private String nome;

    @Column(name = "STATUS", nullable = false, length = 1)
    private String status;

    @Column(name = "DATA_ENTRADA", nullable = false)
    private LocalDate dataEntrada;

    @Column(name = "DATA_SAIDA", nullable = false)
    private LocalDate dataSaida;

    @Column(name = "OBSERVACAO", length = 100)
    private String observacao;

    // Relacionamentos inversos para tabelas de junção
    @OneToMany(mappedBy = "box", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotação já exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoBox> veiculoBoxes = new HashSet<>();

    @OneToMany(mappedBy = "box", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotação já exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ZonaBox> zonaBoxes = new HashSet<>();

    // Relacionamento inverso para PatioBox
    @OneToMany(mappedBy = "box", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotação já exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.PatioBox> patioBoxes = new HashSet<>();
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\Cliente.java   |   package br.com.fiap.mottu.model   |   class Cliente
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\Cliente.java
package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "TB_CLIENTE", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Cliente {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_CLIENTE")
    @EqualsAndHashCode.Include
    private Long idCliente;
    @Column(name = "DATA_CADASTRO", nullable = false, updatable = false)
    private LocalDate dataCadastro;

    @Column(name = "SEXO", nullable = false, length = 2) // Linha a ser restaurada para este estado
    private String sexo;
    @Column(name = "NOME", nullable = false, length = 100)
    private String nome;
    @Column(name = "SOBRENOME", nullable = false, length = 100)
    private String sobrenome;
    @Column(name = "DATA_NASCIMENTO", nullable = false)
    private LocalDate dataNascimento;
    @Column(name = "CPF", nullable = false, unique = true, length = 11) // Linha a ser restaurada para este estado
    private String cpf;
    @Column(name = "PROFISSAO", nullable = false, length = 50)
    private String profissao;
    @Column(name = "ESTADO_CIVIL", nullable = false, length = 50)
    private String estadoCivil;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "TB_ENDERECO_ID_ENDERECO", nullable = false)
    @ToString.Exclude
    private Endereco endereco;
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "TB_CONTATO_ID_CONTATO", nullable = false)
    @ToString.Exclude
    private Contato contato;
    @OneToMany(mappedBy = "cliente", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ClienteVeiculo> clienteVeiculos = new HashSet<>();
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\Contato.java   |   package br.com.fiap.mottu.model   |   class Contato
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\Contato.java
package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.util.HashSet;
import java.util.Set;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "TB_CONTATO", schema = "CHALLENGE")
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Contato {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_CONTATO")
    @EqualsAndHashCode.Include
    private Long idContato;
    @Column(name = "EMAIL", nullable = false, length = 100)
    private String email;
    @Column(name = "DDD", nullable = false, precision = 4, scale = 0)
    private Integer ddd;
    @Column(name = "DDI", nullable = false, precision = 4, scale = 0)
    private Integer ddi;
    @Column(name = "TELEFONE1", nullable = false, length = 20)
    private String telefone1;
    @Column(name = "TELEFONE2", length = 20)
    private String telefone2;
    @Column(name = "TELEFONE3", length = 20)
    private String telefone3;
    @Column(name = "CELULAR", nullable = false, length = 20)
    private String celular;
    @Column(name = "OUTRO", length = 100)
    private String outro;
    @Column(name = "OBSERVACAO", length = 200)
    private String observacao;

    @OneToMany(mappedBy = "contato", cascade = CascadeType.ALL)
    @ToString.Exclude // MANTER esta anotação no campo
    @Builder.Default
    private Set<Cliente> clienteContatos = new HashSet<>();
    @OneToMany(mappedBy = "contato", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // MANTER esta anotação no campo
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ContatoPatio> contatoPatios = new HashSet<>();
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\Endereco.java   |   package br.com.fiap.mottu.model   |   class Endereco
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\Endereco.java
package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.util.HashSet;
import java.util.Set;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "TB_ENDERECO", schema = "CHALLENGE")
@ToString
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Endereco {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_ENDERECO")
    @EqualsAndHashCode.Include
    private Long idEndereco;
    @Column(name = "CEP", nullable = false, length = 9) // Linha a ser restaurada para este estado
    private String cep;
    @Column(name = "NUMERO", nullable = false, precision = 7, scale = 0)
    private Integer numero;
    @Column(name = "LOGRADOURO", nullable = false, length = 50)
    private String logradouro;
    @Column(name = "BAIRRO", nullable = false, length = 50)
    private String bairro;
    @Column(name = "CIDADE", nullable = false, length = 50)
    private String cidade;
    @Column(name = "ESTADO", nullable = false, length = 2) // Linha a ser restaurada para este estado
    private String estado;
    @Column(name = "PAIS", nullable = false, length = 50)
    private String pais;
    @Column(name = "COMPLEMENTO", length = 60)
    private String complemento;
    @Column(name = "OBSERVACAO", length = 200)
    private String observacao;
    // Relacionamentos inversos
    @OneToMany(mappedBy = "endereco", cascade = CascadeType.ALL)
    @ToString.Exclude
    @Builder.Default
    private Set<Cliente> clienteEnderecos = new HashSet<>();
    @OneToMany(mappedBy = "endereco", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.EnderecoPatio> enderecoPatios = new HashSet<>();
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\Patio.java   |   package br.com.fiap.mottu.model   |   class Patio
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "TB_PATIO", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido 'exclude = {...}'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Patio {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_PATIO")
    @EqualsAndHashCode.Include
    private Long idPatio;

    @Column(name = "NOME_PATIO", nullable = false, length = 50)
    private String nomePatio;

    @Column(name = "DATA_ENTRADA", nullable = false)
    private LocalDate dataEntrada;

    @Column(name = "DATA_SAIDA", nullable = false)
    private LocalDate dataSaida;

    @Column(name = "OBSERVACAO", length = 100)
    private String observacao;

    @OneToMany(mappedBy = "patio", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotação já exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ContatoPatio> contatoPatios = new HashSet<>();

    @OneToMany(mappedBy = "patio", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotação já exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.EnderecoPatio> enderecoPatios = new HashSet<>();

    @OneToMany(mappedBy = "patio", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotação já exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoPatio> veiculoPatios = new HashSet<>();

    @OneToMany(mappedBy = "patio", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotação já exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ZonaPatio> zonaPatios = new HashSet<>();

    // Relacionamento inverso para PatioBox
    @OneToMany(mappedBy = "patio", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // Esta anotação já exclui o campo do toString
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.PatioBox> patioBoxes = new HashSet<>();
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\Rastreamento.java   |   package br.com.fiap.mottu.model   |   class Rastreamento
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal; // Importe BigDecimal!
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "TB_RASTREAMENTO", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Rastreamento {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_RASTREAMENTO")
    @EqualsAndHashCode.Include
    private Long idRastreamento;

    // Campos para IPS com BigDecimal e precisão 7,3
    @Column(name = "IPS_X", nullable = false, precision = 7, scale = 3)
    private BigDecimal ipsX;

    @Column(name = "IPS_Y", nullable = false, precision = 7, scale = 3)
    private BigDecimal ipsY;

    @Column(name = "IPS_Z", nullable = false, precision = 7, scale = 3)
    private BigDecimal ipsZ;

    // Campos para GPRS com BigDecimal e precisão 11,6 (Latitude/Longitude) e 7,2 (Altitude)
    @Column(name = "GPRS_LATITUDE", nullable = false, precision = 11, scale = 6)
    private BigDecimal gprsLatitude;

    @Column(name = "GPRS_LONGITUDE", nullable = false, precision = 11, scale = 6)
    private BigDecimal gprsLongitude;

    @Column(name = "GPRS_ALTITUDE", nullable = false, precision = 7, scale = 2)
    private BigDecimal gprsAltitude;

    @OneToMany(mappedBy = "rastreamento", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoRastreamento> veiculoRastreamentos = new HashSet<>();
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\Veiculo.java   |   package br.com.fiap.mottu.model   |   class Veiculo
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\Veiculo.java
package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "TB_VEICULO", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Veiculo {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_VEICULO")
    @EqualsAndHashCode.Include
    private Long idVeiculo;
    @Column(name = "PLACA", nullable = false, unique = true, length = 10)
    private String placa;
    @Column(name = "RENAVAM", nullable = false, unique = true, length = 11) // Linha a ser restaurada para este estado
    private String renavam;
    @Column(name = "CHASSI", nullable = false, unique = true, length = 17) // Linha a ser restaurada para este estado
    private String chassi;
    @Column(name = "FABRICANTE", nullable = false, length = 50)
    private String fabricante;
    @Column(name = "MODELO", nullable = false, length = 60)
    private String modelo;
    @Column(name = "MOTOR", length = 30)
    private String motor;
    @Column(name = "ANO", nullable = false)
    private Integer ano;
    @Column(name = "COMBUSTIVEL", nullable = false, length = 20)
    private String combustivel;
    // Relacionamentos inversos
    @OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ClienteVeiculo> clienteVeiculos = new HashSet<>();
    @OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoBox> veiculoBoxes = new HashSet<>();
    @OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoPatio> veiculoPatios = new HashSet<>();
    @OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoRastreamento> veiculoRastreamentos = new HashSet<>();
    @OneToMany(mappedBy = "veiculo", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoZona> veiculoZonas = new HashSet<>();
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\Zona.java   |   package br.com.fiap.mottu.model   |   class Zona
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\Zona.java
package br.com.fiap.mottu.model;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "TB_ZONA", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Zona {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_ZONA")
    @EqualsAndHashCode.Include
    private Long idZona;
    @Column(name = "NOME", nullable = false, length = 50)
    private String nome;
    @Column(name = "DATA_ENTRADA", nullable = false)
    private LocalDate dataEntrada;
    @Column(name = "DATA_SAIDA", nullable = false)
    private LocalDate dataSaida;
    @Column(name = "OBSERVACAO", length = 100)
    private String observacao;

    @OneToMany(mappedBy = "zona", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // MANTER esta anotação no campo
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.VeiculoZona> veiculoZonas = new HashSet<>();
    @OneToMany(mappedBy = "zona", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // MANTER esta anotação no campo
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ZonaBox> zonaBoxes = new HashSet<>();
    @OneToMany(mappedBy = "zona", cascade = CascadeType.ALL, orphanRemoval = true)
    @ToString.Exclude // MANTER esta anotação no campo
    @Builder.Default
    private Set<br.com.fiap.mottu.model.relacionamento.ZonaPatio> zonaPatios = new HashSet<>();
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\relacionamento\ClienteVeiculo.java   |   package br.com.fiap.mottu.model.relacionamento   |   class ClienteVeiculo
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\ClienteVeiculo.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Cliente;
import br.com.fiap.mottu.model.Veiculo;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_CLIENTEVEICULO", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class ClienteVeiculo {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private ClienteVeiculoId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("clienteId")
    @JoinColumn(name = "TB_CLIENTE_ID_CLIENTE", referencedColumnName = "ID_CLIENTE", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Cliente cliente;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("veiculoId")
    @JoinColumn(name = "TB_VEICULO_ID_VEICULO", referencedColumnName = "ID_VEICULO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Veiculo veiculo;

    public ClienteVeiculo(Cliente cliente, Veiculo veiculo) {
        this.cliente = cliente;
        this.veiculo = veiculo;
        this.id = new ClienteVeiculoId(
                cliente.getIdCliente(),
                cliente.getEndereco() != null ? cliente.getEndereco().getIdEndereco() : null,
                cliente.getContato() != null ? cliente.getContato().getIdContato() : null,
                veiculo.getIdVeiculo()
        );
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\relacionamento\ClienteVeiculoId.java   |   package br.com.fiap.mottu.model.relacionamento   |   class ClienteVeiculoId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\ClienteVeiculoId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode // Essencial para PKs compostas
public class ClienteVeiculoId implements Serializable {

    @Column(name = "TB_CLIENTE_ID_CLIENTE", nullable = false)
    private Long clienteId;

    @Column(name = "TB_CLIENTE_TB_ENDERECO_ID_ENDERECO", nullable = false)
    private Long clienteEnderecoId;

    @Column(name = "TB_CLIENTE_TB_CONTATO_ID_CONTATO", nullable = false)
    private Long clienteContatoId;

    @Column(name = "TB_VEICULO_ID_VEICULO", nullable = false)
    private Long veiculoId;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\relacionamento\ContatoPatio.java   |   package br.com.fiap.mottu.model.relacionamento   |   class ContatoPatio
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\ContatoPatio.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Contato;
import br.com.fiap.mottu.model.Patio;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_CONTATOPATIO", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class ContatoPatio {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private ContatoPatioId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("patioId")
    @JoinColumn(name = "TB_PATIO_ID_PATIO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Patio patio;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("contatoId")
    @JoinColumn(name = "TB_CONTATO_ID_CONTATO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Contato contato;

    public ContatoPatio(Patio patio, Contato contato) {
        this.patio = patio;
        this.contato = contato;
        this.id = new ContatoPatioId(patio.getIdPatio(), contato.getIdContato());
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\relacionamento\ContatoPatioId.java   |   package br.com.fiap.mottu.model.relacionamento   |   class ContatoPatioId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\ContatoPatioId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class ContatoPatioId implements Serializable {

    @Column(name = "TB_PATIO_ID_PATIO", nullable = false)
    private Long patioId;

    @Column(name = "TB_CONTATO_ID_CONTATO", nullable = false)
    private Long contatoId;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\relacionamento\EnderecoPatio.java   |   package br.com.fiap.mottu.model.relacionamento   |   class EnderecoPatio
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\EnderecoPatio.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Endereco;
import br.com.fiap.mottu.model.Patio;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_ENDERECIOPATIO", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class EnderecoPatio {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private EnderecoPatioId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("enderecoId")
    @JoinColumn(name = "TB_ENDERECO_ID_ENDERECO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Endereco endereco;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("patioId")
    @JoinColumn(name = "TB_PATIO_ID_PATIO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Patio patio;

    public EnderecoPatio(Endereco endereco, Patio patio) {
        this.endereco = endereco;
        this.patio = patio;
        this.id = new EnderecoPatioId(endereco.getIdEndereco(), patio.getIdPatio());
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\relacionamento\EnderecoPatioId.java   |   package br.com.fiap.mottu.model.relacionamento   |   class EnderecoPatioId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\EnderecoPatioId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class EnderecoPatioId implements Serializable {

    @Column(name = "TB_ENDERECO_ID_ENDERECO", nullable = false)
    private Long enderecoId;

    @Column(name = "TB_PATIO_ID_PATIO", nullable = false)
    private Long patioId;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\relacionamento\PatioBox.java   |   package br.com.fiap.mottu.model.relacionamento   |   class PatioBox
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Patio;
import br.com.fiap.mottu.model.Box;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_PATIOBOX", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor // NOVO: Adicione esta anotação para que Lombok gere um construtor com todos os campos.
@Builder
@ToString
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class PatioBox {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private PatioBoxId id;

    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("patioId") // Mapeia o campo 'patioId' da chave composta
    @JoinColumn(name = "TB_PATIO_ID_PATIO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude
    private Patio patio;

    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("boxId") // Mapeia o campo 'boxId' da chave composta
    @JoinColumn(name = "TB_BOX_ID_BOX", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude
    private Box box;

    // Construtor para facilitar a criação da associação (este construtor é mantido, Lombok gerará o @AllArgsConstructor também)
    public PatioBox(Patio patio, Box box) {
        this.patio = patio;
        this.box = box;
        // Garanta que getIdBox() existe na sua classe Box ou use o nome correto do getter do ID do Box
        this.id = new PatioBoxId(patio.getIdPatio(), box.getIdBox());
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\relacionamento\PatioBoxId.java   |   package br.com.fiap.mottu.model.relacionamento   |   class PatioBoxId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode // Essencial para PKs compostas
public class PatioBoxId implements Serializable {

    @Column(name = "TB_PATIO_ID_PATIO", nullable = false)
    private Long patioId;

    @Column(name = "TB_BOX_ID_BOX", nullable = false)
    private Long boxId;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoBox.java   |   package br.com.fiap.mottu.model.relacionamento   |   class VeiculoBox
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoBox.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Box;
import br.com.fiap.mottu.model.Veiculo;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_VEICULOBOX", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class VeiculoBox {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private VeiculoBoxId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("veiculoId")
    @JoinColumn(name = "TB_VEICULO_ID_VEICULO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Veiculo veiculo;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("boxId")
    @JoinColumn(name = "TB_BOX_ID_BOX", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Box box;

    public VeiculoBox(Veiculo veiculo, Box box) {
        this.veiculo = veiculo;
        this.box = box;
        this.id = new VeiculoBoxId(veiculo.getIdVeiculo(), box.getIdBox());
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoBoxId.java   |   package br.com.fiap.mottu.model.relacionamento   |   class VeiculoBoxId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\VeiculoBoxId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class VeiculoBoxId implements Serializable {

    @Column(name = "TB_VEICULO_ID_VEICULO", nullable = false)
    private Long veiculoId;

    @Column(name = "TB_BOX_ID_BOX", nullable = false)
    private Long boxId;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoPatio.java   |   package br.com.fiap.mottu.model.relacionamento   |   class VeiculoPatio
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoPatio.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Patio;
import br.com.fiap.mottu.model.Veiculo;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_VEICULOPATIO", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class VeiculoPatio {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private VeiculoPatioId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("veiculoId")
    @JoinColumn(name = "TB_VEICULO_ID_VEICULO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Veiculo veiculo;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("patioId")
    @JoinColumn(name = "TB_PATIO_ID_PATIO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Patio patio;

    public VeiculoPatio(Veiculo veiculo, Patio patio) {
        this.veiculo = veiculo;
        this.patio = patio;
        this.id = new VeiculoPatioId(veiculo.getIdVeiculo(), patio.getIdPatio());
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoPatioId.java   |   package br.com.fiap.mottu.model.relacionamento   |   class VeiculoPatioId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\VeiculoPatioId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class VeiculoPatioId implements Serializable {

    @Column(name = "TB_VEICULO_ID_VEICULO", nullable = false)
    private Long veiculoId;

    @Column(name = "TB_PATIO_ID_PATIO", nullable = false)
    private Long patioId;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoRastreamento.java   |   package br.com.fiap.mottu.model.relacionamento   |   class VeiculoRastreamento
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoRastreamento.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Rastreamento;
import br.com.fiap.mottu.model.Veiculo;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_VEICULORASTREAMENTO", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class VeiculoRastreamento {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private VeiculoRastreamentoId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("veiculoId")
    @JoinColumn(name = "TB_VEICULO_ID_VEICULO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Veiculo veiculo;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("rastreamentoId")
    @JoinColumn(name = "TB_RASTREAMENTO_ID_RASTREAMENTO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Rastreamento rastreamento;

    public VeiculoRastreamento(Veiculo veiculo, Rastreamento rastreamento) {
        this.veiculo = veiculo;
        this.rastreamento = rastreamento;
        this.id = new VeiculoRastreamentoId(veiculo.getIdVeiculo(), rastreamento.getIdRastreamento());
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoRastreamentoId.java   |   package br.com.fiap.mottu.model.relacionamento   |   class VeiculoRastreamentoId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\VeiculoRastreamentoId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class VeiculoRastreamentoId implements Serializable {

    @Column(name = "TB_VEICULO_ID_VEICULO", nullable = false)
    private Long veiculoId;

    @Column(name = "TB_RASTREAMENTO_ID_RASTREAMENTO", nullable = false)
    private Long rastreamentoId;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoZona.java   |   package br.com.fiap.mottu.model.relacionamento   |   class VeiculoZona
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoZona.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Veiculo;
import br.com.fiap.mottu.model.Zona;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_VEICULOZONA", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class VeiculoZona {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private VeiculoZonaId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("veiculoId")
    @JoinColumn(name = "TB_VEICULO_ID_VEICULO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Veiculo veiculo;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("zonaId")
    @JoinColumn(name = "TB_ZONA_ID_ZONA", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Zona zona;

    public VeiculoZona(Veiculo veiculo, Zona zona) {
        this.veiculo = veiculo;
        this.zona = zona;
        this.id = new VeiculoZonaId(veiculo.getIdVeiculo(), zona.getIdZona());
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\relacionamento\VeiculoZonaId.java   |   package br.com.fiap.mottu.model.relacionamento   |   class VeiculoZonaId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\VeiculoZonaId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class VeiculoZonaId implements Serializable {

    @Column(name = "TB_VEICULO_ID_VEICULO", nullable = false)
    private Long veiculoId;

    @Column(name = "TB_ZONA_ID_ZONA", nullable = false)
    private Long zonaId;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\relacionamento\ZonaBox.java   |   package br.com.fiap.mottu.model.relacionamento   |   class ZonaBox
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\ZonaBox.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Box;
import br.com.fiap.mottu.model.Zona;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_ZONABOX", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class ZonaBox {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private ZonaBoxId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("zonaId")
    @JoinColumn(name = "TB_ZONA_ID_ZONA", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Zona zona;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("boxId")
    @JoinColumn(name = "TB_BOX_ID_BOX", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Box box;

    public ZonaBox(Zona zona, Box box) {
        this.zona = zona;
        this.box = box;
        this.id = new ZonaBoxId(zona.getIdZona(), box.getIdBox());
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\relacionamento\ZonaBoxId.java   |   package br.com.fiap.mottu.model.relacionamento   |   class ZonaBoxId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\ZonaBoxId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class ZonaBoxId implements Serializable {

    @Column(name = "TB_ZONA_ID_ZONA", nullable = false)
    private Long zonaId;

    @Column(name = "TB_BOX_ID_BOX", nullable = false)
    private Long boxId;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\relacionamento\ZonaPatio.java   |   package br.com.fiap.mottu.model.relacionamento   |   class ZonaPatio
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// main\java\br\com\fiap\mottu\model\relacionamento\ZonaPatio.java
package br.com.fiap.mottu.model.relacionamento;

import br.com.fiap.mottu.model.Patio;
import br.com.fiap.mottu.model.Zona;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "TB_ZONAPATIO", schema = "CHALLENGE")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString // CORRIGIDO: Removido o parâmetro 'exclude'
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class ZonaPatio {

    @EmbeddedId
    @EqualsAndHashCode.Include
    private ZonaPatioId id;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("patioId")
    @JoinColumn(name = "TB_PATIO_ID_PATIO", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Patio patio;
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("zonaId")
    @JoinColumn(name = "TB_ZONA_ID_ZONA", nullable = false, insertable = false, updatable = false)
    @ToString.Exclude // MANTER esta anotação no campo
    private Zona zona;

    public ZonaPatio(Patio patio, Zona zona) {
        this.patio = patio;
        this.zona = zona;
        this.id = new ZonaPatioId(patio.getIdPatio(), zona.getIdZona());
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\model\relacionamento\ZonaPatioId.java   |   package br.com.fiap.mottu.model.relacionamento   |   class ZonaPatioId
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\model\relacionamento\ZonaPatioId.java
package br.com.fiap.mottu.model.relacionamento;

import jakarta.persistence.*;
import lombok.*;

import java.io.Serializable;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class ZonaPatioId implements Serializable {

    @Column(name = "TB_PATIO_ID_PATIO", nullable = false)
    private Long patioId;

    @Column(name = "TB_ZONA_ID_ZONA", nullable = false)
    private Long zonaId;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\repository\BoxRepository.java   |   package br.com.fiap.mottu.repository   |   class BoxRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\BoxRepository.java
package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Box;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface BoxRepository extends JpaRepository<Box, Long>, JpaSpecificationExecutor<Box> {
    Optional<Box> findById(Long idBox); // Já disponível, mas explicitando
    List<Box> findByNomeContainingIgnoreCase(String nome); // Mantido para buscas parciais se necessário
    Optional<Box> findByNomeIgnoreCase(String nome); // ADICIONADO para checagem de duplicidade exata
    boolean existsByNomeIgnoreCase(String nome); // ADICIONADO como alternativa para checagem de duplicidade
    List<Box> findByDataEntradaBetween(LocalDate startDate, LocalDate endDate);
    List<Box> findByDataSaidaBetween(LocalDate startDate, LocalDate endDate);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\repository\ClienteRepository.java   |   package br.com.fiap.mottu.repository   |   class ClienteRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\ClienteRepository.java
package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Cliente;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface ClienteRepository extends JpaRepository<Cliente, Long>, JpaSpecificationExecutor<Cliente> {
    // Métodos de pesquisa avançada (derivados):
    // Cliente: cpf, id, nome, data de cadastro
    Optional<Cliente> findByCpf(String cpf);
    Optional<Cliente> findById(Long idCliente); // Já disponível, mas explicitando
    List<Cliente> findByNomeContainingIgnoreCase(String nome);
    List<Cliente> findByDataCadastroBetween(LocalDate startDate, LocalDate endDate);
    // Você também pode combinar:
    // Optional<Cliente> findByCpfAndNomeContainingIgnoreCase(String cpf, String nome);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\repository\ContatoRepository.java   |   package br.com.fiap.mottu.repository   |   class ContatoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\ContatoRepository.java
package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Contato;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.List;

@Repository
public interface ContatoRepository extends JpaRepository<Contato, Long>, JpaSpecificationExecutor<Contato> {
    // Você pode adicionar métodos de busca por email, telefone, etc.
    Optional<Contato> findByEmail(String email);
    List<Contato> findByCelularContaining(String celular); // Exemplo de busca parcial por celular
    List<Contato> findByDddAndTelefone1(Integer ddd, String telefone1); // Exemplo de combinação
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\repository\EnderecoRepository.java   |   package br.com.fiap.mottu.repository   |   class EnderecoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\EnderecoRepository.java
package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Endereco;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.List;

@Repository
public interface EnderecoRepository extends JpaRepository<Endereco, Long>, JpaSpecificationExecutor<Endereco> {
    // Métodos de pesquisa avançada (derivados):
    Optional<Endereco> findByCep(String cep);
    List<Endereco> findByCidadeContainingIgnoreCase(String cidade);
    List<Endereco> findByEstado(String estado);
    List<Endereco> findByLogradouroContainingIgnoreCase(String logradouro);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\repository\PatioRepository.java   |   package br.com.fiap.mottu.repository   |   class PatioRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\PatioRepository.java
package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Patio;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface PatioRepository extends JpaRepository<Patio, Long>, JpaSpecificationExecutor<Patio> {
    Optional<Patio> findById(Long idPatio); // Já disponível, mas explicitando
    List<Patio> findByNomePatioContainingIgnoreCase(String nomePatio); // Mantido para buscas parciais
    Optional<Patio> findByNomePatioIgnoreCase(String nomePatio); // ADICIONADO para checagem de duplicidade exata
    boolean existsByNomePatioIgnoreCase(String nomePatio); // ADICIONADO como alternativa
    List<Patio> findByDataEntradaBetween(LocalDate startDate, LocalDate endDate);
    List<Patio> findByDataSaidaBetween(LocalDate startDate, LocalDate endDate);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\repository\RastreamentoRepository.java   |   package br.com.fiap.mottu.repository   |   class RastreamentoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Rastreamento;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;
import java.util.Optional;
import java.util.List;

@Repository
public interface RastreamentoRepository extends JpaRepository<Rastreamento, Long>, JpaSpecificationExecutor<Rastreamento> {
    Optional<Rastreamento> findById(Long idRastreamento);
    // Já disponível

    // Remova os métodos abaixo:
    // List<Rastreamento> findByIpsContainingIgnoreCase(String ips);
    // List<Rastreamento> findByGprsContainingIgnoreCase(String gprs);
    // Optional<Rastreamento> findByIpsIgnoreCase(String ips);
    // Optional<Rastreamento> findByGprsIgnoreCase(String gprs);
    // boolean existsByIpsIgnoreCase(String ips);
    // boolean existsByGprsIgnoreCase(String gprs);

    // Você pode adicionar métodos de busca por coordenadas específicas, se precisar
    // Por exemplo:
    // Optional<Rastreamento> findByIpsXAndIpsYAndIpsZ(Double ipsX, Double ipsY, Double ipsZ);
    // List<Rastreamento> findByGprsLatitudeBetweenAndGprsLongitudeBetween(Double minLat, Double maxLat, Double minLong, Double maxLong);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\repository\VeiculoRepository.java   |   package br.com.fiap.mottu.repository   |   class VeiculoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\VeiculoRepository.java
package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Veiculo;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.List;

@Repository
public interface VeiculoRepository extends JpaRepository<Veiculo, Long>, JpaSpecificationExecutor<Veiculo> {
    // Métodos de pesquisa avançada (derivados):
    // Veiculo: placa, id, renavam, chassi, modelo, fabricante, ano, combustivel
    Optional<Veiculo> findByPlaca(String placa);
    Optional<Veiculo> findById(Long idVeiculo); // Já disponível, mas explicitando
    Optional<Veiculo> findByRenavam(String renavam);
    Optional<Veiculo> findByChassi(String chassi);
    List<Veiculo> findByModeloContainingIgnoreCase(String modelo);
    List<Veiculo> findByFabricanteContainingIgnoreCase(String fabricante);
    List<Veiculo> findByAno(Integer ano); // Busca exata por ano
    List<Veiculo> findByAnoBetween(Integer startAno, Integer endAno); // Busca por intervalo de ano
    List<Veiculo> findByCombustivelContainingIgnoreCase(String combustivel);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\repository\ZonaRepository.java   |   package br.com.fiap.mottu.repository   |   class ZonaRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\ZonaRepository.java
package br.com.fiap.mottu.repository;

import br.com.fiap.mottu.model.Zona;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface ZonaRepository extends JpaRepository<Zona, Long>, JpaSpecificationExecutor<Zona> {
    Optional<Zona> findById(Long idZona); // Já disponível, mas explicitando
    List<Zona> findByNomeContainingIgnoreCase(String nome); // Mantido para buscas parciais
    Optional<Zona> findByNomeIgnoreCase(String nome); // ADICIONADO para checagem de duplicidade exata
    boolean existsByNomeIgnoreCase(String nome); // ADICIONADO como alternativa
    List<Zona> findByDataEntradaBetween(LocalDate startDate, LocalDate endDate);
    List<Zona> findByDataSaidaBetween(LocalDate startDate, LocalDate endDate);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\repository\relacionamento\ClienteVeiculoRepository.java   |   package br.com.fiap.mottu.repository.relacionamento   |   class ClienteVeiculoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\ClienteVeiculoRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.ClienteVeiculo;
import br.com.fiap.mottu.model.relacionamento.ClienteVeiculoId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ClienteVeiculoRepository extends JpaRepository<ClienteVeiculo, ClienteVeiculoId>, JpaSpecificationExecutor<ClienteVeiculo> {
    // Métodos customizados podem ser úteis aqui
    List<ClienteVeiculo> findById_ClienteId(Long clienteId);
    List<ClienteVeiculo> findById_VeiculoId(Long veiculoId);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\repository\relacionamento\ContatoPatioRepository.java   |   package br.com.fiap.mottu.repository.relacionamento   |   class ContatoPatioRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\ContatoPatioRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.ContatoPatio;
import br.com.fiap.mottu.model.relacionamento.ContatoPatioId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface ContatoPatioRepository extends JpaRepository<ContatoPatio, ContatoPatioId>, JpaSpecificationExecutor<ContatoPatio> {
    // Adicione métodos de busca específicos se precisar
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\repository\relacionamento\EnderecoPatioRepository.java   |   package br.com.fiap.mottu.repository.relacionamento   |   class EnderecoPatioRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\EnderecoPatioRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.EnderecoPatio;
import br.com.fiap.mottu.model.relacionamento.EnderecoPatioId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface EnderecoPatioRepository extends JpaRepository<EnderecoPatio, EnderecoPatioId>, JpaSpecificationExecutor<EnderecoPatio> {
    // Adicione métodos de busca específicos se precisar
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\repository\relacionamento\PatioBoxRepository.java   |   package br.com.fiap.mottu.repository.relacionamento   |   class PatioBoxRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.PatioBox;
import br.com.fiap.mottu.model.relacionamento.PatioBoxId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface PatioBoxRepository extends JpaRepository<PatioBox, PatioBoxId>, JpaSpecificationExecutor<PatioBox> {
    // Métodos customizados podem ser adicionados aqui se necessário
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\repository\relacionamento\VeiculoBoxRepository.java   |   package br.com.fiap.mottu.repository.relacionamento   |   class VeiculoBoxRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\VeiculoBoxRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.VeiculoBox;
import br.com.fiap.mottu.model.relacionamento.VeiculoBoxId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface VeiculoBoxRepository extends JpaRepository<VeiculoBox, VeiculoBoxId>, JpaSpecificationExecutor<VeiculoBox> {
    // Adicione métodos de busca específicos se precisar
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\repository\relacionamento\VeiculoPatioRepository.java   |   package br.com.fiap.mottu.repository.relacionamento   |   class VeiculoPatioRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\VeiculoPatioRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.VeiculoPatio;
import br.com.fiap.mottu.model.relacionamento.VeiculoPatioId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface VeiculoPatioRepository extends JpaRepository<VeiculoPatio, VeiculoPatioId>, JpaSpecificationExecutor<VeiculoPatio> {
    // Adicione métodos de busca específicos se precisar
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\repository\relacionamento\VeiculoRastreamentoRepository.java   |   package br.com.fiap.mottu.repository.relacionamento   |   class VeiculoRastreamentoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\VeiculoRastreamentoRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.VeiculoRastreamento;
import br.com.fiap.mottu.model.relacionamento.VeiculoRastreamentoId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface VeiculoRastreamentoRepository extends JpaRepository<VeiculoRastreamento, VeiculoRastreamentoId>, JpaSpecificationExecutor<VeiculoRastreamento> {
    // Adicione métodos de busca específicos se precisar
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\repository\relacionamento\VeiculoZonaRepository.java   |   package br.com.fiap.mottu.repository.relacionamento   |   class VeiculoZonaRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\VeiculoZonaRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.VeiculoZona;
import br.com.fiap.mottu.model.relacionamento.VeiculoZonaId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface VeiculoZonaRepository extends JpaRepository<VeiculoZona, VeiculoZonaId>, JpaSpecificationExecutor<VeiculoZona> {
    // Adicione métodos de busca específicos se precisar
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\repository\relacionamento\ZonaBoxRepository.java   |   package br.com.fiap.mottu.repository.relacionamento   |   class ZonaBoxRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\ZonaBoxRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.ZonaBox;
import br.com.fiap.mottu.model.relacionamento.ZonaBoxId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface ZonaBoxRepository extends JpaRepository<ZonaBox, ZonaBoxId>, JpaSpecificationExecutor<ZonaBox> {
    // Adicione métodos de busca específicos se precisar
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\repository\relacionamento\ZonaPatioRepository.java   |   package br.com.fiap.mottu.repository.relacionamento   |   class ZonaPatioRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\repository\relacionamento\ZonaPatioRepository.java
package br.com.fiap.mottu.repository.relacionamento;

import br.com.fiap.mottu.model.relacionamento.ZonaPatio;
import br.com.fiap.mottu.model.relacionamento.ZonaPatioId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
public interface ZonaPatioRepository extends JpaRepository<ZonaPatio, ZonaPatioId>, JpaSpecificationExecutor<ZonaPatio> {
    // Adicione métodos de busca específicos se precisar
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\service\BoxService.java   |   package br.com.fiap.mottu.service   |   class BoxService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.box.BoxRequestDto;
import br.com.fiap.mottu.filter.BoxFilter;
import br.com.fiap.mottu.mapper.BoxMapper;
import br.com.fiap.mottu.model.Box;
import br.com.fiap.mottu.repository.BoxRepository;
import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;
import br.com.fiap.mottu.specification.BoxSpecification;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;

@Service
public class BoxService {

    private final BoxRepository boxRepository;
    private final BoxMapper boxMapper;

    @Autowired
    public BoxService(BoxRepository boxRepository, BoxMapper boxMapper) {
        this.boxRepository = boxRepository;
        this.boxMapper = boxMapper;
    }

    public List<Box> listarTodosBoxes() {
        return boxRepository.findAll();
    }

    public Box buscarBoxPorId(Long id) {
        return boxRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Box", id));
    }

    public List<Box> buscarBoxesPorFiltro(BoxFilter filter) {
        return boxRepository.findAll(BoxSpecification.withFilters(filter));
    }

    @Transactional
    public Box criarBox(BoxRequestDto boxRequestDto) {
        // Evita duplicação de nome
        String nome = boxRequestDto.getNome();
        if (boxRepository.findByNomeContainingIgnoreCase(nome)
                .stream().anyMatch(b -> b.getNome().equalsIgnoreCase(nome))) {
            throw new DuplicatedResourceException("Box", "nome", nome);
        }
        Box box = boxMapper.toEntity(boxRequestDto);
        return boxRepository.save(box);
    }

    @Transactional
    public Box atualizarBox(Long id, BoxRequestDto boxRequestDto) {
        return boxRepository.findById(id)
                .map(boxExistente -> {
                    String novoNome = boxRequestDto.getNome();
                    if (novoNome != null
                            && !novoNome.isBlank()
                            && !novoNome.equalsIgnoreCase(boxExistente.getNome())
                            && boxRepository.findByNomeContainingIgnoreCase(novoNome)
                            .stream().anyMatch(b -> b.getNome().equalsIgnoreCase(novoNome))) {
                        throw new DuplicatedResourceException("Box", "nome", novoNome);
                    }
                    boxMapper.partialUpdate(boxRequestDto, boxExistente);
                    return boxRepository.save(boxExistente);
                })
                .orElseThrow(() -> new ResourceNotFoundException("Box", id));
    }

    @Transactional
    public void deletarBox(Long id) {
        if (!boxRepository.existsById(id)) {
            throw new ResourceNotFoundException("Box", id);
        }
        boxRepository.deleteById(id);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\service\ClienteService.java   |   package br.com.fiap.mottu.service   |   class ClienteService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// br/com/fiap/mottu/service/ClienteService.java
package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.cliente.ClienteRequestDto;
import br.com.fiap.mottu.dto.endereco.EnderecoRequestDto;
import br.com.fiap.mottu.dto.contato.ContatoRequestDto;
import br.com.fiap.mottu.filter.ClienteFilter;
import br.com.fiap.mottu.model.Cliente;
import br.com.fiap.mottu.model.Contato;
import br.com.fiap.mottu.model.Endereco;
import br.com.fiap.mottu.model.Veiculo;
import br.com.fiap.mottu.model.relacionamento.ClienteVeiculo;
import br.com.fiap.mottu.model.relacionamento.ClienteVeiculoId;
import br.com.fiap.mottu.repository.ClienteRepository;
import br.com.fiap.mottu.repository.relacionamento.ClienteVeiculoRepository;
import br.com.fiap.mottu.repository.ContatoRepository;
import br.com.fiap.mottu.repository.EnderecoRepository;
import br.com.fiap.mottu.repository.VeiculoRepository;
import br.com.fiap.mottu.specification.ClienteSpecification;
import br.com.fiap.mottu.exception.ResourceNotFoundException;
import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.InvalidInputException;
import br.com.fiap.mottu.mapper.ClienteMapper;
import br.com.fiap.mottu.mapper.ContatoMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import reactor.core.publisher.Mono;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class ClienteService {

    private final ClienteRepository clienteRepository;
    private final EnderecoRepository enderecoRepository;
    private final ContatoRepository contatoRepository;
    private final VeiculoRepository veiculoRepository;
    private final ClienteVeiculoRepository clienteVeiculoRepository;
    private final EnderecoService enderecoService;
    private final ClienteMapper clienteMapper;
    private final ContatoMapper contatoMapper;

    @Autowired
    public ClienteService(
            ClienteRepository clienteRepository,
            EnderecoRepository enderecoRepository,
            ContatoRepository contatoRepository,
            VeiculoRepository veiculoRepository,
            ClienteVeiculoRepository clienteVeiculoRepository,
            EnderecoService enderecoService,
            ClienteMapper clienteMapper,
            ContatoMapper contatoMapper
    ) {
        this.clienteRepository = clienteRepository;
        this.enderecoRepository = enderecoRepository;
        this.contatoRepository = contatoRepository;
        this.veiculoRepository = veiculoRepository;
        this.clienteVeiculoRepository = clienteVeiculoRepository;
        this.enderecoService = enderecoService;
        this.clienteMapper = clienteMapper;
        this.contatoMapper = contatoMapper;
    }

    public List<Cliente> listarTodosClientes() {
        return clienteRepository.findAll();
    }

    public Cliente buscarClientePorId(Long id) {
        return clienteRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Cliente", id));
    }

    public List<Cliente> buscarClientesPorFiltro(ClienteFilter filter) {
        return clienteRepository.findAll(ClienteSpecification.withFilters(filter));
    }

    @Transactional
    public Mono<Cliente> criarCliente(ClienteRequestDto dto) {
        if (clienteRepository.findByCpf(dto.getCpf()).isPresent()) {
            return Mono.error(new DuplicatedResourceException("Cliente", "CPF", dto.getCpf()));
        }

        Mono<Endereco> enderecoMono = (dto.getEnderecoRequestDto().getIdEndereco() != null)
                ? Mono.justOrEmpty(enderecoRepository.findById(dto.getEnderecoRequestDto().getIdEndereco()))
                .switchIfEmpty(Mono.error(new ResourceNotFoundException("Endereço", dto.getEnderecoRequestDto().getIdEndereco())))
                : enderecoService.criarEndereco(dto.getEnderecoRequestDto());

        Mono<Contato> contatoMono = (dto.getContatoRequestDto().getIdContato() != null)
                ? Mono.justOrEmpty(contatoRepository.findById(dto.getContatoRequestDto().getIdContato()))
                .switchIfEmpty(Mono.error(new ResourceNotFoundException("Contato", dto.getContatoRequestDto().getIdContato())))
                : Mono.just(contatoRepository.save(contatoMapper.toEntity(dto.getContatoRequestDto())));

        return Mono.zip(enderecoMono, contatoMono)
                .flatMap(tuple -> {
                    Cliente cliente = clienteMapper.toEntity(dto);
                    cliente.setEndereco(tuple.getT1());
                    cliente.setContato(tuple.getT2());
                    return Mono.just(clienteRepository.save(cliente));
                })
                .onErrorResume(e -> {
                    if (e instanceof ResourceNotFoundException
                            || e instanceof DuplicatedResourceException
                            || e instanceof InvalidInputException) {
                        return Mono.error(e);
                    }
                    return Mono.error(new InvalidInputException("Erro inesperado ao criar cliente: " + e.getMessage()));
                });
    }

    @Transactional
    public Mono<Cliente> atualizarCliente(Long id, ClienteRequestDto dto) {
        return Mono.justOrEmpty(clienteRepository.findById(id))
                .switchIfEmpty(Mono.error(new ResourceNotFoundException("Cliente", id)))
                .flatMap(clienteExistente -> {
                    if (dto.getCpf() != null
                            && !dto.getCpf().equals(clienteExistente.getCpf())
                            && clienteRepository.findByCpf(dto.getCpf()).isPresent()) {
                        return Mono.error(new DuplicatedResourceException("Cliente", "CPF", dto.getCpf()));
                    }

                    clienteMapper.partialUpdate(dto, clienteExistente);

                    Mono<Endereco> enderecoMono;
                    if (dto.getEnderecoRequestDto() != null) {
                        if (dto.getEnderecoRequestDto().getIdEndereco() != null) {
                            enderecoMono = enderecoService.atualizarEndereco(dto.getEnderecoRequestDto().getIdEndereco(), dto.getEnderecoRequestDto());
                        } else {
                            enderecoMono = enderecoService.criarEndereco(dto.getEnderecoRequestDto());
                        }
                    } else {
                        enderecoMono = Mono.just(clienteExistente.getEndereco());
                    }

                    Mono<Contato> contatoMono;
                    if (dto.getContatoRequestDto() != null) {
                        if (dto.getContatoRequestDto().getIdContato() != null) {
                            contatoMono = Mono.justOrEmpty(contatoRepository.findById(dto.getContatoRequestDto().getIdContato()))
                                    .switchIfEmpty(Mono.error(new ResourceNotFoundException("Contato", dto.getContatoRequestDto().getIdContato())))
                                    .flatMap(contatoExistente -> {
                                        contatoMapper.partialUpdate(dto.getContatoRequestDto(), contatoExistente);
                                        return Mono.just(contatoRepository.save(contatoExistente));
                                    });
                        } else {
                            contatoMono = Mono.just(contatoRepository.save(contatoMapper.toEntity(dto.getContatoRequestDto())));
                        }
                    } else {
                        contatoMono = Mono.just(clienteExistente.getContato());
                    }

                    return Mono.zip(enderecoMono, contatoMono)
                            .flatMap(tuple -> {
                                clienteExistente.setEndereco(tuple.getT1());
                                clienteExistente.setContato(tuple.getT2());
                                return Mono.just(clienteRepository.save(clienteExistente));
                            });
                })
                .onErrorResume(e -> {
                    if (e instanceof ResourceNotFoundException
                            || e instanceof DuplicatedResourceException
                            || e instanceof InvalidInputException) {
                        return Mono.error(e);
                    }
                    return Mono.error(new InvalidInputException("Erro inesperado ao atualizar cliente: " + e.getMessage()));
                });
    }

    @Transactional
    public void deletarCliente(Long id) {
        if (!clienteRepository.existsById(id)) {
            throw new ResourceNotFoundException("Cliente", id);
        }
        clienteRepository.deleteById(id);
    }

    @Transactional
    public ClienteVeiculo associarClienteVeiculo(Long clienteId, Long enderecoId, Long contatoId, Long veiculoId) {
        Cliente cliente = clienteRepository.findById(clienteId)
                .orElseThrow(() -> new ResourceNotFoundException("Cliente", clienteId));
        Veiculo veiculo = veiculoRepository.findById(veiculoId)
                .orElseThrow(() -> new ResourceNotFoundException("Veículo", veiculoId));

        ClienteVeiculoId id = new ClienteVeiculoId(clienteId, enderecoId, contatoId, veiculoId);
        if (clienteVeiculoRepository.existsById(id)) {
            throw new DuplicatedResourceException("Associação Cliente-Veículo", "IDs", id.toString());
        }
        ClienteVeiculo associacao = new ClienteVeiculo(cliente, veiculo);
        return clienteVeiculoRepository.save(associacao);
    }

    @Transactional
    public void desassociarClienteVeiculo(Long clienteId,
                                          Long enderecoId,
                                          Long contatoId,
                                          Long veiculoId) {
        // Cria o objeto de chave composta
        ClienteVeiculoId id = new ClienteVeiculoId(clienteId, enderecoId, contatoId, veiculoId);

        // Verifica existência usando a própria chave composta
        if (!clienteVeiculoRepository.existsById(id)) {
            throw new ResourceNotFoundException(
                    "Associação Cliente-Veículo",  // nome do recurso
                    "ids",                           // nome do campo
                    id.toString()                    // valor que faltou
            );
        }

        // Remove passando o próprio ID (e não uma String)
        clienteVeiculoRepository.deleteById(id);
    }


    public Set<Veiculo> getVeiculosByClienteId(Long clienteId) {
        Cliente cliente = clienteRepository.findById(clienteId)
                .orElseThrow(() -> new ResourceNotFoundException("Cliente", clienteId));
        return cliente.getClienteVeiculos().stream()
                .map(ClienteVeiculo::getVeiculo)
                .collect(Collectors.toSet());
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\service\ContatoService.java   |   package br.com.fiap.mottu.service   |   class ContatoService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.contato.ContatoRequestDto;
import br.com.fiap.mottu.filter.ContatoFilter;
import br.com.fiap.mottu.mapper.ContatoMapper;
import br.com.fiap.mottu.model.Contato;
import br.com.fiap.mottu.repository.ContatoRepository;
import br.com.fiap.mottu.exception.*;
import br.com.fiap.mottu.specification.ContatoSpecification;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;

@Service
public class ContatoService {

    private final ContatoRepository contatoRepository;
    private final ContatoMapper contatoMapper;

    @Autowired
    public ContatoService(ContatoRepository contatoRepository, ContatoMapper contatoMapper) {
        this.contatoRepository = contatoRepository;
        this.contatoMapper = contatoMapper;
    }

    public List<Contato> listarTodosContatos() {
        return contatoRepository.findAll();
    }

    public Contato buscarContatoPorId(Long id) {
        return contatoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Contato", id));
    }

    public List<Contato> buscarContatosPorFiltro(ContatoFilter filter) {
        return contatoRepository.findAll(ContatoSpecification.withFilters(filter));
    }

    @Transactional
    public Contato criarContato(ContatoRequestDto dto) {
        String email = dto.getEmail();
        if (contatoRepository.findByEmail(email).isPresent()) {
            throw new DuplicatedResourceException("Contato", "email", email);
        }
        return contatoRepository.save(contatoMapper.toEntity(dto));
    }

    @Transactional
    public Contato atualizarContato(Long id, ContatoRequestDto dto) {
        return contatoRepository.findById(id)
                .map(existente -> {
                    String novoEmail = dto.getEmail();
                    if (novoEmail != null
                            && !novoEmail.equals(existente.getEmail())
                            && contatoRepository.findByEmail(novoEmail).isPresent()) {
                        throw new DuplicatedResourceException("Contato", "email", novoEmail);
                    }
                    contatoMapper.partialUpdate(dto, existente);
                    return contatoRepository.save(existente);
                })
                .orElseThrow(() -> new ResourceNotFoundException("Contato", id));
    }

    @Transactional
    public void deletarContato(Long id) {
        if (!contatoRepository.existsById(id)) {
            throw new ResourceNotFoundException("Contato", id);
        }
        contatoRepository.deleteById(id);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\service\EnderecoService.java   |   package br.com.fiap.mottu.service   |   class EnderecoService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// br/com/fiap/mottu/service/EnderecoService.java
package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.endereco.EnderecoRequestDto;
import br.com.fiap.mottu.external.viacep.ViaCepService;
import br.com.fiap.mottu.model.Endereco;
import br.com.fiap.mottu.mapper.EnderecoMapper;
import br.com.fiap.mottu.repository.EnderecoRepository;
import br.com.fiap.mottu.exception.ResourceNotFoundException;
import br.com.fiap.mottu.exception.InvalidInputException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import reactor.core.publisher.Mono;
import java.util.List;

@Service
public class EnderecoService {

    private final EnderecoRepository enderecoRepository;
    private final EnderecoMapper enderecoMapper;
    private final ViaCepService viaCepService;

    @Autowired
    public EnderecoService(EnderecoRepository enderecoRepository,
                           EnderecoMapper enderecoMapper,
                           ViaCepService viaCepService) {
        this.enderecoRepository = enderecoRepository;
        this.enderecoMapper = enderecoMapper;
        this.viaCepService = viaCepService;
    }

    public List<Endereco> listarTodosEnderecos() {
        return enderecoRepository.findAll();
    }

    public Endereco buscarEnderecoPorId(Long id) {
        return enderecoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Endereço", id));
    }

    @Transactional
    public Mono<Endereco> criarEndereco(EnderecoRequestDto dto) {
        // Validação básica
        if (dto.getCep() == null || dto.getCep().isBlank()) {
            return Mono.error(new InvalidInputException("CEP não pode ser nulo ou vazio."));
        }

        return viaCepService.buscarEnderecoPorCep(dto.getCep())
                .flatMap(resp -> {
                    Endereco endereco = enderecoMapper.toEntity(dto);
                    endereco.setLogradouro(resp.getLogradouro());
                    endereco.setBairro(resp.getBairro());
                    endereco.setCidade(resp.getLocalidade());
                    endereco.setEstado(resp.getUf());
                    endereco.setPais("Brasil");
                    return Mono.just(enderecoRepository.save(endereco));
                })
                // Aqui usamos o construtor de três argumentos:
                // (nome do recurso, nome do campo, valor do campo)
                .switchIfEmpty(Mono.error(
                        new ResourceNotFoundException("CEP", "cep", dto.getCep())
                ))
                .onErrorResume(e -> (e instanceof InvalidInputException)
                        ? Mono.error(e)
                        : Mono.error(new InvalidInputException("Erro ao criar endereço: " + e.getMessage())));
    }


    @Transactional
    public Mono<Endereco> atualizarEndereco(Long id, EnderecoRequestDto dto) {
        return Mono.justOrEmpty(enderecoRepository.findById(id))
                .switchIfEmpty(Mono.error(new ResourceNotFoundException("Endereço", id)))
                .flatMap(existing -> {
                    if (dto.getCep() != null && !dto.getCep().isBlank()) {
                        return viaCepService.buscarEnderecoPorCep(dto.getCep())
                                .flatMap(resp -> {
                                    enderecoMapper.partialUpdate(dto, existing);
                                    existing.setLogradouro(resp.getLogradouro());
                                    existing.setBairro(resp.getBairro());
                                    existing.setCidade(resp.getLocalidade());
                                    existing.setEstado(resp.getUf());
                                    existing.setPais("Brasil");
                                    return Mono.just(enderecoRepository.save(existing));
                                })
                                .switchIfEmpty(Mono.error(new ResourceNotFoundException("Dados de CEP para atualização", "CEP", dto.getCep())));
                    } else {
                        enderecoMapper.partialUpdate(dto, existing);
                        return Mono.just(enderecoRepository.save(existing));
                    }
                })
                .onErrorResume(e -> (e instanceof InvalidInputException || e instanceof ResourceNotFoundException)
                        ? Mono.error(e)
                        : Mono.error(new InvalidInputException("Erro inesperado ao atualizar endereço: " + e.getMessage())));
    }

    @Transactional
    public void deletarEndereco(Long id) {
        if (!enderecoRepository.existsById(id)) {
            throw new ResourceNotFoundException("Endereço", id);
        }
        enderecoRepository.deleteById(id);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\service\PatioService.java   |   package br.com.fiap.mottu.service   |   class PatioService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.patio.PatioRequestDto;
import br.com.fiap.mottu.filter.PatioFilter;
import br.com.fiap.mottu.mapper.PatioMapper;
import br.com.fiap.mottu.model.Patio;
import br.com.fiap.mottu.model.Veiculo;
import br.com.fiap.mottu.model.Zona;
import br.com.fiap.mottu.model.Box; // NOVO: Importar Box
import br.com.fiap.mottu.model.Contato;
import br.com.fiap.mottu.model.Endereco;

// Importar as classes de relacionamento e seus IDs
import br.com.fiap.mottu.model.relacionamento.VeiculoPatio;
import br.com.fiap.mottu.model.relacionamento.VeiculoPatioId;
import br.com.fiap.mottu.model.relacionamento.ZonaPatio;
import br.com.fiap.mottu.model.relacionamento.ZonaPatioId;
import br.com.fiap.mottu.model.relacionamento.ContatoPatio;
import br.com.fiap.mottu.model.relacionamento.ContatoPatioId;
import br.com.fiap.mottu.model.relacionamento.EnderecoPatio;
import br.com.fiap.mottu.model.relacionamento.EnderecoPatioId;
import br.com.fiap.mottu.model.relacionamento.PatioBox;    // NOVO
import br.com.fiap.mottu.model.relacionamento.PatioBoxId;  // NOVO


import br.com.fiap.mottu.repository.PatioRepository;
import br.com.fiap.mottu.repository.VeiculoRepository;
import br.com.fiap.mottu.repository.ZonaRepository;
import br.com.fiap.mottu.repository.BoxRepository;          // NOVO: Injetar BoxRepository
import br.com.fiap.mottu.repository.ContatoRepository;
import br.com.fiap.mottu.repository.EnderecoRepository;

// Importar os repositórios das tabelas de junção
import br.com.fiap.mottu.repository.relacionamento.VeiculoPatioRepository;
import br.com.fiap.mottu.repository.relacionamento.ZonaPatioRepository;
import br.com.fiap.mottu.repository.relacionamento.ContatoPatioRepository;
import br.com.fiap.mottu.repository.relacionamento.EnderecoPatioRepository;
import br.com.fiap.mottu.repository.relacionamento.PatioBoxRepository; // NOVO: Injetar


import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;
import br.com.fiap.mottu.specification.PatioSpecification;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;
import java.util.Set; // Para coleções
import java.util.stream.Collectors; // Para operações com streams

@Service
public class PatioService {

    private final PatioRepository patioRepository;
    private final PatioMapper patioMapper;
    private final VeiculoRepository veiculoRepository;
    private final ZonaRepository zonaRepository;
    private final BoxRepository boxRepository; // NOVO
    private final ContatoRepository contatoRepository;
    private final EnderecoRepository enderecoRepository;

    // Repositórios das tabelas de junção
    private final VeiculoPatioRepository veiculoPatioRepository;
    private final ZonaPatioRepository zonaPatioRepository;
    private final ContatoPatioRepository contatoPatioRepository;
    private final EnderecoPatioRepository enderecoPatioRepository;
    private final PatioBoxRepository patioBoxRepository; // NOVO


    @Autowired
    public PatioService(PatioRepository patioRepository, PatioMapper patioMapper,
                        VeiculoRepository veiculoRepository, ZonaRepository zonaRepository,
                        ContatoRepository contatoRepository, EnderecoRepository enderecoRepository,
                        VeiculoPatioRepository veiculoPatioRepository, ZonaPatioRepository zonaPatioRepository,
                        ContatoPatioRepository contatoPatioRepository, EnderecoPatioRepository enderecoPatioRepository,
                        BoxRepository boxRepository, PatioBoxRepository patioBoxRepository) { // NOVO: Adicione BoxRepository e PatioBoxRepository aqui
        this.patioRepository = patioRepository;
        this.patioMapper = patioMapper;
        this.veiculoRepository = veiculoRepository;
        this.zonaRepository = zonaRepository;
        this.contatoRepository = contatoRepository;
        this.enderecoRepository = enderecoRepository;
        this.veiculoPatioRepository = veiculoPatioRepository;
        this.zonaPatioRepository = zonaPatioRepository;
        this.contatoPatioRepository = contatoPatioRepository;
        this.enderecoPatioRepository = enderecoPatioRepository;
        this.boxRepository = boxRepository;
        this.patioBoxRepository = patioBoxRepository;
    }

    public List<Patio> listarTodosPatios() {
        return patioRepository.findAll();
    }

    public Patio buscarPatioPorId(Long id) {
        return patioRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Pátio", id));
    }

    public List<Patio> buscarPatiosPorFiltro(PatioFilter filter) {
        return patioRepository.findAll(PatioSpecification.withFilters(filter));
    }

    @Transactional
    public Patio criarPatio(PatioRequestDto dto) {
        String nome = dto.getNomePatio();
        if (patioRepository.findByNomePatioContainingIgnoreCase(nome)
                .stream().anyMatch(p -> p.getNomePatio().equalsIgnoreCase(nome))) {
            throw new DuplicatedResourceException("Pátio", "nome", nome);
        }
        Patio patio = patioMapper.toEntity(dto);
        return patioRepository.save(patio);
    }

    @Transactional
    public Patio atualizarPatio(Long id, PatioRequestDto dto) {
        return patioRepository.findById(id)
                .map(existente -> {
                    String novoNome = dto.getNomePatio();
                    if (novoNome != null
                            && !novoNome.equalsIgnoreCase(existente.getNomePatio())
                            && patioRepository.findByNomePatioContainingIgnoreCase(novoNome)
                            .stream().anyMatch(p -> p.getNomePatio().equalsIgnoreCase(novoNome))) {
                        throw new DuplicatedResourceException("Pátio", "nome", novoNome);
                    }
                    patioMapper.partialUpdate(dto, existente);
                    return patioRepository.save(existente);
                })
                .orElseThrow(() -> new ResourceNotFoundException("Pátio", id));
    }

    @Transactional
    public void deletarPatio(Long id) {
        if (!patioRepository.existsById(id)) {
            throw new ResourceNotFoundException("Pátio", id);
        }
        patioRepository.deleteById(id);
    }

    // Métodos para gerenciar associações de Patio

    // --- VeiculoPatio ---
    @Transactional
    public VeiculoPatio associarPatioVeiculo(Long patioId, Long veiculoId) {
        Patio patio = patioRepository.findById(patioId)
                .orElseThrow(() -> new ResourceNotFoundException("Pátio", patioId));
        Veiculo veiculo = veiculoRepository.findById(veiculoId)
                .orElseThrow(() -> new ResourceNotFoundException("Veículo", veiculoId));

        VeiculoPatioId id = new VeiculoPatioId(veiculoId, patioId); // Cria o ID composto
        if (veiculoPatioRepository.existsById(id)) {
            throw new DuplicatedResourceException("Associação Pátio-Veículo", "IDs", id.toString());
        }

        VeiculoPatio associacao = new VeiculoPatio(veiculo, patio); // Cria a entidade de relacionamento
        return veiculoPatioRepository.save(associacao);
    }

    @Transactional
    public void desassociarPatioVeiculo(Long patioId, Long veiculoId) {
        VeiculoPatioId id = new VeiculoPatioId(veiculoId, patioId); // Cria o ID composto
        if (!veiculoPatioRepository.existsById(id)) {
            throw new ResourceNotFoundException("Associação Pátio-Veículo", "IDs", id.toString());
        }
        veiculoPatioRepository.deleteById(id);
    }

    public Set<Veiculo> getVeiculosByPatioId(Long patioId) {
        Patio patio = patioRepository.findById(patioId)
                .orElseThrow(() -> new ResourceNotFoundException("Pátio", patioId));
        return patio.getVeiculoPatios().stream() // Assume que Patio tem um Set<VeiculoPatio>
                .map(VeiculoPatio::getVeiculo) // Mapeia para a entidade Veiculo
                .collect(Collectors.toSet());
    }

    // --- ZonaPatio ---
    @Transactional
    public ZonaPatio associarPatioZona(Long patioId, Long zonaId) {
        Patio patio = patioRepository.findById(patioId)
                .orElseThrow(() -> new ResourceNotFoundException("Pátio", patioId));
        Zona zona = zonaRepository.findById(zonaId)
                .orElseThrow(() -> new ResourceNotFoundException("Zona", zonaId));

        ZonaPatioId id = new ZonaPatioId(patioId, zonaId); // Cria o ID composto
        if (zonaPatioRepository.existsById(id)) {
            throw new DuplicatedResourceException("Associação Pátio-Zona", "IDs", id.toString());
        }

        ZonaPatio associacao = new ZonaPatio(patio, zona); // Cria a entidade de relacionamento
        return zonaPatioRepository.save(associacao);
    }

    @Transactional
    public void desassociarPatioZona(Long patioId, Long zonaId) {
        ZonaPatioId id = new ZonaPatioId(patioId, zonaId); // Cria o ID composto
        if (!zonaPatioRepository.existsById(id)) {
            throw new ResourceNotFoundException("Associação Pátio-Zona", "IDs", id.toString());
        }
        zonaPatioRepository.deleteById(id);
    }

    public Set<Zona> getZonasByPatioId(Long patioId) {
        Patio patio = patioRepository.findById(patioId)
                .orElseThrow(() -> new ResourceNotFoundException("Pátio", patioId));
        return patio.getZonaPatios().stream() // Assume que Patio tem um Set<ZonaPatio>
                .map(ZonaPatio::getZona) // Mapeia para a entidade Zona
                .collect(Collectors.toSet());
    }

    // --- ContatoPatio ---
    @Transactional
    public ContatoPatio associarPatioContato(Long patioId, Long contatoId) {
        Patio patio = patioRepository.findById(patioId)
                .orElseThrow(() -> new ResourceNotFoundException("Pátio", patioId));
        Contato contato = contatoRepository.findById(contatoId)
                .orElseThrow(() -> new ResourceNotFoundException("Contato", contatoId));

        ContatoPatioId id = new ContatoPatioId(patioId, contatoId); // Cria o ID composto
        if (contatoPatioRepository.existsById(id)) {
            throw new DuplicatedResourceException("Associação Pátio-Contato", "IDs", id.toString());
        }

        ContatoPatio associacao = new ContatoPatio(patio, contato); // Cria a entidade de relacionamento
        return contatoPatioRepository.save(associacao);
    }

    @Transactional
    public void desassociarPatioContato(Long patioId, Long contatoId) {
        ContatoPatioId id = new ContatoPatioId(patioId, contatoId); // Cria o ID composto
        if (!contatoPatioRepository.existsById(id)) {
            throw new ResourceNotFoundException("Associação Pátio-Contato", "IDs", id.toString());
        }
        contatoPatioRepository.deleteById(id);
    }

    public Set<Contato> getContatosByPatioId(Long patioId) {
        Patio patio = patioRepository.findById(patioId)
                .orElseThrow(() -> new ResourceNotFoundException("Pátio", patioId));
        return patio.getContatoPatios().stream() // Assume que Patio tem um Set<ContatoPatio>
                .map(ContatoPatio::getContato) // Mapeia para a entidade Contato
                .collect(Collectors.toSet());
    }

    // --- EnderecoPatio ---
    @Transactional
    public EnderecoPatio associarPatioEndereco(Long patioId, Long enderecoId) {
        Patio patio = patioRepository.findById(patioId)
                .orElseThrow(() -> new ResourceNotFoundException("Pátio", patioId));
        Endereco endereco = enderecoRepository.findById(enderecoId)
                .orElseThrow(() -> new ResourceNotFoundException("Endereço", enderecoId));

        // O EnderecoPatioId usa enderecoId primeiro, conforme seu DDL
        EnderecoPatioId id = new EnderecoPatioId(enderecoId, patioId); // Cria o ID composto
        if (enderecoPatioRepository.existsById(id)) {
            throw new DuplicatedResourceException("Associação Pátio-Endereço", "IDs", id.toString());
        }

        EnderecoPatio associacao = new EnderecoPatio(endereco, patio); // Cria a entidade de relacionamento
        return enderecoPatioRepository.save(associacao);
    }

    @Transactional
    public void desassociarPatioEndereco(Long patioId, Long enderecoId) {
        // O EnderecoPatioId usa enderecoId primeiro, conforme seu DDL
        EnderecoPatioId id = new EnderecoPatioId(enderecoId, patioId); // Cria o ID composto
        if (!enderecoPatioRepository.existsById(id)) {
            throw new ResourceNotFoundException("Associação Pátio-Endereço", "IDs", id.toString());
        }
        enderecoPatioRepository.deleteById(id);
    }

    public Set<Endereco> getEnderecosByPatioId(Long patioId) {
        Patio patio = patioRepository.findById(patioId)
                .orElseThrow(() -> new ResourceNotFoundException("Pátio", patioId));
        return patio.getEnderecoPatios().stream()
                .map(EnderecoPatio::getEndereco)
                .collect(Collectors.toSet());
    }

    // --- PatioBox (NOVO) ---
    @Transactional
    public PatioBox associarPatioBox(Long patioId, Long boxId) {
        Patio patio = patioRepository.findById(patioId)
                .orElseThrow(() -> new ResourceNotFoundException("Pátio", patioId));
        Box box = boxRepository.findById(boxId)
                .orElseThrow(() -> new ResourceNotFoundException("Box", boxId));

        PatioBoxId id = new PatioBoxId(patioId, boxId);
        if (patioBoxRepository.existsById(id)) {
            throw new DuplicatedResourceException("Associação Pátio-Box", "IDs", id.toString());
        }

        PatioBox associacao = new PatioBox(patio, box);
        return patioBoxRepository.save(associacao);
    }

    @Transactional
    public void desassociarPatioBox(Long patioId, Long boxId) {
        PatioBoxId id = new PatioBoxId(patioId, boxId);
        if (!patioBoxRepository.existsById(id)) {
            throw new ResourceNotFoundException("Associação Pátio-Box", "IDs", id.toString());
        }
        patioBoxRepository.deleteById(id);
    }

    public Set<Box> getBoxesByPatioId(Long patioId) {
        Patio patio = patioRepository.findById(patioId)
                .orElseThrow(() -> new ResourceNotFoundException("Pátio", patioId));
        return patio.getPatioBoxes().stream()
                .map(PatioBox::getBox)
                .collect(Collectors.toSet());
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\service\RastreamentoService.java   |   package br.com.fiap.mottu.service   |   class RastreamentoService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.rastreamento.RastreamentoRequestDto;
import br.com.fiap.mottu.filter.RastreamentoFilter;
import br.com.fiap.mottu.mapper.RastreamentoMapper;
import br.com.fiap.mottu.model.Rastreamento;
import br.com.fiap.mottu.repository.RastreamentoRepository;
import br.com.fiap.mottu.exception.*;
import br.com.fiap.mottu.specification.RastreamentoSpecification;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;
import java.math.BigDecimal; // Importe BigDecimal!

@Service
public class RastreamentoService {

    private final RastreamentoRepository rastreamentoRepository;
    private final RastreamentoMapper rastreamentoMapper;

    @Autowired
    public RastreamentoService(RastreamentoRepository rastreamentoRepository,
                               RastreamentoMapper rastreamentoMapper) {
        this.rastreamentoRepository = rastreamentoRepository;
        this.rastreamentoMapper = rastreamentoMapper;
    }

    public List<Rastreamento> listarTodosRastreamentos() {
        return rastreamentoRepository.findAll();
    }

    public Rastreamento buscarRastreamentoPorId(Long id) {
        return rastreamentoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Rastreamento", id));
    }

    public List<Rastreamento> buscarRastreamentosPorFiltro(RastreamentoFilter filter) {
        return rastreamentoRepository.findAll(RastreamentoSpecification.withFilters(filter));
    }

    @Transactional
    public Rastreamento criarRastreamento(RastreamentoRequestDto dto) {
        if (dto.getIpsX() == null || dto.getIpsY() == null || dto.getIpsZ() == null ||
                dto.getGprsLatitude() == null || dto.getGprsLongitude() == null || dto.getGprsAltitude() == null) {
            throw new InvalidInputException("Todas as coordenadas (IPS_X, IPS_Y, IPS_Z, GPRS_LATITUDE, GPRS_LONGITUDE, GPRS_ALTITUDE) são obrigatórias.");
        }
        Rastreamento r = rastreamentoMapper.toEntity(dto);
        return rastreamentoRepository.save(r);
    }

    @Transactional
    public Rastreamento atualizarRastreamento(Long id, RastreamentoRequestDto dto) {
        return rastreamentoRepository.findById(id)
                .map(existente -> {
                    rastreamentoMapper.partialUpdate(dto, existente);
                    return rastreamentoRepository.save(existente);
                })
                .orElseThrow(() -> new ResourceNotFoundException("Rastreamento", id));
    }

    @Transactional
    public void deletarRastreamento(Long id) {
        if (!rastreamentoRepository.existsById(id)) {
            throw new ResourceNotFoundException("Rastreamento", id);
        }
        rastreamentoRepository.deleteById(id);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\service\VeiculoService.java   |   package br.com.fiap.mottu.service   |   class VeiculoService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.veiculo.VeiculoRequestDto;
import br.com.fiap.mottu.dto.veiculo.VeiculoResponseDto;
import br.com.fiap.mottu.dto.veiculo.VeiculoLocalizacaoResponseDto; // NOVO: Importar o DTO de localização

import br.com.fiap.mottu.filter.VeiculoFilter;
import br.com.fiap.mottu.mapper.VeiculoMapper;
import br.com.fiap.mottu.mapper.RastreamentoMapper; // NOVO: Injetar para mapear Rastreamento
import br.com.fiap.mottu.mapper.PatioMapper;       // NOVO: Injetar para mapear Patio
import br.com.fiap.mottu.mapper.ZonaMapper;         // NOVO: Injetar para mapear Zona
import br.com.fiap.mottu.mapper.BoxMapper;           // NOVO: Injetar para mapear Box

import br.com.fiap.mottu.model.Veiculo;
import br.com.fiap.mottu.model.Rastreamento; // NOVO: Importar Rastreamento
import br.com.fiap.mottu.model.Patio;       // NOVO: Importar Patio
import br.com.fiap.mottu.model.Zona;         // NOVO: Importar Zona
import br.com.fiap.mottu.model.Box;          // NOVO: Importar Box

// Importar as classes de relacionamento
import br.com.fiap.mottu.model.relacionamento.VeiculoRastreamento;
import br.com.fiap.mottu.model.relacionamento.VeiculoPatio;
import br.com.fiap.mottu.model.relacionamento.VeiculoZona;
import br.com.fiap.mottu.model.relacionamento.VeiculoBox;

import br.com.fiap.mottu.repository.VeiculoRepository;
import br.com.fiap.mottu.repository.relacionamento.VeiculoRastreamentoRepository; // NOVO: Injetar

import br.com.fiap.mottu.exception.DuplicatedResourceException;
import br.com.fiap.mottu.exception.ResourceNotFoundException;
import br.com.fiap.mottu.specification.VeiculoSpecification;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.time.LocalDateTime; // Para o timestamp da consulta
import java.util.List;
import java.util.Comparator; // Para encontrar o último rastreamento
import java.util.Optional; // Para lidar com Optional
import java.util.Set; // Para coleções
import java.util.stream.Collectors; // Para streams

@Service
public class VeiculoService {

    private final VeiculoRepository veiculoRepository;
    private final VeiculoMapper veiculoMapper;
    private final VeiculoRastreamentoRepository veiculoRastreamentoRepository;
    private final RastreamentoMapper rastreamentoMapper;
    private final PatioMapper patioMapper;
    private final ZonaMapper zonaMapper;
    private final BoxMapper boxMapper;

    @Autowired
    public VeiculoService(VeiculoRepository veiculoRepository,
                          VeiculoMapper veiculoMapper,
                          VeiculoRastreamentoRepository veiculoRastreamentoRepository,
                          RastreamentoMapper rastreamentoMapper,
                          PatioMapper patioMapper,
                          ZonaMapper zonaMapper,
                          BoxMapper boxMapper) {
        this.veiculoRepository = veiculoRepository;
        this.veiculoMapper = veiculoMapper;
        this.veiculoRastreamentoRepository = veiculoRastreamentoRepository;
        this.rastreamentoMapper = rastreamentoMapper;
        this.patioMapper = patioMapper;
        this.zonaMapper = zonaMapper;
        this.boxMapper = boxMapper;
    }

    @Transactional(readOnly = true)
    public List<Veiculo> listarTodosVeiculos() {
        return veiculoRepository.findAll();
    }

    @Transactional(readOnly = true)
    public Veiculo buscarVeiculoPorId(Long id) {
        return veiculoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Veículo", id));
    }

    @Transactional(readOnly = true)
    public List<Veiculo> buscarVeiculosPorFiltro(VeiculoFilter filter) {
        return veiculoRepository.findAll(VeiculoSpecification.withFilters(filter));
    }

    @Transactional
    public Veiculo criarVeiculo(VeiculoRequestDto dto) {
        // Validações de duplicidade: placa, RENAVAM e chassi
        if (veiculoRepository.findByPlaca(dto.getPlaca()).isPresent()) {
            throw new DuplicatedResourceException("Veículo", "placa", dto.getPlaca());
        }
        if (veiculoRepository.findByRenavam(dto.getRenavam()).isPresent()) {
            throw new DuplicatedResourceException("Veículo", "RENAVAM", dto.getRenavam());
        }
        if (veiculoRepository.findByChassi(dto.getChassi()).isPresent()) {
            throw new DuplicatedResourceException("Veículo", "chassi", dto.getChassi());
        }
        Veiculo veiculo = veiculoMapper.toEntity(dto);
        return veiculoRepository.save(veiculo);
    }

    @Transactional
    public Veiculo atualizarVeiculo(Long id, VeiculoRequestDto dto) {
        Veiculo existente = veiculoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Veículo", id));

        // Validação de placa duplicada (se alterada e diferente da placa de outro veículo)
        if (dto.getPlaca() != null && !dto.getPlaca().isBlank() && !dto.getPlaca().equals(existente.getPlaca())) {
            if (veiculoRepository.findByPlaca(dto.getPlaca())
                    .filter(v -> !v.getIdVeiculo().equals(id)) // Exclui o próprio veículo da checagem
                    .isPresent()) {
                throw new DuplicatedResourceException("Veículo", "placa", dto.getPlaca());
            }
        }

        // Validação de RENAVAM duplicado (se alterado e diferente do RENAVAM de outro veículo)
        if (dto.getRenavam() != null && !dto.getRenavam().isBlank() && !dto.getRenavam().equals(existente.getRenavam())) {
            if (veiculoRepository.findByRenavam(dto.getRenavam())
                    .filter(v -> !v.getIdVeiculo().equals(id)) // Exclui o próprio veículo
                    .isPresent()) {
                throw new DuplicatedResourceException("Veículo", "RENAVAM", dto.getRenavam());
            }
        }

        // Validação de chassi duplicado (se alterado e diferente do chassi de outro veículo)
        if (dto.getChassi() != null && !dto.getChassi().isBlank() && !dto.getChassi().equals(existente.getChassi())) {
            if (veiculoRepository.findByChassi(dto.getChassi())
                    .filter(v -> !v.getIdVeiculo().equals(id)) // Exclui o próprio veículo
                    .isPresent()) {
                throw new DuplicatedResourceException("Veículo", "chassi", dto.getChassi());
            }
        }

        veiculoMapper.partialUpdate(dto, existente);
        return veiculoRepository.save(existente);
    }

    @Transactional
    public void deletarVeiculo(Long id) {
        if (!veiculoRepository.existsById(id)) {
            throw new ResourceNotFoundException("Veículo", id);
        }
        veiculoRepository.deleteById(id);
    }

    /**
     * Retorna o último ponto de rastreamento de um veículo e suas associações atuais
     * com Pátio, Zona e Box.
     * @param veiculoId ID do veículo.
     * @return DTO com informações de localização do veículo.
     * @throws ResourceNotFoundException se o veículo não for encontrado.
     */
    @Transactional(readOnly = true)
    public VeiculoLocalizacaoResponseDto getLocalizacaoVeiculo(Long veiculoId) {
        Veiculo veiculo = veiculoRepository.findById(veiculoId)
                .orElseThrow(() -> new ResourceNotFoundException("Veículo", veiculoId));

        Rastreamento ultimoRastreamento = null;
        // Encontrar o último rastreamento associado ao veículo.
        // Assumimos que a tabela VeiculoRastreamento não tem um campo de timestamp próprio para a associação,
        // então usamos o ID do Rastreamento como proxy para o mais recente.
        // Se sua entidade Rastreamento tiver um campo de data/hora (ex: `dataHoraRegistro`),
        // é MELHOR usar: `Comparator.comparing(va -> va.getRastreamento().getDataHoraRegistro())`
        Optional<VeiculoRastreamento> ultimaAssociacaoRastreamento = veiculo.getVeiculoRastreamentos().stream()
                .max(Comparator.comparing(va -> va.getRastreamento().getIdRastreamento())); // Usando ID como proxy para o mais recente

        if (ultimaAssociacaoRastreamento.isPresent()) {
            ultimoRastreamento = ultimaAssociacaoRastreamento.get().getRastreamento();
        }

        // Encontrar Patio associado (um veículo pode estar em um Patio via VeiculoPatio)
        // Assumimos que um veículo está em no máximo um pátio por vez ou pegamos o primeiro.
        Patio patioAssociado = veiculo.getVeiculoPatios().stream()
                .map(VeiculoPatio::getPatio)
                .findFirst()
                .orElse(null);

        // Encontrar Zona associada (um veículo pode estar em uma Zona via VeiculoZona)
        // Assumimos que um veículo está em no máximo uma zona por vez ou pegamos a primeira.
        Zona zonaAssociada = veiculo.getVeiculoZonas().stream()
                .map(VeiculoZona::getZona)
                .findFirst()
                .orElse(null);

        // Encontrar Box associado (um veículo pode estar em um Box via VeiculoBox)
        // Assumimos que um veículo está em no máximo um box por vez ou pegamos o primeiro.
        Box boxAssociado = veiculo.getVeiculoBoxes().stream()
                .map(VeiculoBox::getBox)
                .findFirst()
                .orElse(null);

        return new VeiculoLocalizacaoResponseDto(
                veiculo.getIdVeiculo(),
                veiculo.getPlaca(),
                veiculo.getModelo(),
                veiculo.getFabricante(),
                (ultimoRastreamento != null) ? rastreamentoMapper.toResponseDto(ultimoRastreamento) : null,
                (patioAssociado != null) ? patioMapper.toResponseDto(patioAssociado) : null,
                (zonaAssociada != null) ? zonaMapper.toResponseDto(zonaAssociada) : null,
                (boxAssociado != null) ? boxMapper.toResponseDto(boxAssociado) : null,
                LocalDateTime.now() // Timestamp da consulta
        );
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\service\ZonaService.java   |   package br.com.fiap.mottu.service   |   class ZonaService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.service;

import br.com.fiap.mottu.dto.zona.ZonaRequestDto;
import br.com.fiap.mottu.filter.ZonaFilter;
import br.com.fiap.mottu.mapper.ZonaMapper;
import br.com.fiap.mottu.model.Zona;
import br.com.fiap.mottu.repository.ZonaRepository;
import br.com.fiap.mottu.exception.*;
import br.com.fiap.mottu.specification.ZonaSpecification;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;

@Service
public class ZonaService {

    private final ZonaRepository zonaRepository;
    private final ZonaMapper zonaMapper;

    @Autowired
    public ZonaService(ZonaRepository zonaRepository, ZonaMapper zonaMapper) {
        this.zonaRepository = zonaRepository;
        this.zonaMapper = zonaMapper;
    }

    public List<Zona> listarTodasZonas() {
        return zonaRepository.findAll();
    }

    public Zona buscarZonaPorId(Long id) {
        return zonaRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Zona", id));
    }

    public List<Zona> buscarZonasPorFiltro(ZonaFilter filter) {
        return zonaRepository.findAll(ZonaSpecification.withFilters(filter));
    }

    @Transactional
    public Zona criarZona(ZonaRequestDto dto) {
        String nome = dto.getNome();
        if (zonaRepository.findByNomeContainingIgnoreCase(nome)
                .stream().anyMatch(z -> z.getNome().equalsIgnoreCase(nome))) {
            throw new DuplicatedResourceException("Zona", "nome", nome);
        }
        Zona z = zonaMapper.toEntity(dto);
        return zonaRepository.save(z);
    }

    @Transactional
    public Zona atualizarZona(Long id, ZonaRequestDto dto) {
        return zonaRepository.findById(id)
                .map(existente -> {
                    String novoNome = dto.getNome();
                    if (novoNome != null
                            && !novoNome.equalsIgnoreCase(existente.getNome())
                            && zonaRepository.findByNomeContainingIgnoreCase(novoNome)
                            .stream().anyMatch(z -> z.getNome().equalsIgnoreCase(novoNome))) {
                        throw new DuplicatedResourceException("Zona", "nome", novoNome);
                    }
                    zonaMapper.partialUpdate(dto, existente);
                    return zonaRepository.save(existente);
                })
                .orElseThrow(() -> new ResourceNotFoundException("Zona", id));
    }

    @Transactional
    public void deletarZona(Long id) {
        if (!zonaRepository.existsById(id)) {
            throw new ResourceNotFoundException("Zona", id);
        }
        zonaRepository.deleteById(id);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\specification\BoxSpecification.java   |   package br.com.fiap.mottu.specification   |   class BoxSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\specification\BoxSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.BoxFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Box;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class BoxSpecification {

    public static Specification<Box> withFilters(BoxFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.nome() != null && !filter.nome().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("nome")), "%" + filter.nome().toLowerCase() + "%"));
            }
            if (filter.status() != null && !filter.status().isBlank()) {
                predicates.add(cb.equal(root.get("status"), filter.status()));
            }
            if (filter.dataEntradaInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataEntrada"), filter.dataEntradaInicio()));
            }
            if (filter.dataEntradaFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataEntrada"), filter.dataEntradaFim()));
            }
            if (filter.dataSaidaInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataSaida"), filter.dataSaidaInicio()));
            }
            if (filter.dataSaidaFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataSaida"), filter.dataSaidaFim()));
            }
            if (filter.observacao() != null && !filter.observacao().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("observacao")), "%" + filter.observacao().toLowerCase() + "%"));
            }

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\specification\ClienteSpecification.java   |   package br.com.fiap.mottu.specification   |   class ClienteSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\specification\ClienteSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.ClienteFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Cliente;
import br.com.fiap.mottu.model.relacionamento.ClienteVeiculo;
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class ClienteSpecification {

    public static Specification<Cliente> withFilters(ClienteFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.nome() != null && !filter.nome().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("nome")), "%" + filter.nome().toLowerCase() + "%"));
            }
            if (filter.sobrenome() != null && !filter.sobrenome().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("sobrenome")), "%" + filter.sobrenome().toLowerCase() + "%"));
            }
            if (filter.cpf() != null && !filter.cpf().isBlank()) {
                predicates.add(cb.equal(root.get("cpf"), filter.cpf()));
            }
            if (filter.sexo() != null && !filter.sexo().isBlank()) {
                predicates.add(cb.equal(root.get("sexo"), filter.sexo()));
            }
            if (filter.profissao() != null && !filter.profissao().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("profissao")), "%" + filter.profissao().toLowerCase() + "%"));
            }
            if (filter.estadoCivil() != null && !filter.estadoCivil().isBlank()) {
                predicates.add(cb.equal(root.get("estadoCivil"), filter.estadoCivil()));
            }
            if (filter.dataCadastroInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataCadastro"), filter.dataCadastroInicio()));
            }
            if (filter.dataCadastroFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataCadastro"), filter.dataCadastroFim()));
            }
            if (filter.dataNascimentoInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataNascimento"), filter.dataNascimentoInicio()));
            }
            if (filter.dataNascimentoFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataNascimento"), filter.dataNascimentoFim()));
            }

            // Filtro por relacionamento ManyToOne (Endereco)
            if (filter.enderecoCidade() != null && !filter.enderecoCidade().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("endereco").get("cidade")), "%" + filter.enderecoCidade().toLowerCase() + "%"));
            }
            if (filter.enderecoEstado() != null && !filter.enderecoEstado().isBlank()) {
                predicates.add(cb.equal(root.get("endereco").get("estado"), filter.enderecoEstado()));
            }

            // Filtro por relacionamento ManyToOne (Contato)
            if (filter.contatoEmail() != null && !filter.contatoEmail().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("contato").get("email")), "%" + filter.contatoEmail().toLowerCase() + "%"));
            }
            if (filter.contatoCelular() != null && !filter.contatoCelular().isBlank()) {
                predicates.add(cb.like(root.get("contato").get("celular"), "%" + filter.contatoCelular() + "%"));
            }

            // Filtro por relacionamento OneToMany (ClienteVeiculo) para propriedade de Veiculo
            // Isso envolve fazer um JOIN com a tabela de junção e depois com a entidade Veiculo
            if (filter.veiculoPlaca() != null && !filter.veiculoPlaca().isBlank()) {
                Join<Cliente, ClienteVeiculo> clienteVeiculoJoin = root.join("clienteVeiculos");
                predicates.add(cb.equal(clienteVeiculoJoin.get("veiculo").get("placa"), filter.veiculoPlaca()));
            }
            if (filter.veiculoModelo() != null && !filter.veiculoModelo().isBlank()) {
                Join<Cliente, ClienteVeiculo> clienteVeiculoJoin = root.join("clienteVeiculos");
                predicates.add(cb.like(cb.lower(clienteVeiculoJoin.get("veiculo").get("modelo")), "%" + filter.veiculoModelo().toLowerCase() + "%"));
            }

            query.distinct(true); // Evitar duplicação de resultados ao usar joins para coleções

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\specification\ContatoSpecification.java   |   package br.com.fiap.mottu.specification   |   class ContatoSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\specification\ContatoSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.ContatoFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Contato;
import jakarta.persistence.criteria.Predicate;
import jakarta.persistence.criteria.Join;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class ContatoSpecification {

    public static Specification<Contato> withFilters(ContatoFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.email() != null && !filter.email().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("email")), "%" + filter.email().toLowerCase() + "%"));
            }
            if (filter.ddd() != null) {
                predicates.add(cb.equal(root.get("ddd"), filter.ddd()));
            }
            if (filter.ddi() != null) {
                predicates.add(cb.equal(root.get("ddi"), filter.ddi()));
            }
            if (filter.telefone1() != null && !filter.telefone1().isBlank()) {
                predicates.add(cb.like(root.get("telefone1"), "%" + filter.telefone1() + "%"));
            }
            if (filter.celular() != null && !filter.celular().isBlank()) {
                predicates.add(cb.like(root.get("celular"), "%" + filter.celular() + "%"));
            }
            if (filter.observacao() != null && !filter.observacao().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("observacao")), "%" + filter.observacao().toLowerCase() + "%"));
            }

            // Filtro por relacionamento OneToMany (Cliente)
            if (filter.clienteNome() != null && !filter.clienteNome().isBlank()) {
                Join<Contato, br.com.fiap.mottu.model.Cliente> clienteJoin = root.join("clienteContatos"); // Mapeia para o nome da coleção em Contato
                predicates.add(cb.like(cb.lower(clienteJoin.get("nome")), "%" + filter.clienteNome().toLowerCase() + "%"));
            }

            query.distinct(true); // Evitar duplicação de resultados

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\specification\EnderecoSpecification.java   |   package br.com.fiap.mottu.specification   |   class EnderecoSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\specification\EnderecoSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.EnderecoFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Endereco;
import jakarta.persistence.criteria.Predicate;
import jakarta.persistence.criteria.Join;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class EnderecoSpecification {

    public static Specification<Endereco> withFilters(EnderecoFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.cep() != null && !filter.cep().isBlank()) {
                predicates.add(cb.equal(root.get("cep"), filter.cep()));
            }
            if (filter.numero() != null) {
                predicates.add(cb.equal(root.get("numero"), filter.numero()));
            }
            if (filter.logradouro() != null && !filter.logradouro().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("logradouro")), "%" + filter.logradouro().toLowerCase() + "%"));
            }
            if (filter.bairro() != null && !filter.bairro().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("bairro")), "%" + filter.bairro().toLowerCase() + "%"));
            }
            if (filter.cidade() != null && !filter.cidade().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("cidade")), "%" + filter.cidade().toLowerCase() + "%"));
            }
            if (filter.estado() != null && !filter.estado().isBlank()) {
                predicates.add(cb.equal(root.get("estado"), filter.estado()));
            }
            if (filter.pais() != null && !filter.pais().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("pais")), "%" + filter.pais().toLowerCase() + "%"));
            }
            if (filter.observacao() != null && !filter.observacao().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("observacao")), "%" + filter.observacao().toLowerCase() + "%"));
            }

            // Filtro por relacionamento OneToMany (Cliente)
            if (filter.clienteNome() != null && !filter.clienteNome().isBlank()) {
                Join<Endereco, br.com.fiap.mottu.model.Cliente> clienteJoin = root.join("clienteEnderecos"); // Mapeia para o nome da coleção em Endereco
                predicates.add(cb.like(cb.lower(clienteJoin.get("nome")), "%" + filter.clienteNome().toLowerCase() + "%"));
            }

            query.distinct(true); // Evitar duplicação de resultados

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\specification\PatioSpecification.java   |   package br.com.fiap.mottu.specification   |   class PatioSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\specification\PatioSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.PatioFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Patio;
import br.com.fiap.mottu.model.relacionamento.VeiculoPatio; // Exemplo de junção
import br.com.fiap.mottu.model.relacionamento.EnderecoPatio; // Exemplo de junção
import br.com.fiap.mottu.model.relacionamento.ContatoPatio; // Exemplo de junção
import br.com.fiap.mottu.model.relacionamento.ZonaPatio; // Exemplo de junção
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class PatioSpecification {

    public static Specification<Patio> withFilters(PatioFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.nomePatio() != null && !filter.nomePatio().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("nomePatio")), "%" + filter.nomePatio().toLowerCase() + "%"));
            }
            if (filter.dataEntradaInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataEntrada"), filter.dataEntradaInicio()));
            }
            if (filter.dataEntradaFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataEntrada"), filter.dataEntradaFim()));
            }
            if (filter.dataSaidaInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataSaida"), filter.dataSaidaInicio()));
            }
            if (filter.dataSaidaFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataSaida"), filter.dataSaidaFim()));
            }
            if (filter.observacao() != null && !filter.observacao().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("observacao")), "%" + filter.observacao().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (VeiculoPatio)
            if (filter.veiculoPlaca() != null && !filter.veiculoPlaca().isBlank()) {
                Join<Patio, VeiculoPatio> veiculoPatioJoin = root.join("veiculoPatios");
                predicates.add(cb.equal(veiculoPatioJoin.get("veiculo").get("placa"), filter.veiculoPlaca()));
            }

            // Filtro por relacionamento ManyToMany (EnderecoPatio)
            if (filter.enderecoCidade() != null && !filter.enderecoCidade().isBlank()) {
                Join<Patio, EnderecoPatio> enderecoPatioJoin = root.join("enderecoPatios");
                predicates.add(cb.like(cb.lower(enderecoPatioJoin.get("endereco").get("cidade")), "%" + filter.enderecoCidade().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (ContatoPatio)
            if (filter.contatoEmail() != null && !filter.contatoEmail().isBlank()) {
                Join<Patio, ContatoPatio> contatoPatioJoin = root.join("contatoPatios");
                predicates.add(cb.like(cb.lower(contatoPatioJoin.get("contato").get("email")), "%" + filter.contatoEmail().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (ZonaPatio)
            if (filter.zonaNome() != null && !filter.zonaNome().isBlank()) {
                Join<Patio, ZonaPatio> zonaPatioJoin = root.join("zonaPatios");
                predicates.add(cb.like(cb.lower(zonaPatioJoin.get("zona").get("nome")), "%" + filter.zonaNome().toLowerCase() + "%"));
            }

            query.distinct(true); // Evitar duplicação de resultados

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\specification\RastreamentoSpecification.java   |   package br.com.fiap.mottu.specification   |   class RastreamentoSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.RastreamentoFilter;
import br.com.fiap.mottu.model.Rastreamento;
import br.com.fiap.mottu.model.relacionamento.VeiculoRastreamento;
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;
import java.math.BigDecimal; // Importe BigDecimal!

public class RastreamentoSpecification {

    public static Specification<Rastreamento> withFilters(RastreamentoFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            // Filtros para IPS
            if (filter.ipsX() != null) {
                predicates.add(cb.equal(root.get("ipsX"), filter.ipsX()));
            }
            if (filter.ipsY() != null) {
                predicates.add(cb.equal(root.get("ipsY"), filter.ipsY()));
            }
            if (filter.ipsZ() != null) {
                predicates.add(cb.equal(root.get("ipsZ"), filter.ipsZ()));
            }

            // Filtros para GPRS
            if (filter.gprsLatitude() != null) {
                predicates.add(cb.equal(root.get("gprsLatitude"), filter.gprsLatitude()));
            }
            if (filter.gprsLongitude() != null) {
                predicates.add(cb.equal(root.get("gprsLongitude"), filter.gprsLongitude()));
            }
            if (filter.gprsAltitude() != null) {
                predicates.add(cb.equal(root.get("gprsAltitude"), filter.gprsAltitude()));
            }

            // Filtro por relacionamento ManyToMany (VeiculoRastreamento)
            if (filter.veiculoPlaca() != null && !filter.veiculoPlaca().isBlank()) {
                Join<Rastreamento, VeiculoRastreamento> veiculoRastreamentoJoin = root.join("veiculoRastreamentos");
                predicates.add(cb.equal(veiculoRastreamentoJoin.get("veiculo").get("placa"), filter.veiculoPlaca()));
            }

            query.distinct(true); // Evitar duplicação de resultados

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\specification\VeiculoSpecification.java   |   package br.com.fiap.mottu.specification   |   class VeiculoSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\specification\VeiculoSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.VeiculoFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Veiculo;
import br.com.fiap.mottu.model.relacionamento.ClienteVeiculo;
import br.com.fiap.mottu.model.relacionamento.VeiculoBox;
import br.com.fiap.mottu.model.relacionamento.VeiculoPatio;
import br.com.fiap.mottu.model.relacionamento.VeiculoZona;
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class VeiculoSpecification {

    public static Specification<Veiculo> withFilters(VeiculoFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.placa() != null && !filter.placa().isBlank()) {
                predicates.add(cb.equal(root.get("placa"), filter.placa()));
            }
            if (filter.renavam() != null && !filter.renavam().isBlank()) {
                predicates.add(cb.equal(root.get("renavam"), filter.renavam()));
            }
            if (filter.chassi() != null && !filter.chassi().isBlank()) {
                predicates.add(cb.equal(root.get("chassi"), filter.chassi()));
            }
            if (filter.fabricante() != null && !filter.fabricante().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("fabricante")), "%" + filter.fabricante().toLowerCase() + "%"));
            }
            if (filter.modelo() != null && !filter.modelo().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("modelo")), "%" + filter.modelo().toLowerCase() + "%"));
            }
            if (filter.motor() != null && !filter.motor().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("motor")), "%" + filter.motor().toLowerCase() + "%"));
            }
            if (filter.ano() != null) {
                predicates.add(cb.equal(root.get("ano"), filter.ano()));
            }
            if (filter.combustivel() != null && !filter.combustivel().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("combustivel")), "%" + filter.combustivel().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (ClienteVeiculo)
            if (filter.clienteCpf() != null && !filter.clienteCpf().isBlank()) {
                Join<Veiculo, ClienteVeiculo> clienteVeiculoJoin = root.join("clienteVeiculos");
                predicates.add(cb.equal(clienteVeiculoJoin.get("cliente").get("cpf"), filter.clienteCpf()));
            }

            // Filtro por relacionamento ManyToMany (VeiculoBox)
            if (filter.boxNome() != null && !filter.boxNome().isBlank()) {
                Join<Veiculo, VeiculoBox> veiculoBoxJoin = root.join("veiculoBoxes");
                predicates.add(cb.like(cb.lower(veiculoBoxJoin.get("box").get("nome")), "%" + filter.boxNome().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (VeiculoPatio)
            if (filter.patioNome() != null && !filter.patioNome().isBlank()) {
                Join<Veiculo, VeiculoPatio> veiculoPatioJoin = root.join("veiculoPatios");
                predicates.add(cb.like(cb.lower(veiculoPatioJoin.get("patio").get("nomePatio")), "%" + filter.patioNome().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (VeiculoZona)
            if (filter.zonaNome() != null && !filter.zonaNome().isBlank()) {
                Join<Veiculo, VeiculoZona> veiculoZonaJoin = root.join("veiculoZonas");
                predicates.add(cb.like(cb.lower(veiculoZonaJoin.get("zona").get("nome")), "%" + filter.zonaNome().toLowerCase() + "%"));
            }

            query.distinct(true); // Evitar duplicação de resultados

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\mottu\specification\ZonaSpecification.java   |   package br.com.fiap.mottu.specification   |   class ZonaSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Caminho do arquivo: br\com\fiap\mottu\specification\ZonaSpecification.java
package br.com.fiap.mottu.specification;

import br.com.fiap.mottu.filter.ZonaFilter; // Importa do novo pacote
import br.com.fiap.mottu.model.Zona;
import br.com.fiap.mottu.model.relacionamento.ZonaBox;
import br.com.fiap.mottu.model.relacionamento.ZonaPatio;
import br.com.fiap.mottu.model.relacionamento.VeiculoZona;
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class ZonaSpecification {

    public static Specification<Zona> withFilters(ZonaFilter filter) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (filter.nome() != null && !filter.nome().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("nome")), "%" + filter.nome().toLowerCase() + "%"));
            }
            if (filter.dataEntradaInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataEntrada"), filter.dataEntradaInicio()));
            }
            if (filter.dataEntradaFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataEntrada"), filter.dataEntradaFim()));
            }
            if (filter.dataSaidaInicio() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("dataSaida"), filter.dataSaidaInicio()));
            }
            if (filter.dataSaidaFim() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("dataSaida"), filter.dataSaidaFim()));
            }
            if (filter.observacao() != null && !filter.observacao().isBlank()) {
                predicates.add(cb.like(cb.lower(root.get("observacao")), "%" + filter.observacao().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (ZonaBox)
            if (filter.boxNome() != null && !filter.boxNome().isBlank()) {
                Join<Zona, ZonaBox> zonaBoxJoin = root.join("zonaBoxes");
                predicates.add(cb.like(cb.lower(zonaBoxJoin.get("box").get("nome")), "%" + filter.boxNome().toLowerCase() + "%"));
            }

            // Filtro por relacionamento ManyToMany (VeiculoZona)
            if (filter.veiculoPlaca() != null && !filter.veiculoPlaca().isBlank()) {
                Join<Zona, VeiculoZona> veiculoZonaJoin = root.join("veiculoZonas");
                predicates.add(cb.equal(veiculoZonaJoin.get("veiculo").get("placa"), filter.veiculoPlaca()));
            }

            // Filtro por relacionamento ManyToMany (ZonaPatio)
            if (filter.patioNome() != null && !filter.patioNome().isBlank()) {
                Join<Zona, ZonaPatio> zonaPatioJoin = root.join("zonaPatios");
                predicates.add(cb.like(cb.lower(zonaPatioJoin.get("patio").get("nomePatio")), "%" + filter.patioNome().toLowerCase() + "%"));
            }

            query.distinct(true); // Evitar duplicação de resultados

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// test\java\br\com\fiap\mottu\MottuApplicationTests.java   |   package br.com.fiap.mottu   |   class MottuApplicationTests
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.mottu;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class MottuApplicationTests {

	@Test
	void contextLoads() {
	}

}

